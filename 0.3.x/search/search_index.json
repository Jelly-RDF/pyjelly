{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyjelly","text":"<p>pyjelly is a Python implementation of Jelly, a high-performance binary serialization format and streaming protocol for RDF knowledge graphs. It works great with rdflib.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast reading and writing of RDF knowledge graphs in the Jelly format</li> <li>Seamless integration with rdflib</li> <li>Stream processing support for large datasets or streams of many RDF graphs/datasets</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting started</li> <li>Overview and supported features</li> <li>API reference</li> <li>Contributing \u2013 how to report issues, contribute code, and request features</li> </ul>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p>"},{"location":"#license","title":"License","text":"<p>The pyjelly library is licensed under the Apache 2.0 license.</p> <p>The development of the Jelly protocol, its implementations, and supporting tooling was co-funded by the European Union. More details.</p> <p></p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#pyjelly","title":"<code>pyjelly</code>","text":"<p>Modules:</p> Name Description <code>errors</code> <code>integrations</code> <code>jelly</code> <code>options</code> <code>parse</code> <code>serialize</code>"},{"location":"api/#pyjelly.errors","title":"<code>errors</code>","text":"<p>Classes:</p> Name Description <code>JellyConformanceError</code> <p>Raised when Jelly conformance is violated.</p> <code>JellyAssertionError</code> <p>Raised when a recommended assertion from the specification fails.</p> <code>JellyNotImplementedError</code> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.errors.JellyConformanceError","title":"<code>JellyConformanceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when Jelly conformance is violated.</p>"},{"location":"api/#pyjelly.errors.JellyAssertionError","title":"<code>JellyAssertionError</code>","text":"<p>               Bases: <code>AssertionError</code></p> <p>Raised when a recommended assertion from the specification fails.</p>"},{"location":"api/#pyjelly.errors.JellyNotImplementedError","title":"<code>JellyNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.integrations","title":"<code>integrations</code>","text":"<p>Modules:</p> Name Description <code>rdflib</code>"},{"location":"api/#pyjelly.integrations.rdflib","title":"<code>rdflib</code>","text":"<p>Modules:</p> Name Description <code>parse</code> <code>serialize</code> <p>Functions:</p> Name Description <code>register_extension_to_rdflib</code> <p>Make rdflib.util.guess_format discover Jelly format.</p>"},{"location":"api/#pyjelly.integrations.rdflib.register_extension_to_rdflib","title":"<code>register_extension_to_rdflib(extension='.jelly')</code>","text":"<p>Make rdflib.util.guess_format discover Jelly format.</p> <p>rdflib.util.guess_format(\"foo.jelly\") register_extension_to_rdflib() rdflib.util.guess_format(\"foo.jelly\") 'jelly'</p> Source code in <code>pyjelly/integrations/rdflib/__init__.py</code> <pre><code>def register_extension_to_rdflib(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Make [rdflib.util.guess_format][] discover Jelly format.\n\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    &gt;&gt;&gt; register_extension_to_rdflib()\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    'jelly'\n    \"\"\"\n    rdflib.util.SUFFIX_FORMAT_MAP[extension.removeprefix(\".\")] = \"jelly\"\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.parse","title":"<code>parse</code>","text":"<p>Classes:</p> Name Description <code>RDFLibAdapter</code> <p>RDFLib adapter class, is extended by triples and quads implementations.</p> <code>RDFLibTriplesAdapter</code> <p>Triples adapter RDFLib implementation.</p> <code>RDFLibQuadsAdapter</code> <p>Extended RDFLib adapter for the QUADS physical type.</p> <code>RDFLibGraphsAdapter</code> <p>Extension of RDFLibQuadsBaseAdapter for the GRAPHS physical type.</p> <code>RDFLibJellyParser</code> <p>Functions:</p> Name Description <code>parse_triples_stream</code> <p>Parse flat triple stream.</p> <code>parse_quads_stream</code> <p>Parse flat quads stream.</p> <code>parse_jelly_grouped</code> <p>Take jelly file and return generators based on the detected logical type.</p> <code>parse_jelly_flat</code> <p>Parse jelly file with FLAT physical type into one Graph/Dataset.</p> <code>RDFLibAdapter(options, parsing_mode=ParsingMode.FLAT)</code> <p>               Bases: <code>Adapter</code></p> <p>RDFLib adapter class, is extended by triples and quads implementations.</p> <p>Args:     Adapter (type): abstract adapter class</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def __init__(\n    self, options: ParserOptions, parsing_mode: ParsingMode = ParsingMode.FLAT\n) -&gt; None:\n    self.options = options\n    self.parsing_mode = parsing_mode\n</code></pre> <code>RDFLibTriplesAdapter(options, graph_factory, parsing_mode=ParsingMode.FLAT)</code> <p>               Bases: <code>RDFLibAdapter</code></p> <p>Triples adapter RDFLib implementation.</p> <p>Notes: has internal graph object which tracks     triples and namespaces and can get flushed between frames.</p> <p>Methods:</p> Name Description <code>frame</code> <p>Finalize one frame in triples stream.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n    graph_factory: Callable[[], Graph],\n    parsing_mode: ParsingMode = ParsingMode.FLAT,\n) -&gt; None:\n    super().__init__(options=options, parsing_mode=parsing_mode)\n    self.graph = graph_factory()\n    self.graph_factory = graph_factory\n    self.parsing_mode = parsing_mode\n</code></pre> <code>frame()</code> <p>Finalize one frame in triples stream.</p> <p>Returns:    Graph: frame content as a separate Graph         and starts a new Graph</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def frame(self) -&gt; Graph:\n    \"\"\"\n    Finalize one frame in triples stream.\n\n    Returns:\n       Graph: frame content as a separate Graph\n            and starts a new Graph\n\n    \"\"\"\n    this_graph = self.graph\n    self.graph = self.graph_factory()\n    return this_graph\n</code></pre> <code>RDFLibQuadsAdapter(options, dataset_factory, parsing_mode=ParsingMode.FLAT)</code> <p>               Bases: <code>RDFLibQuadsBaseAdapter</code></p> <p>Extended RDFLib adapter for the QUADS physical type.</p> <p>Notes:     Adds triples and namespaces directly to     dataset, so RDFLib handles the rest.</p> <p>Args:     RDFLibQuadsBaseAdapter (type): base quads adapter         (shared with graphs physical type)</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n    dataset_factory: Callable[[], Dataset],\n    parsing_mode: ParsingMode = ParsingMode.FLAT,\n) -&gt; None:\n    super().__init__(options=options, parsing_mode=parsing_mode)\n    self.dataset = dataset_factory()\n    self.dataset_factory = dataset_factory\n</code></pre> <code>RDFLibGraphsAdapter(options, dataset_factory, parsing_mode=ParsingMode.FLAT)</code> <p>               Bases: <code>RDFLibQuadsBaseAdapter</code></p> <p>Extension of RDFLibQuadsBaseAdapter for the GRAPHS physical type.</p> <p>Notes: introduces graph start/end, checks if graph exists,     dataset store management.</p> <p>Args:     RDFLibQuadsBaseAdapter (type): base adapter for quads management.</p> <p>Raises:     JellyConformanceError: if no graph_start was encountered</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n    dataset_factory: Callable[[], Dataset],\n    parsing_mode: ParsingMode = ParsingMode.FLAT,\n) -&gt; None:\n    super().__init__(\n        options=options,\n        dataset_factory=dataset_factory,\n        parsing_mode=parsing_mode,\n    )\n    self._graph_id = None\n</code></pre> <code>RDFLibJellyParser</code> <p>               Bases: <code>Parser</code></p> <p>Methods:</p> Name Description <code>parse</code> <p>Parse jelly file into provided RDFLib Graph.</p> <code>parse(source, sink)</code> <p>Parse jelly file into provided RDFLib Graph.</p> <p>Args:     source (InputSource): jelly file as buffered binary stream InputSource obj     sink (Graph): RDFLib Graph</p> <p>Raises:     TypeError: raises error if invalid input</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse(self, source: InputSource, sink: Graph) -&gt; None:\n    \"\"\"\n    Parse jelly file into provided RDFLib Graph.\n\n    Args:\n        source (InputSource): jelly file as buffered binary stream InputSource obj\n        sink (Graph): RDFLib Graph\n\n    Raises:\n        TypeError: raises error if invalid input\n\n    \"\"\"\n    inp = source.getByteStream()  # type: ignore[no-untyped-call]\n    if inp is None:\n        msg = \"expected source to be a stream of bytes\"\n        raise TypeError(msg)\n    parse_jelly_flat(\n        inp,\n        graph_factory=lambda: Graph(store=sink.store, identifier=sink.identifier),\n        dataset_factory=lambda: Dataset(store=sink.store),\n    )\n</code></pre> <code>parse_triples_stream(frames, options, graph_factory, parsing_mode=ParsingMode.FLAT)</code> <p>Parse flat triple stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options     graph_factory (Callable): Lambda to construct a graph     parsing_mode (ParsingMode): specifies whether this is         a flat or grouped parsing.</p> <p>Yields:     Generator[Graph]: RDFLib Graph(s)</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_triples_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n    graph_factory: Callable[[], Graph],\n    parsing_mode: ParsingMode = ParsingMode.FLAT,\n) -&gt; Generator[Graph]:\n    \"\"\"\n    Parse flat triple stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n        graph_factory (Callable): Lambda to construct a graph\n        parsing_mode (ParsingMode): specifies whether this is\n            a flat or grouped parsing.\n\n    Yields:\n        Generator[Graph]: RDFLib Graph(s)\n\n    \"\"\"\n    adapter = RDFLibTriplesAdapter(\n        options, graph_factory=graph_factory, parsing_mode=parsing_mode\n    )\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        g = decoder.decode_frame(frame)\n        if g is not None:\n            yield g\n\n    if parsing_mode is ParsingMode.FLAT:\n        yield adapter.graph\n</code></pre> <code>parse_quads_stream(frames, options, dataset_factory, parsing_mode=ParsingMode.FLAT)</code> <p>Parse flat quads stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options     dataset_factory (Callable): Lambda to construct a dataset     parsing_mode (ParsingMode): specifies whether this is         a flat or grouped parsing.</p> <p>Yields:     Generator[Dataset]: RDFLib dataset(s)</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_quads_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n    dataset_factory: Callable[[], Dataset],\n    parsing_mode: ParsingMode = ParsingMode.FLAT,\n) -&gt; Generator[Dataset]:\n    \"\"\"\n    Parse flat quads stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n        dataset_factory (Callable): Lambda to construct a dataset\n        parsing_mode (ParsingMode): specifies whether this is\n            a flat or grouped parsing.\n\n    Yields:\n        Generator[Dataset]: RDFLib dataset(s)\n\n    \"\"\"\n    adapter_class: type[RDFLibQuadsBaseAdapter]\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_QUADS:\n        adapter_class = RDFLibQuadsAdapter\n    else:\n        adapter_class = RDFLibGraphsAdapter\n    adapter = adapter_class(\n        options=options,\n        dataset_factory=dataset_factory,\n        parsing_mode=parsing_mode,\n    )\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        ds = decoder.decode_frame(frame)\n        if ds is not None:\n            yield ds\n\n    if parsing_mode is ParsingMode.FLAT:\n        yield adapter.dataset\n</code></pre> <code>parse_jelly_grouped(inp, graph_factory, dataset_factory)</code> <p>Take jelly file and return generators based on the detected logical type.</p> <p>Yields one graph/dataset per frame.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream     graph_factory (Callable): lambda to construct a Graph     dataset_factory (Callable): lambda to construct a Dataset</p> <p>Raises:     NotImplementedError: is raised if a logical type is not implemented</p> <p>Yields:     Generator[Any] | Generator[Dataset] | Generator[Graph]:         returns generators for graphs/datasets based on the type of input</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_grouped(\n    inp: IO[bytes],\n    graph_factory: Callable[[], Graph],\n    dataset_factory: Callable[[], Dataset],\n) -&gt; Generator[Any] | Generator[Graph] | Generator[Dataset]:\n    \"\"\"\n    Take jelly file and return generators based on the detected logical type.\n\n    Yields one graph/dataset per frame.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream\n        graph_factory (Callable): lambda to construct a Graph\n        dataset_factory (Callable): lambda to construct a Dataset\n\n    Raises:\n        NotImplementedError: is raised if a logical type is not implemented\n\n    Yields:\n        Generator[Any] | Generator[Dataset] | Generator[Graph]:\n            returns generators for graphs/datasets based on the type of input\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        yield from parse_triples_stream(\n            frames=frames,\n            options=options,\n            graph_factory=graph_factory,\n            parsing_mode=ParsingMode.GROUPED,\n        )\n        return\n\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        yield from parse_quads_stream(\n            frames=frames,\n            options=options,\n            dataset_factory=dataset_factory,\n            parsing_mode=ParsingMode.GROUPED,\n        )\n        return\n\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre> <code>parse_jelly_flat(inp, graph_factory, dataset_factory)</code> <p>Parse jelly file with FLAT physical type into one Graph/Dataset.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream     graph_factory (Callable): lambda to construct a Graph     dataset_factory (Callable): lambda to construct a Dataset</p> <p>Raises:     NotImplementedError: if physical type is not supported</p> <p>Returns:     RDFLib Graph or Dataset</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_flat(\n    inp: IO[bytes],\n    graph_factory: Callable[[], Graph],\n    dataset_factory: Callable[[], Dataset],\n) -&gt; Any | Dataset | Graph:\n    \"\"\"\n    Parse jelly file with FLAT physical type into one Graph/Dataset.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream\n        graph_factory (Callable): lambda to construct a Graph\n        dataset_factory (Callable): lambda to construct a Dataset\n\n    Raises:\n        NotImplementedError: if physical type is not supported\n\n    Returns:\n        RDFLib Graph or Dataset\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        return next(\n            parse_triples_stream(\n                frames=frames,\n                options=options,\n                graph_factory=graph_factory,\n                parsing_mode=ParsingMode.FLAT,\n            )\n        )\n\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        return next(\n            parse_quads_stream(\n                frames=frames,\n                options=options,\n                dataset_factory=dataset_factory,\n                parsing_mode=ParsingMode.FLAT,\n            )\n        )\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.serialize","title":"<code>serialize</code>","text":"<p>Classes:</p> Name Description <code>RDFLibTermEncoder</code> <code>RDFLibJellySerializer</code> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Functions:</p> Name Description <code>triples_stream_frames</code> <p>Serialize a Graph/Dataset into jelly frames.</p> <code>quads_stream_frames</code> <p>Serialize a Dataset into jelly frames.</p> <code>graphs_stream_frames</code> <p>Serialize a Dataset into jelly frames as a stream of graphs.</p> <code>RDFLibTermEncoder(lookup_preset=None)</code> <p>               Bases: <code>TermEncoder</code></p> <p>Methods:</p> Name Description <code>encode_any</code> <p>Encode term based on its RDFLib object.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def __init__(\n    self,\n    lookup_preset: options.LookupPreset | None = None,\n) -&gt; None:\n    if lookup_preset is None:\n        lookup_preset = options.LookupPreset()\n    self.lookup_preset = lookup_preset\n    self.names = LookupEncoder(lookup_size=lookup_preset.max_names)\n    self.prefixes = LookupEncoder(lookup_size=lookup_preset.max_prefixes)\n    self.datatypes = LookupEncoder(lookup_size=lookup_preset.max_datatypes)\n</code></pre> <code>encode_any(term, slot)</code> <p>Encode term based on its RDFLib object.</p> <p>Args:     term (object): term to encode     slot (Slot): its place in statement.</p> <p>Returns:     RowsAndTerm: encoded extra rows and a jelly term to encode</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def encode_any(self, term: object, slot: Slot) -&gt; RowsAndTerm:\n    \"\"\"\n    Encode term based on its RDFLib object.\n\n    Args:\n        term (object): term to encode\n        slot (Slot): its place in statement.\n\n    Returns:\n        RowsAndTerm: encoded extra rows and a jelly term to encode\n\n    \"\"\"\n    if slot is Slot.graph and term == DATASET_DEFAULT_GRAPH_ID:\n        return self.encode_default_graph()\n\n    if isinstance(term, rdflib.URIRef):\n        return self.encode_iri(term)\n\n    if isinstance(term, rdflib.Literal):\n        return self.encode_literal(\n            lex=str(term),\n            language=term.language,\n            # `datatype` is cast to `str` explicitly because\n            # `URIRef.__eq__` overrides `str.__eq__` in an incompatible manner\n            datatype=term.datatype and str(term.datatype),\n        )\n\n    if isinstance(term, rdflib.BNode):\n        return self.encode_bnode(str(term))\n\n    return super().encode_any(term, slot)  # error if not handled\n</code></pre> <code>RDFLibJellySerializer(store)</code> <p>               Bases: <code>Serializer</code></p> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Handles streaming RDF terms into Jelly frames using internal encoders. Supports only graphs and datasets (not quoted graphs).</p> <p>Methods:</p> Name Description <code>guess_options</code> <p>Guess the serializer options based on the store type.</p> <code>guess_stream</code> <p>Return an appropriate stream implementation for the given options.</p> <code>serialize</code> <p>Serialize self.store content to Jelly format.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def __init__(self, store: Graph) -&gt; None:\n    if isinstance(store, QuotedGraph):\n        msg = \"N3 format is not supported\"\n        raise NotImplementedError(msg)\n    super().__init__(store)\n</code></pre> <code>guess_options()</code> <p>Guess the serializer options based on the store type.</p> <p>RDFLibJellySerializer(Graph()).guess_options().logical_type 1 RDFLibJellySerializer(Dataset()).guess_options().logical_type 2</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_options(self) -&gt; SerializerOptions:\n    \"\"\"\n    Guess the serializer options based on the store type.\n\n    &gt;&gt;&gt; RDFLibJellySerializer(Graph()).guess_options().logical_type\n    1\n    &gt;&gt;&gt; RDFLibJellySerializer(Dataset()).guess_options().logical_type\n    2\n    \"\"\"\n    logical_type = (\n        jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS\n        if isinstance(self.store, Dataset)\n        else jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES\n    )\n    return SerializerOptions(logical_type=logical_type)\n</code></pre> <code>guess_stream(options)</code> <p>Return an appropriate stream implementation for the given options.</p> <p>graph_ser = RDFLibJellySerializer(Graph()) ds_ser = RDFLibJellySerializer(Dataset())</p> <p>type(graph_ser.guess_stream(graph_ser.guess_options()))  type(ds_ser.guess_stream(ds_ser.guess_options()))  Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_stream(self, options: SerializerOptions) -&gt; Stream:\n    \"\"\"\n    Return an appropriate stream implementation for the given options.\n\n    &gt;&gt;&gt; graph_ser = RDFLibJellySerializer(Graph())\n    &gt;&gt;&gt; ds_ser = RDFLibJellySerializer(Dataset())\n\n    &gt;&gt;&gt; type(graph_ser.guess_stream(graph_ser.guess_options()))\n    &lt;class 'pyjelly.serialize.streams.TripleStream'&gt;\n    &gt;&gt;&gt; type(ds_ser.guess_stream(ds_ser.guess_options()))\n    &lt;class 'pyjelly.serialize.streams.QuadStream'&gt;\n    \"\"\"\n    stream_cls: type[Stream]\n    if options.logical_type != jelly.LOGICAL_STREAM_TYPE_GRAPHS and isinstance(\n        self.store, Dataset\n    ):\n        stream_cls = QuadStream\n    else:\n        stream_cls = TripleStream\n    return stream_cls.for_rdflib(options=options)\n</code></pre> <code>serialize(out, /, *, stream=None, options=None, **unused)</code> <p>Serialize self.store content to Jelly format.</p> <p>Args:     out (IO[bytes]): output buffered writer     stream (Stream | None, optional): Jelly stream object. Defaults to None.     options (SerializerOptions | None, optional): Serializer options         if defined beforehand, e.g., read from a separate file.         Defaults to None.     **unused(Any): unused args for RDFLib serialize</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@override\ndef serialize(  # type: ignore[override]\n    self,\n    out: IO[bytes],\n    /,\n    *,\n    stream: Stream | None = None,\n    options: SerializerOptions | None = None,\n    **unused: Any,\n) -&gt; None:\n    \"\"\"\n    Serialize self.store content to Jelly format.\n\n    Args:\n        out (IO[bytes]): output buffered writer\n        stream (Stream | None, optional): Jelly stream object. Defaults to None.\n        options (SerializerOptions | None, optional): Serializer options\n            if defined beforehand, e.g., read from a separate file.\n            Defaults to None.\n        **unused(Any): unused args for RDFLib serialize\n\n    \"\"\"\n    if options is None:\n        options = self.guess_options()\n    if stream is None:\n        stream = self.guess_stream(options)\n    write = write_delimited if stream.options.params.delimited else write_single\n    for stream_frame in stream_frames(stream, self.store):\n        write(stream_frame, out)\n</code></pre> <code>triples_stream_frames(stream, data)</code> <p>Serialize a Graph/Dataset into jelly frames.</p> <p>Args:     stream (TripleStream): stream that specifies triples processing     data (Graph | Dataset): Graph/Dataset to serialize.</p> <p>Notes:     if Dataset is given, its graphs are unpacked and iterated over     if flow is GraphsFrameFlow, emits a frame per graph.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(TripleStream)\ndef triples_stream_frames(\n    stream: TripleStream,\n    data: Graph | Dataset,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Graph/Dataset into jelly frames.\n\n    Args:\n        stream (TripleStream): stream that specifies triples processing\n        data (Graph | Dataset): Graph/Dataset to serialize.\n\n    Notes:\n        if Dataset is given, its graphs are unpacked and iterated over\n        if flow is GraphsFrameFlow, emits a frame per graph.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)\n    graphs = (data,) if not isinstance(data, Dataset) else data.graphs()\n    for graph in graphs:\n        for terms in graph:\n            if frame := stream.triple(terms):\n                yield frame\n        # this part turns each graph to a frame for graphs logical type\n        if frame := stream.flow.frame_from_graph():\n            yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>quads_stream_frames(stream, data)</code> <p>Serialize a Dataset into jelly frames.</p> <p>Notes:     Emits one frame per dataset if flow is of DatasetsFrameFlow.</p> <p>Args:     stream (QuadStream): stream that specifies quads processing     data (Dataset): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register\ndef quads_stream_frames(\n    stream: QuadStream,\n    data: Dataset,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Dataset into jelly frames.\n\n    Notes:\n        Emits one frame per dataset if flow is of DatasetsFrameFlow.\n\n    Args:\n        stream (QuadStream): stream that specifies quads processing\n        data (Dataset): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    assert isinstance(data, Dataset)\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)\n    for terms in data.quads():\n        if frame := stream.quad(terms):\n            yield frame\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>graphs_stream_frames(stream, data)</code> <p>Serialize a Dataset into jelly frames as a stream of graphs.</p> <p>Notes:     If flow of DatasetsFrameFlow type, the whole dataset     will be encoded into one frame.</p> <p>Args:     stream (GraphStream): stream that specifies graphs processing     data (Dataset): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register\ndef graphs_stream_frames(\n    stream: GraphStream,\n    data: Dataset,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Dataset into jelly frames as a stream of graphs.\n\n    Notes:\n        If flow of DatasetsFrameFlow type, the whole dataset\n        will be encoded into one frame.\n\n    Args:\n        stream (GraphStream): stream that specifies graphs processing\n        data (Dataset): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    assert isinstance(data, Dataset)\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)\n    for graph in data.graphs():\n        yield from stream.graph(graph_id=graph.identifier, graph=graph)\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre>"},{"location":"api/#pyjelly.jelly","title":"<code>jelly</code>","text":"<p>Modules:</p> Name Description <code>rdf_pb2</code> <p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.jelly.rdf_pb2","title":"<code>rdf_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.options","title":"<code>options</code>","text":"<p>Functions:</p> Name Description <code>register_mimetypes</code> <p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>Attributes:</p> Name Type Description <code>INTEGRATION_SIDE_EFFECTS</code> <code>bool</code> <p>Whether to allow integration module imports to trigger side effects.</p>"},{"location":"api/#pyjelly.options.INTEGRATION_SIDE_EFFECTS","title":"<code>INTEGRATION_SIDE_EFFECTS = True</code>","text":"<p>Whether to allow integration module imports to trigger side effects.</p> <p>These side effects are cheap and may include populating some registries for guessing the defaults for external integrations that work with Jelly.</p>"},{"location":"api/#pyjelly.options.register_mimetypes","title":"<code>register_mimetypes(extension='.jelly')</code>","text":"<p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>register_mimetypes() mimetypes.guess_type(\"out.jelly\") ('application/x-jelly-rdf', None)</p> Source code in <code>pyjelly/options.py</code> <pre><code>def register_mimetypes(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Associate files that have Jelly extension with Jelly MIME types.\n\n    &gt;&gt;&gt; register_mimetypes()\n    &gt;&gt;&gt; mimetypes.guess_type(\"out.jelly\")\n    ('application/x-jelly-rdf', None)\n    \"\"\"\n    for mimetype in MIMETYPES:\n        mimetypes.add_type(mimetype, extension)\n</code></pre>"},{"location":"api/#pyjelly.parse","title":"<code>parse</code>","text":"<p>Modules:</p> Name Description <code>decode</code> <code>ioutils</code> <code>lookup</code>"},{"location":"api/#pyjelly.parse.decode","title":"<code>decode</code>","text":"<p>Classes:</p> Name Description <code>ParsingMode</code> <p>Specifies how jelly frames should be treated.</p> <code>Decoder</code> <p>Functions:</p> Name Description <code>options_from_frame</code> <p>Fill stream options based on the options row.</p>"},{"location":"api/#pyjelly.parse.decode.ParsingMode","title":"<code>ParsingMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies how jelly frames should be treated.</p> <p>Modes: FLAT     Yield all frames as one Graph or Dataset. GROUPED     Yield one Graph/Dataset per frame (grouped parsing).</p>"},{"location":"api/#pyjelly.parse.decode.Decoder","title":"<code>Decoder(adapter)</code>","text":"<p>Initializes decoder with a lookup tables with preset sizes, integration-dependent adapter and empty repeated terms dictionary.</p> <p>Args:     adapter (Adapter): integration-dependent adapter that specifies terms     conversion to specific objects, framing,     namespace declarations, and graphs/datasets forming.</p> <p>Methods:</p> Name Description <code>decode_frame</code> <p>Decode a frame to custom object based on adapter implementation.</p> <code>decode_row</code> <p>Decode a row based on its type.</p> <code>ingest_prefix_entry</code> <p>Update prefix lookup table based on the table entry.</p> <code>ingest_name_entry</code> <p>Update name lookup table based on the table entry.</p> <code>ingest_datatype_entry</code> <p>Update datatype lookup table based on the table entry.</p> <code>decode_term</code> <p>Decode a term based on its type: IRI/literal/BN/default graph.</p> <code>decode_iri</code> <p>Decode RdfIri message to IRI using a custom adapter.</p> <code>decode_bnode</code> <p>Decode string message to blank node (BN) using a custom adapter.</p> <code>decode_literal</code> <p>Decode RdfLiteral to literal based on custom adapter implementation.</p> <code>decode_statement</code> <p>Decode a triple/quad message.</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def __init__(self, adapter: Adapter) -&gt; None:\n    \"\"\"\n    Initialize decoder.\n\n    Initializes decoder with a lookup tables with preset sizes,\n    integration-dependent adapter and empty repeated terms dictionary.\n\n    Args:\n        adapter (Adapter): integration-dependent adapter that specifies terms\n        conversion to specific objects, framing,\n        namespace declarations, and graphs/datasets forming.\n\n    \"\"\"\n    self.adapter = adapter\n    self.names = LookupDecoder(lookup_size=self.options.lookup_preset.max_names)\n    self.prefixes = LookupDecoder(\n        lookup_size=self.options.lookup_preset.max_prefixes\n    )\n    self.datatypes = LookupDecoder(\n        lookup_size=self.options.lookup_preset.max_datatypes\n    )\n    self.repeated_terms: dict[str, jelly.RdfIri | str | jelly.RdfLiteral] = {}\n</code></pre> <code>decode_frame(frame)</code> <p>Decode a frame to custom object based on adapter implementation.</p> <p>Args:     frame (jelly.RdfStreamFrame): jelly frame</p> <p>Returns:     Any: custom obj based on adapter logic</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_frame(self, frame: jelly.RdfStreamFrame) -&gt; Any:\n    \"\"\"\n    Decode a frame to custom object based on adapter implementation.\n\n    Args:\n        frame (jelly.RdfStreamFrame): jelly frame\n\n    Returns:\n        Any: custom obj based on adapter logic\n\n    \"\"\"\n    for row_owner in frame.rows:\n        row = getattr(row_owner, row_owner.WhichOneof(\"row\"))\n        self.decode_row(row)\n    if self.adapter.parsing_mode is ParsingMode.GROUPED:\n        return self.adapter.frame()\n    return None\n</code></pre> <code>decode_row(row)</code> <p>Decode a row based on its type.</p> <p>Notes: uses custom adapters to decode triples/quads, namespace declarations,        graph start/end.</p> <p>Args:     row (Any): protobuf row message</p> <p>Raises:     TypeError: raises error if this type of protobuf message does not have                a respective handler</p> <p>Returns:     Any | None: decoded row -                 result from calling decode_row (row type appropriate handler)</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_row(self, row: Any) -&gt; Any | None:\n    \"\"\"\n    Decode a row based on its type.\n\n    Notes: uses custom adapters to decode triples/quads, namespace declarations,\n           graph start/end.\n\n    Args:\n        row (Any): protobuf row message\n\n    Raises:\n        TypeError: raises error if this type of protobuf message does not have\n                   a respective handler\n\n    Returns:\n        Any | None: decoded row -\n                    result from calling decode_row (row type appropriate handler)\n\n    \"\"\"\n    try:\n        decode_row = self.row_handlers[type(row)]\n    except KeyError:\n        msg = f\"decoder not implemented for {type(row)}\"\n        raise TypeError(msg) from None\n    return decode_row(self, row)\n</code></pre> <code>ingest_prefix_entry(entry)</code> <p>Update prefix lookup table based on the table entry.</p> <p>Args:     entry (jelly.RdfPrefixEntry): prefix message, containing id and value</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def ingest_prefix_entry(self, entry: jelly.RdfPrefixEntry) -&gt; None:\n    \"\"\"\n    Update prefix lookup table based on the table entry.\n\n    Args:\n        entry (jelly.RdfPrefixEntry): prefix message, containing id and value\n\n    \"\"\"\n    self.prefixes.assign_entry(index=entry.id, value=entry.value)\n</code></pre> <code>ingest_name_entry(entry)</code> <p>Update name lookup table based on the table entry.</p> <p>Args:     entry (jelly.RdfNameEntry): name message, containing id and value</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def ingest_name_entry(self, entry: jelly.RdfNameEntry) -&gt; None:\n    \"\"\"\n    Update name lookup table based on the table entry.\n\n    Args:\n        entry (jelly.RdfNameEntry): name message, containing id and value\n\n    \"\"\"\n    self.names.assign_entry(index=entry.id, value=entry.value)\n</code></pre> <code>ingest_datatype_entry(entry)</code> <p>Update datatype lookup table based on the table entry.</p> <p>Args:     entry (jelly.RdfDatatypeEntry): name message, containing id and value</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def ingest_datatype_entry(self, entry: jelly.RdfDatatypeEntry) -&gt; None:\n    \"\"\"\n    Update datatype lookup table based on the table entry.\n\n    Args:\n        entry (jelly.RdfDatatypeEntry): name message, containing id and value\n\n    \"\"\"\n    self.datatypes.assign_entry(index=entry.id, value=entry.value)\n</code></pre> <code>decode_term(term)</code> <p>Decode a term based on its type: IRI/literal/BN/default graph.</p> <p>Notes: requires a custom adapter with implemented methods for terms decoding.</p> <p>Args:     term (Any): IRI/literal/BN(string)/Default graph message</p> <p>Raises:     TypeError: raises error if no handler for the term is found</p> <p>Returns:     Any: decoded term (currently, rdflib objects, e.g., rdflib.term.URIRef)</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_term(self, term: Any) -&gt; Any:\n    \"\"\"\n    Decode a term based on its type: IRI/literal/BN/default graph.\n\n    Notes: requires a custom adapter with implemented methods for terms decoding.\n\n    Args:\n        term (Any): IRI/literal/BN(string)/Default graph message\n\n    Raises:\n        TypeError: raises error if no handler for the term is found\n\n    Returns:\n        Any: decoded term (currently, rdflib objects, e.g., rdflib.term.URIRef)\n\n    \"\"\"\n    try:\n        decode_term = self.term_handlers[type(term)]\n    except KeyError:\n        msg = f\"decoder not implemented for {type(term)}\"\n        raise TypeError(msg) from None\n    return decode_term(self, term)\n</code></pre> <code>decode_iri(iri)</code> <p>Decode RdfIri message to IRI using a custom adapter.</p> <p>Args:     iri (jelly.RdfIri): RdfIri message</p> <p>Returns:     Any: IRI, based on adapter implementation, e.g., rdflib.term.URIRef</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_iri(self, iri: jelly.RdfIri) -&gt; Any:\n    \"\"\"\n    Decode RdfIri message to IRI using a custom adapter.\n\n    Args:\n        iri (jelly.RdfIri): RdfIri message\n\n    Returns:\n        Any: IRI, based on adapter implementation, e.g., rdflib.term.URIRef\n\n    \"\"\"\n    name = self.names.decode_name_term_index(iri.name_id)\n    prefix = self.prefixes.decode_prefix_term_index(iri.prefix_id)\n    return self.adapter.iri(iri=prefix + name)\n</code></pre> <code>decode_bnode(bnode)</code> <p>Decode string message to blank node (BN) using a custom adapter.</p> <p>Args:     bnode (str): blank node id</p> <p>Returns:     Any: blank node object from the custom adapter</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_bnode(self, bnode: str) -&gt; Any:\n    \"\"\"\n    Decode string message to blank node (BN) using a custom adapter.\n\n    Args:\n        bnode (str): blank node id\n\n    Returns:\n        Any: blank node object from the custom adapter\n\n    \"\"\"\n    return self.adapter.bnode(bnode)\n</code></pre> <code>decode_literal(literal)</code> <p>Decode RdfLiteral to literal based on custom adapter implementation.</p> <p>Notes: checks for langtag existence;        for datatype checks for non-zero table size and datatype field presence</p> <p>Args:     literal (jelly.RdfLiteral): RdfLiteral message</p> <p>Returns:     Any: literal returned by the custom adapter</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_literal(self, literal: jelly.RdfLiteral) -&gt; Any:\n    \"\"\"\n    Decode RdfLiteral to literal based on custom adapter implementation.\n\n    Notes: checks for langtag existence;\n           for datatype checks for non-zero table size and datatype field presence\n\n    Args:\n        literal (jelly.RdfLiteral): RdfLiteral message\n\n    Returns:\n        Any: literal returned by the custom adapter\n\n    \"\"\"\n    language = datatype = None\n    if literal.langtag:\n        language = literal.langtag\n    elif self.datatypes.lookup_size and literal.HasField(\"datatype\"):\n        datatype = self.datatypes.decode_datatype_term_index(literal.datatype)\n    return self.adapter.literal(\n        lex=literal.lex,\n        language=language,\n        datatype=datatype,\n    )\n</code></pre> <code>decode_statement(statement, oneofs)</code> <p>Decode a triple/quad message.</p> <p>Notes: also updates repeated terms dictionary</p> <p>Args:     statement (jelly.RdfTriple | jelly.RdfQuad): triple/quad message     oneofs (Sequence[str]): terms s/p/o/g(if quads)</p> <p>Raises:     ValueError: if a missing repeated term is encountered</p> <p>Returns:     Any: a list of decoded terms</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_statement(\n    self,\n    statement: jelly.RdfTriple | jelly.RdfQuad,\n    oneofs: Sequence[str],\n) -&gt; Any:\n    \"\"\"\n    Decode a triple/quad message.\n\n    Notes: also updates repeated terms dictionary\n\n    Args:\n        statement (jelly.RdfTriple | jelly.RdfQuad): triple/quad message\n        oneofs (Sequence[str]): terms s/p/o/g(if quads)\n\n    Raises:\n        ValueError: if a missing repeated term is encountered\n\n    Returns:\n        Any: a list of decoded terms\n\n    \"\"\"\n    terms = []\n    for oneof in oneofs:\n        field = statement.WhichOneof(oneof)\n        if field:\n            jelly_term = getattr(statement, field)\n            decoded_term = self.decode_term(jelly_term)\n            self.repeated_terms[oneof] = decoded_term\n        else:\n            decoded_term = self.repeated_terms[oneof]\n            if decoded_term is None:\n                msg = f\"missing repeated term {oneof}\"\n                raise ValueError(msg)\n        terms.append(decoded_term)\n    return terms\n</code></pre>"},{"location":"api/#pyjelly.parse.decode.options_from_frame","title":"<code>options_from_frame(frame, *, delimited)</code>","text":"<p>Fill stream options based on the options row.</p> <p>Notes:     generalized_statements, rdf_star, and namespace declarations     are set to false by default</p> <p>Args:     frame (jelly.RdfStreamFrame): first non-empty frame from the stream     delimited (bool): derived delimited flag</p> <p>Returns:     ParserOptions: filled options with types/lookups/stream parameters information</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def options_from_frame(\n    frame: jelly.RdfStreamFrame,\n    *,\n    delimited: bool,\n) -&gt; ParserOptions:\n    \"\"\"\n    Fill stream options based on the options row.\n\n    Notes:\n        generalized_statements, rdf_star, and namespace declarations\n        are set to false by default\n\n    Args:\n        frame (jelly.RdfStreamFrame): first non-empty frame from the stream\n        delimited (bool): derived delimited flag\n\n    Returns:\n        ParserOptions: filled options with types/lookups/stream parameters information\n\n    \"\"\"\n    row = frame.rows[0]\n    options = row.options\n    return ParserOptions(\n        stream_types=StreamTypes(\n            physical_type=options.physical_type,\n            logical_type=options.logical_type,\n        ),\n        lookup_preset=LookupPreset(\n            max_names=options.max_name_table_size,\n            max_prefixes=options.max_prefix_table_size,\n            max_datatypes=options.max_datatype_table_size,\n        ),\n        params=StreamParameters(\n            stream_name=options.stream_name,\n            version=options.version,\n            delimited=delimited,\n        ),\n    )\n</code></pre>"},{"location":"api/#pyjelly.parse.ioutils","title":"<code>ioutils</code>","text":"<p>Functions:</p> Name Description <code>delimited_jelly_hint</code> <p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <code>get_options_and_frames</code> <p>Return stream options and frames from the buffered binary stream.</p>"},{"location":"api/#pyjelly.parse.ioutils.delimited_jelly_hint","title":"<code>delimited_jelly_hint(header)</code>","text":"<p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <p>Truth table (notation: <code>0A</code> = <code>0x0A</code>, <code>NN</code> = <code>not 0x0A</code>, <code>??</code> = don't care):</p> Byte 1 Byte 2 Byte 3 Result <code>NN</code> <code>??</code> <code>??</code> Delimited <code>0A</code> <code>NN</code> <code>??</code> Non-delimited <code>0A</code> <code>0A</code> <code>NN</code> Delimited (size = 10) <code>0A</code> <code>0A</code> <code>0A</code> Non-delimited (stream options size = 10) <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x00])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A])) False</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def delimited_jelly_hint(header: bytes) -&gt; bool:\n    \"\"\"\n    Detect whether a Jelly file is delimited from its first 3 bytes.\n\n    Truth table (notation: `0A` = `0x0A`, `NN` = `not 0x0A`, `??` = _don't care_):\n\n    | Byte 1 | Byte 2 | Byte 3 | Result                                   |\n    |--------|--------|--------|------------------------------------------|\n    | `NN`   |  `??`  |  `??`  | Delimited                                |\n    | `0A`   |  `NN`  |  `??`  | Non-delimited                            |\n    | `0A`   |  `0A`  |  `NN`  | Delimited (size = 10)                    |\n    | `0A`   |  `0A`  |  `0A`  | Non-delimited (stream options size = 10) |\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x00]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A]))\n    False\n    \"\"\"\n    magic = 0x0A\n    return len(header) == 3 and (  # noqa: PLR2004\n        header[0] != magic or (header[1] == magic and header[2] != magic)\n    )\n</code></pre>"},{"location":"api/#pyjelly.parse.ioutils.get_options_and_frames","title":"<code>get_options_and_frames(inp)</code>","text":"<p>Return stream options and frames from the buffered binary stream.</p> <p>Args:     inp (IO[bytes]): jelly buffered binary stream</p> <p>Raises:     JellyConformanceError: if no non-empty frames detected in the delimited stream     JellyConformanceError: if non-delimited,         error is raised if no rows are detected (empty frame)</p> <p>Returns:     tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]: ParserOptions holds:         stream types, lookup presets and other stream options</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def get_options_and_frames(\n    inp: IO[bytes],\n) -&gt; tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]:\n    \"\"\"\n    Return stream options and frames from the buffered binary stream.\n\n    Args:\n        inp (IO[bytes]): jelly buffered binary stream\n\n    Raises:\n        JellyConformanceError: if no non-empty frames detected in the delimited stream\n        JellyConformanceError: if non-delimited,\n            error is raised if no rows are detected (empty frame)\n\n    Returns:\n        tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]: ParserOptions holds:\n            stream types, lookup presets and other stream options\n\n    \"\"\"\n    is_delimited = delimited_jelly_hint(bytes_read := inp.read(3))\n    inp.seek(-len(bytes_read), os.SEEK_CUR)\n\n    if is_delimited:\n        frames = frame_iterator(inp)\n        first_frame = next(frames, None)\n        if first_frame is None:\n            msg = \"No non-empty frames found in the stream\"\n            raise JellyConformanceError(msg)\n\n        options = options_from_frame(first_frame, delimited=True)\n        return options, chain((first_frame,), frames)\n\n    frame = parse(jelly.RdfStreamFrame, inp.read())\n\n    if not frame.rows:\n        msg = \"The stream is corrupted (only contains an empty frame)\"\n        raise JellyConformanceError(msg)\n\n    options = options_from_frame(frame, delimited=False)\n    return options, iter((frame,))\n</code></pre>"},{"location":"api/#pyjelly.parse.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>LookupDecoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.parse.lookup.LookupDecoder","title":"<code>LookupDecoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required Source code in <code>pyjelly/parse/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    if lookup_size &gt; MAX_LOOKUP_SIZE:\n        msg = f\"lookup size must be less than {MAX_LOOKUP_SIZE}\"\n        raise JellyAssertionError(msg)\n    self.lookup_size = lookup_size\n    placeholders = (None,) * lookup_size\n    self.data: deque[str | None] = deque(placeholders, maxlen=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre>"},{"location":"api/#pyjelly.serialize","title":"<code>serialize</code>","text":"<p>Modules:</p> Name Description <code>encode</code> <code>flows</code> <code>lookup</code> <code>streams</code>"},{"location":"api/#pyjelly.serialize.encode","title":"<code>encode</code>","text":"<p>Classes:</p> Name Description <code>TermEncoder</code> <code>Slot</code> <p>Slots for encoding RDF terms.</p> <p>Functions:</p> Name Description <code>split_iri</code> <p>Split iri into prefix and name.</p> <code>encode_statement</code> <p>Encode a statement.</p> <code>encode_triple</code> <p>Encode one triple.</p> <code>encode_quad</code> <p>Encode one quad.</p> <code>encode_namespace_declaration</code> <p>Encode namespace declaration.</p> <code>encode_options</code> <p>Encode stream options to ProtoBuf message.</p>"},{"location":"api/#pyjelly.serialize.encode.TermEncoder","title":"<code>TermEncoder(lookup_preset=None)</code>","text":"<p>Methods:</p> Name Description <code>encode_iri</code> <p>Encode iri.</p> <code>encode_default_graph</code> <p>Encode default graph.</p> <code>encode_bnode</code> <p>Encode blank node (BN).</p> <code>encode_literal</code> <p>Encode literal.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def __init__(\n    self,\n    lookup_preset: options.LookupPreset | None = None,\n) -&gt; None:\n    if lookup_preset is None:\n        lookup_preset = options.LookupPreset()\n    self.lookup_preset = lookup_preset\n    self.names = LookupEncoder(lookup_size=lookup_preset.max_names)\n    self.prefixes = LookupEncoder(lookup_size=lookup_preset.max_prefixes)\n    self.datatypes = LookupEncoder(lookup_size=lookup_preset.max_datatypes)\n</code></pre> <code>encode_iri(iri_string)</code> <p>Encode iri.</p> <p>Args:     iri_string (str): full iri in string format.</p> <p>Returns:     RowsAnd[jelly.RdfIri]: extra rows and protobuf RdfIri message.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_iri(self, iri_string: str) -&gt; RowsAnd[jelly.RdfIri]:\n    \"\"\"\n    Encode iri.\n\n    Args:\n        iri_string (str): full iri in string format.\n\n    Returns:\n        RowsAnd[jelly.RdfIri]: extra rows and protobuf RdfIri message.\n\n    \"\"\"\n    prefix, name = split_iri(iri_string)\n    if self.prefixes.lookup.max_size:\n        prefix_entry_index = self.prefixes.encode_entry_index(prefix)\n    else:\n        name = iri_string\n        prefix_entry_index = None\n\n    name_entry_index = self.names.encode_entry_index(name)\n    term_rows = []\n\n    if prefix_entry_index is not None:\n        prefix_entry = jelly.RdfPrefixEntry(id=prefix_entry_index, value=prefix)\n        term_rows.append(jelly.RdfStreamRow(prefix=prefix_entry))\n\n    if name_entry_index is not None:\n        name_entry = jelly.RdfNameEntry(id=name_entry_index, value=name)\n        term_rows.append(jelly.RdfStreamRow(name=name_entry))\n\n    prefix_index = self.prefixes.encode_prefix_term_index(prefix)\n    name_index = self.names.encode_name_term_index(name)\n    return term_rows, jelly.RdfIri(prefix_id=prefix_index, name_id=name_index)\n</code></pre> <code>encode_default_graph()</code> <p>Encode default graph.</p> <p>Returns:     RowsAnd[jelly.RdfDefaultGraph]: empty extra rows and         default graph message.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_default_graph(self) -&gt; RowsAnd[jelly.RdfDefaultGraph]:\n    \"\"\"\n    Encode default graph.\n\n    Returns:\n        RowsAnd[jelly.RdfDefaultGraph]: empty extra rows and\n            default graph message.\n\n    \"\"\"\n    return (), jelly.RdfDefaultGraph()\n</code></pre> <code>encode_bnode(bnode)</code> <p>Encode blank node (BN).</p> <p>Args:     bnode (str): BN internal identifier in string format.</p> <p>Returns:     RowsAnd[str]: empty extra rows and original BN string.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_bnode(self, bnode: str) -&gt; RowsAnd[str]:\n    \"\"\"\n    Encode blank node (BN).\n\n    Args:\n        bnode (str): BN internal identifier in string format.\n\n    Returns:\n        RowsAnd[str]: empty extra rows and original BN string.\n\n    \"\"\"\n    return (), bnode\n</code></pre> <code>encode_literal(*, lex, language=None, datatype=None)</code> <p>Encode literal.</p> <p>Args:     lex (str): lexical form/literal value     language (str | None, optional): langtag. Defaults to None.     datatype (str | None, optional): data type if     it is a typed literal. Defaults to None.</p> <p>Raises:     JellyConformanceError: if datatype specified while         datatable is not used.</p> <p>Returns:     RowsAnd[jelly.RdfLiteral]: extra rows (i.e., datatype entries)         and RdfLiteral message.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_literal(\n    self,\n    *,\n    lex: str,\n    language: str | None = None,\n    datatype: str | None = None,\n) -&gt; RowsAnd[jelly.RdfLiteral]:\n    \"\"\"\n    Encode literal.\n\n    Args:\n        lex (str): lexical form/literal value\n        language (str | None, optional): langtag. Defaults to None.\n        datatype (str | None, optional): data type if\n        it is a typed literal. Defaults to None.\n\n    Raises:\n        JellyConformanceError: if datatype specified while\n            datatable is not used.\n\n    Returns:\n        RowsAnd[jelly.RdfLiteral]: extra rows (i.e., datatype entries)\n            and RdfLiteral message.\n\n    \"\"\"\n    datatype_id = None\n    term_rows: tuple[()] | tuple[jelly.RdfStreamRow] = ()\n\n    if datatype and datatype != options.STRING_DATATYPE_IRI:\n        if self.datatypes.lookup.max_size == 0:\n            msg = (\n                f\"can't encode literal with type {datatype}: \"\n                \"datatype lookup cannot be used if disabled \"\n                \"(its size was set to 0)\"\n            )\n            raise JellyConformanceError(msg)\n        datatype_entry_id = self.datatypes.encode_entry_index(datatype)\n\n        if datatype_entry_id is not None:\n            entry = jelly.RdfDatatypeEntry(id=datatype_entry_id, value=datatype)\n            term_rows = (jelly.RdfStreamRow(datatype=entry),)\n\n        datatype_id = self.datatypes.encode_datatype_term_index(datatype)\n\n    return term_rows, jelly.RdfLiteral(\n        lex=lex,\n        langtag=language,\n        datatype=datatype_id,\n    )\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.Slot","title":"<code>Slot</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Slots for encoding RDF terms.</p>"},{"location":"api/#pyjelly.serialize.encode.split_iri","title":"<code>split_iri(iri_string)</code>","text":"<p>Split iri into prefix and name.</p> <p>Args:     iri_string (str): full iri string.</p> <p>Returns:     tuple[str, str]: iri's prefix and name.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def split_iri(iri_string: str) -&gt; tuple[str, str]:\n    \"\"\"\n    Split iri into prefix and name.\n\n    Args:\n        iri_string (str): full iri string.\n\n    Returns:\n        tuple[str, str]: iri's prefix and name.\n\n    \"\"\"\n    name = iri_string\n    prefix = \"\"\n    for sep in \"#\", \"/\":\n        prefix, char, name = iri_string.rpartition(sep)\n        if char:\n            return prefix + char, name\n    return prefix, name\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_statement","title":"<code>encode_statement(terms, term_encoder, repeated_terms)</code>","text":"<p>Encode a statement.</p> <p>Args:     terms (Iterable[object]): original terms to encode     term_encoder (TermEncoder): encoder with lookup tables     repeated_terms (dict[Slot, object]): dictionary of repeated terms.</p> <p>Returns:     tuple[list[jelly.RdfStreamRow], dict[str, Any]]:         extra rows to append and jelly terms.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_statement(\n    terms: Iterable[object],\n    term_encoder: TermEncoder,\n    repeated_terms: dict[Slot, object],\n) -&gt; tuple[list[jelly.RdfStreamRow], dict[str, Any]]:\n    \"\"\"\n    Encode a statement.\n\n    Args:\n        terms (Iterable[object]): original terms to encode\n        term_encoder (TermEncoder): encoder with lookup tables\n        repeated_terms (dict[Slot, object]): dictionary of repeated terms.\n\n    Returns:\n        tuple[list[jelly.RdfStreamRow], dict[str, Any]]:\n            extra rows to append and jelly terms.\n\n    \"\"\"\n    statement: dict[str, object] = {}\n    rows: list[jelly.RdfStreamRow] = []\n    for slot, term in zip(Slot, terms):\n        if repeated_terms[slot] != term:\n            extra_rows, value = term_encoder.encode_any(term, slot)\n            oneof = term_encoder.TERM_ONEOF_NAMES[type(value)]\n            rows.extend(extra_rows)\n            field = f\"{slot}_{oneof}\"\n            statement[field] = value\n            repeated_terms[slot] = term\n    return rows, statement\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_triple","title":"<code>encode_triple(terms, term_encoder, repeated_terms)</code>","text":"<p>Encode one triple.</p> <p>Args:     terms (Iterable[object]): original terms to encode     term_encoder (TermEncoder): current encoder with lookup tables     repeated_terms (dict[Slot, object]): dictionary of repeated terms.</p> <p>Returns:     list[jelly.RdfStreamRow]: list of rows to add to the current flow.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_triple(\n    terms: Iterable[object],\n    term_encoder: TermEncoder,\n    repeated_terms: dict[Slot, object],\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode one triple.\n\n    Args:\n        terms (Iterable[object]): original terms to encode\n        term_encoder (TermEncoder): current encoder with lookup tables\n        repeated_terms (dict[Slot, object]): dictionary of repeated terms.\n\n    Returns:\n        list[jelly.RdfStreamRow]: list of rows to add to the current flow.\n\n    \"\"\"\n    rows, statement = encode_statement(terms, term_encoder, repeated_terms)\n    row = jelly.RdfStreamRow(triple=jelly.RdfTriple(**statement))\n    rows.append(row)\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_quad","title":"<code>encode_quad(terms, term_encoder, repeated_terms)</code>","text":"<p>Encode one quad.</p> <p>Args:     terms (Iterable[object]): original terms to encode     term_encoder (TermEncoder): current encoder with lookup tables     repeated_terms (dict[Slot, object]): dictionary of repeated terms.</p> <p>Returns:     list[jelly.RdfStreamRow]: list of messages to append to current flow.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_quad(\n    terms: Iterable[object],\n    term_encoder: TermEncoder,\n    repeated_terms: dict[Slot, object],\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode one quad.\n\n    Args:\n        terms (Iterable[object]): original terms to encode\n        term_encoder (TermEncoder): current encoder with lookup tables\n        repeated_terms (dict[Slot, object]): dictionary of repeated terms.\n\n    Returns:\n        list[jelly.RdfStreamRow]: list of messages to append to current flow.\n\n    \"\"\"\n    rows, statement = encode_statement(terms, term_encoder, repeated_terms)\n    row = jelly.RdfStreamRow(quad=jelly.RdfQuad(**statement))\n    rows.append(row)\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_namespace_declaration","title":"<code>encode_namespace_declaration(name, value, term_encoder)</code>","text":"<p>Encode namespace declaration.</p> <p>Args:     name (str): namespace prefix label     value (str): namespace iri     term_encoder (TermEncoder): current encoder</p> <p>Returns:     list[jelly.RdfStreamRow]: list of messages to append to current flow.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_namespace_declaration(\n    name: str,\n    value: str,\n    term_encoder: TermEncoder,\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode namespace declaration.\n\n    Args:\n        name (str): namespace prefix label\n        value (str): namespace iri\n        term_encoder (TermEncoder): current encoder\n\n    Returns:\n        list[jelly.RdfStreamRow]: list of messages to append to current flow.\n\n    \"\"\"\n    [*rows], iri = term_encoder.encode_iri(value)\n    declaration = jelly.RdfNamespaceDeclaration(name=name, value=iri)\n    row = jelly.RdfStreamRow(namespace=declaration)\n    rows.append(row)\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_options","title":"<code>encode_options(lookup_preset, stream_types, params)</code>","text":"<p>Encode stream options to ProtoBuf message.</p> <p>Args:     lookup_preset (options.LookupPreset): lookup tables options     stream_types (options.StreamTypes): physical and logical types     params (options.StreamParameters): other params.</p> <p>Returns:     jelly.RdfStreamRow: encoded stream options row</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_options(\n    lookup_preset: options.LookupPreset,\n    stream_types: options.StreamTypes,\n    params: options.StreamParameters,\n) -&gt; jelly.RdfStreamRow:\n    \"\"\"\n    Encode stream options to ProtoBuf message.\n\n    Args:\n        lookup_preset (options.LookupPreset): lookup tables options\n        stream_types (options.StreamTypes): physical and logical types\n        params (options.StreamParameters): other params.\n\n    Returns:\n        jelly.RdfStreamRow: encoded stream options row\n\n    \"\"\"\n    return jelly.RdfStreamRow(\n        options=jelly.RdfStreamOptions(\n            stream_name=params.stream_name,\n            physical_type=stream_types.physical_type,\n            generalized_statements=params.generalized_statements,\n            rdf_star=params.rdf_star,\n            max_name_table_size=lookup_preset.max_names,\n            max_prefix_table_size=lookup_preset.max_prefixes,\n            max_datatype_table_size=lookup_preset.max_datatypes,\n            logical_type=stream_types.logical_type,\n            version=params.version,\n        )\n    )\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows","title":"<code>flows</code>","text":"<p>Classes:</p> Name Description <code>FrameFlow</code> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <code>ManualFrameFlow</code> <p>Produces frames only when manually requested (never automatically).</p> <code>BoundedFrameFlow</code> <p>Produce frames automatically when a fixed number of rows is reached.</p> <code>GraphsFrameFlow</code> <code>DatasetsFrameFlow</code> <p>Functions:</p> Name Description <code>flow_for_type</code> <p>Return flow based on logical type requested.</p>"},{"location":"api/#pyjelly.serialize.flows.FrameFlow","title":"<code>FrameFlow</code>","text":"<p>               Bases: <code>UserList[RdfStreamRow]</code></p> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <p>Collects stream rows and assembles them into RdfStreamFrame objects when ready.</p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Treat the current rows as a graph and produce a frame.</p> <code>frame_from_dataset</code> <p>Treat the current rows as a dataset and produce a frame.</p> <code>to_stream_frame</code> <p>Create stream frame from flow content.</p> <code>frame_from_graph()</code> <p>Treat the current rows as a graph and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a graph and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>frame_from_dataset()</code> <p>Treat the current rows as a dataset and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a dataset and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>to_stream_frame()</code> <p>Create stream frame from flow content.</p> <p>Notes:     Clears flow content after creating the frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def to_stream_frame(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Create stream frame from flow content.\n\n    Notes:\n        Clears flow content after creating the frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame\n\n    \"\"\"\n    if not self:\n        return None\n    frame = jelly.RdfStreamFrame(rows=self)\n    self.clear()\n    return frame\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.ManualFrameFlow","title":"<code>ManualFrameFlow(initlist=None, *, logical_type=jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produces frames only when manually requested (never automatically).</p> <p>Warning</p> <p>All stream rows are kept in memory until <code>to_stream_frame()</code> is called. This may lead to high memory usage for large streams.</p> <p>Used for non-delimited serialization.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType = jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.BoundedFrameFlow","title":"<code>BoundedFrameFlow(initlist=None, *, frame_size=None)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produce frames automatically when a fixed number of rows is reached.</p> <p>Used for delimited encoding (default mode).</p> <p>Methods:</p> Name Description <code>frame_from_bounds</code> <p>Emit frame from flow if full.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    frame_size: int | None = None,\n) -&gt; None:\n    super().__init__(initlist)\n    self.frame_size = frame_size or DEFAULT_FRAME_SIZE\n</code></pre> <code>frame_from_bounds()</code> <p>Emit frame from flow if full.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>@override\ndef frame_from_bounds(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit frame from flow if full.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame\n\n    \"\"\"\n    if len(self) &gt;= self.frame_size:\n        return self.to_stream_frame()\n    return None\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.GraphsFrameFlow","title":"<code>GraphsFrameFlow</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Emit current flow content (one graph) as jelly frame.</p> <code>frame_from_graph()</code> <p>Emit current flow content (one graph) as jelly frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: jelly frame or none if         flow is empty.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit current flow content (one graph) as jelly frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: jelly frame or none if\n            flow is empty.\n\n    \"\"\"\n    return self.to_stream_frame()\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.DatasetsFrameFlow","title":"<code>DatasetsFrameFlow</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Methods:</p> Name Description <code>frame_from_dataset</code> <p>Emit current flow content (dataset) as jelly frame.</p> <code>frame_from_dataset()</code> <p>Emit current flow content (dataset) as jelly frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: jelly frame or none if         flow is empty.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit current flow content (dataset) as jelly frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: jelly frame or none if\n            flow is empty.\n\n    \"\"\"\n    return self.to_stream_frame()\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.flow_for_type","title":"<code>flow_for_type(logical_type)</code>","text":"<p>Return flow based on logical type requested.</p> <p>Args:     logical_type (jelly.LogicalStreamType): logical type requested.</p> <p>Raises:     NotImplementedError: if logical type not supported.</p> <p>Returns:     type[FrameFlow]: FrameFlow for respective logical type.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def flow_for_type(logical_type: jelly.LogicalStreamType) -&gt; type[FrameFlow]:\n    \"\"\"\n    Return flow based on logical type requested.\n\n    Args:\n        logical_type (jelly.LogicalStreamType): logical type requested.\n\n    Raises:\n        NotImplementedError: if logical type not supported.\n\n    Returns:\n        type[FrameFlow]: FrameFlow for respective logical type.\n\n    \"\"\"\n    try:\n        return FLOW_DISPATCH[logical_type]\n    except KeyError:\n        msg = (\n            \"unsupported logical stream type: \"\n            f\"{jelly.LogicalStreamType.Name(logical_type)}\"\n        )\n        raise NotImplementedError(msg) from None\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>Lookup</code> <p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <code>LookupEncoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.serialize.lookup.Lookup","title":"<code>Lookup(max_size)</code>","text":"<p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <ul> <li>Assigns incrementing indices starting from 1.</li> <li>After reaching the maximum size, reuses the existing indices from evicting   the least-recently-used entries.</li> <li>Index 0 is reserved for delta encoding in Jelly streams.</li> </ul> <p>To check if a key exists, use <code>.move(key)</code> and catch <code>KeyError</code>. If <code>KeyError</code> is raised, the key can be inserted with <code>.insert(key)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of entries. Zero disables lookup.</p> required Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, max_size: int) -&gt; None:\n    self.data = OrderedDict[str, int]()\n    self.max_size = max_size\n    self._evicting = False\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup.LookupEncoder","title":"<code>LookupEncoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required <p>Methods:</p> Name Description <code>encode_entry_index</code> <p>Get or assign the index to use in an entry.</p> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    self.lookup = Lookup(max_size=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre> <code>encode_entry_index(key)</code> <p>Get or assign the index to use in an entry.</p> <p>Returns:</p> Type Description <code>int or None</code> <ul> <li>0 if the new index is sequential (<code>last_assigned_index + 1</code>)</li> <li>actual assigned/reused index otherwise</li> <li>None if the key already exists</li> </ul> <code>If the return value is None, the entry is already in the lookup and does not</code> <code>need to be emitted. Any integer value (including 0) means the entry is new</code> <code>and should be emitted.</code> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def encode_entry_index(self, key: str) -&gt; int | None:\n    \"\"\"\n    Get or assign the index to use in an entry.\n\n    Returns\n    -------\n    int or None\n        - 0 if the new index is sequential (`last_assigned_index + 1`)\n        - actual assigned/reused index otherwise\n        - None if the key already exists\n\n    If the return value is None, the entry is already in the lookup and does not\n    need to be emitted. Any integer value (including 0) means the entry is new\n    and should be emitted.\n\n    \"\"\"\n    try:\n        self.lookup.make_last_to_evict(key)\n        return None  # noqa: TRY300\n    except KeyError:\n        previous_index = self.last_assigned_index\n        index = self.lookup.insert(key)\n        self.last_assigned_index = index\n        if index == previous_index + 1:\n            return 0\n        return index\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams","title":"<code>streams</code>","text":"<p>Classes:</p> Name Description <code>Stream</code> <code>TripleStream</code> <code>QuadStream</code> <code>GraphStream</code> <p>Functions:</p> Name Description <code>stream_for_type</code> <p>Give a Stream based on physical type specified.</p>"},{"location":"api/#pyjelly.serialize.streams.Stream","title":"<code>Stream(*, encoder, options=None)</code>","text":"<p>Methods:</p> Name Description <code>infer_flow</code> <p>Return flow based on the stream options provided.</p> <code>enroll</code> <p>Initialize start of the stream.</p> <code>stream_options</code> <p>Encode and append stream options row to the current flow.</p> <code>namespace_declaration</code> <p>Add namespace declaration to jelly stream.</p> <code>for_rdflib</code> <p>Initialize stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = dict.fromkeys(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>infer_flow()</code> <p>Return flow based on the stream options provided.</p> <p>Returns:     FrameFlow: initialised FrameFlow object.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def infer_flow(self) -&gt; FrameFlow:\n    \"\"\"\n    Return flow based on the stream options provided.\n\n    Returns:\n        FrameFlow: initialised FrameFlow object.\n\n    \"\"\"\n    flow: FrameFlow\n    if self.options.params.delimited:\n        if self.options.logical_type != jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED:\n            flow_class = flow_for_type(self.options.logical_type)\n        else:\n            flow_class = self.default_delimited_flow_class\n\n        if self.options.logical_type in (\n            jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES,\n            jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS,\n        ):\n            flow = flow_class(frame_size=self.options.frame_size)  # type: ignore[call-overload]\n        else:\n            flow = flow_class()\n    else:\n        flow = ManualFrameFlow(logical_type=self.options.logical_type)\n    return flow\n</code></pre> <code>enroll()</code> <p>Initialize start of the stream.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def enroll(self) -&gt; None:\n    \"\"\"Initialize start of the stream.\"\"\"\n    if not self.enrolled:\n        self.stream_options()\n        self.enrolled = True\n</code></pre> <code>stream_options()</code> <p>Encode and append stream options row to the current flow.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_options(self) -&gt; None:\n    \"\"\"Encode and append stream options row to the current flow.\"\"\"\n    self.flow.append(\n        encode_options(\n            stream_types=self.stream_types,\n            params=self.options.params,\n            lookup_preset=self.options.lookup_preset,\n        )\n    )\n</code></pre> <code>namespace_declaration(name, iri)</code> <p>Add namespace declaration to jelly stream.</p> <p>Args:     name (str): namespace prefix label     iri (str): namespace iri</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def namespace_declaration(self, name: str, iri: str) -&gt; None:\n    \"\"\"\n    Add namespace declaration to jelly stream.\n\n    Args:\n        name (str): namespace prefix label\n        iri (str): namespace iri\n\n    \"\"\"\n    rows = encode_namespace_declaration(\n        name=name,\n        value=iri,\n        term_encoder=self.encoder,\n    )\n    self.flow.extend(rows)\n</code></pre> <code>for_rdflib(options=None)</code> <p>Initialize stream with RDFLib encoder.</p> <p>Args:     options (SerializerOptions | None, optional): Stream options.         Defaults to None.</p> <p>Raises:     TypeError: if Stream is passed, and not a Stream for specific physical type.</p> <p>Returns:     Stream: initialized stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>@classmethod\ndef for_rdflib(cls, options: SerializerOptions | None = None) -&gt; Stream:\n    \"\"\"\n    Initialize stream with RDFLib encoder.\n\n    Args:\n        options (SerializerOptions | None, optional): Stream options.\n            Defaults to None.\n\n    Raises:\n        TypeError: if Stream is passed, and not a Stream for specific physical type.\n\n    Returns:\n        Stream: initialized stream with RDFLib encoder.\n\n    \"\"\"\n    if cls is Stream:\n        msg = \"Stream is an abstract base class, use a subclass instead\"\n        raise TypeError(msg)\n    from pyjelly.integrations.rdflib.serialize import RDFLibTermEncoder\n\n    lookup_preset: LookupPreset | None = None\n    if options is not None:\n        lookup_preset = options.lookup_preset\n    return cls(\n        encoder=RDFLibTermEncoder(lookup_preset=lookup_preset),\n        options=options,\n    )\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.TripleStream","title":"<code>TripleStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>triple</code> <p>Process one triple to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = dict.fromkeys(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>triple(terms)</code> <p>Process one triple to Protobuf messages.</p> <p>Note:     Adds new rows to the current flow and returns StreamFrame if     frame size conditions are met.</p> <p>Args:     terms (Iterable[object]): RDF terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def triple(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one triple to Protobuf messages.\n\n    Note:\n        Adds new rows to the current flow and returns StreamFrame if\n        frame size conditions are met.\n\n    Args:\n        terms (Iterable[object]): RDF terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_triple(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.QuadStream","title":"<code>QuadStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>quad</code> <p>Process one quad to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = dict.fromkeys(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>quad(terms)</code> <p>Process one quad to Protobuf messages.</p> <p>Args:     terms (Iterable[object]): terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def quad(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one quad to Protobuf messages.\n\n    Args:\n        terms (Iterable[object]): terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_quad(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.GraphStream","title":"<code>GraphStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>TripleStream</code></p> <p>Methods:</p> Name Description <code>graph</code> <p>Process one graph into a sequence of jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = dict.fromkeys(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>graph(graph_id, graph)</code> <p>Process one graph into a sequence of jelly frames.</p> <p>Args:     graph_id (object): graph id (BN, Literal, iri, default)     graph (Iterable[Iterable[object]]): iterable of triples (graph's content)</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def graph(\n    self,\n    graph_id: object,\n    graph: Iterable[Iterable[object]],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Process one graph into a sequence of jelly frames.\n\n    Args:\n        graph_id (object): graph id (BN, Literal, iri, default)\n        graph (Iterable[Iterable[object]]): iterable of triples (graph's content)\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    [*graph_rows], graph_node = self.encoder.encode_any(graph_id, Slot.graph)\n    kw_name = f\"{Slot.graph}_{self.encoder.TERM_ONEOF_NAMES[type(graph_node)]}\"\n    kws: dict[Any, Any] = {kw_name: graph_node}\n    start_row = jelly.RdfStreamRow(graph_start=jelly.RdfGraphStart(**kws))\n    graph_rows.append(start_row)\n    self.flow.extend(graph_rows)\n    for triple in graph:\n        if frame := self.triple(triple):  # has frame slicing inside\n            yield frame\n    end_row = jelly.RdfStreamRow(graph_end=jelly.RdfGraphEnd())\n    self.flow.append(end_row)\n    if frame := self.flow.frame_from_bounds():\n        yield frame\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.stream_for_type","title":"<code>stream_for_type(physical_type)</code>","text":"<p>Give a Stream based on physical type specified.</p> <p>Args:     physical_type (jelly.PhysicalStreamType): jelly stream physical type.</p> <p>Raises:     NotImplementedError: if no stream for requested physical type is available.</p> <p>Returns:     type[Stream]: jelly stream</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_for_type(physical_type: jelly.PhysicalStreamType) -&gt; type[Stream]:\n    \"\"\"\n    Give a Stream based on physical type specified.\n\n    Args:\n        physical_type (jelly.PhysicalStreamType): jelly stream physical type.\n\n    Raises:\n        NotImplementedError: if no stream for requested physical type is available.\n\n    Returns:\n        type[Stream]: jelly stream\n\n    \"\"\"\n    try:\n        stream_cls = STREAM_DISPATCH[physical_type]\n    except KeyError:\n        msg = (\n            \"no stream class for physical type \"\n            f\"{jelly.PhysicalStreamType.Name(physical_type)}\"\n        )\n        raise NotImplementedError(msg) from None\n    return stream_cls\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide shows how to install pyjelly and prepare your environment for use with RDFLib.</p>"},{"location":"getting-started/#installation-with-rdflib","title":"Installation (with RDFLib)","text":"<p>Install pyjelly from PyPI:</p> <pre><code>pip install pyjelly[rdflib]\n</code></pre> <p>pyjelly requires Python 3.9 or newer and works on all major platforms (Linux, macOS, Windows).</p>"},{"location":"getting-started/#usage-with-rdflib","title":"Usage with RDFLib","text":"<p>Once installed, pyjelly integrates with RDFLib automatically. You can immediately serialize and parse <code>.jelly</code> files using the standard RDFLib API.</p>"},{"location":"getting-started/#serialization","title":"Serialization","text":"<p>To serialize a graph to the Jelly format:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"http://xmlns.com/foaf/spec/index.rdf\")\ng.serialize(destination=\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>This creates a delimited Jelly stream using default options.</p>"},{"location":"getting-started/#parsing","title":"Parsing","text":"<p>To load RDF data from a <code>.jelly</code> file:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"foaf.jelly\", format=\"jelly\")\n\nprint(\"Parsed triples:\")\nfor s, p, o in g:\n    print(f\"{s} {p} {o}\")\n</code></pre> <p>RDFLib will reconstruct the graph from the serialized Jelly stream.</p>"},{"location":"getting-started/#streaming-graph-parser","title":"Streaming graph parser","text":"<p>To process a Jelly stream frame-by-frame, loading each as a separate RDFLib graph:</p> <pre><code>from rdflib import Dataset, Graph\n\n# libraries to load example jelly stream data\nimport gzip\nimport urllib.request\nfrom typing import cast, IO\n\nfrom pyjelly.integrations.rdflib.parse import parse_jelly_grouped\n\nurl = \"https://w3id.org/riverbench/datasets/dbpedia-live/dev/files/jelly_10K.jelly.gz\"\n\n# load, uncompress .gz file, and pass to jelly parser\nwith (\n    urllib.request.urlopen(url) as resp,\n    cast(IO[bytes], gzip.GzipFile(fileobj=resp)) as jelly_stream,\n):\n    graphs = parse_jelly_grouped(\n        jelly_stream,\n        graph_factory=lambda: Graph(),\n        dataset_factory=lambda: Dataset(),\n    )\n    for i, graph in enumerate(graphs):\n        print(f\"Graph {i} in the stream has {len(graph)} triples\")\n</code></pre> <p>Because <code>parse_jelly_grouped</code> returns a generator, each iteration receives one graph, keeping memory usage bounded to the current frame. Thus, large datasets and live streams can be processed efficiently.</p>"},{"location":"getting-started/#file-extension-support","title":"File extension support","text":"<p>You can generally omit the <code>format=\"jelly\"</code> parameter if the file ends in <code>.jelly</code> \u2013 RDFLib will auto-detect the format:</p> <pre><code>from rdflib import Graph\nimport pyjelly.integrations.rdflib\n\ng = Graph()\ng.parse(\"foaf.jelly\")\n</code></pre> <p>Warning</p> <p>Unfortunately, the way this is implemented in RDFLib is a bit wonky, so it will only work if you explicitly import <code>pyjelly.integrations.rdflib</code>, or you used <code>format=\"jelly\"</code> in the <code>serialize()</code> or <code>parse()</code> call before.</p>"},{"location":"overview/","title":"Overview and supported features","text":""},{"location":"overview/#what-is-jelly-and-pyjelly","title":"What is Jelly and pyjelly?","text":"<p>Jelly is a high-performance serialization format and streaming protocol for RDF knowledge graphs. It enables fast, compact, and flexible transmission of RDF data with Protobuf, supporting both flat and structured streams of triples, quads, graphs, and datasets. Jelly is designed to work well in both batch and real-time settings, including use over files, sockets, or stream processing systems like Kafka or gRPC.</p> <p>pyjelly is a Python implementation of the Jelly protocol. It provides:</p> <ul> <li>Full support for reading and writing Jelly-encoded RDF data</li> <li>Seamless integration with RDFLib (\"works just like Turtle\")</li> <li>Support for all Jelly stream types</li> <li>Tools for working with delimited and non-delimited Jelly streams</li> <li>Fine-grained control over serialization options, compression, and framing</li> </ul>"},{"location":"overview/#overview","title":"Overview","text":""},{"location":"overview/#use-cases","title":"Use cases","text":"<p>pyjelly is suitable for:</p> <ul> <li>Compact serialization of large RDF graphs and datasets.</li> <li>Incremental or streaming processing of RDF data.</li> <li>Writing or reading <code>.jelly</code> files in data pipelines.</li> <li>Efficient on-disk storage of RDF collections.</li> <li>Interchange of RDF data between systems.</li> </ul>"},{"location":"overview/#supported-stream-types","title":"Supported stream types","text":"<p>pyjelly supports all physical stream types including <code>TRIPLES</code>, <code>QUADS</code> and <code>GRAPHS</code>.</p> <p>See the full stream type matrix for an overview of valid combinations.</p>"},{"location":"overview/#conformance-to-the-jelly-protocol","title":"Conformance to the Jelly protocol","text":"<p>pyjelly is designed to conform to version 1.1.2 of the Jelly specification. It adheres to:</p> <ul> <li>Stream header structure and metadata.</li> <li>Frame structure and ordering guarantees.</li> <li>Compression rules and lookup tables.</li> <li>Namespace declarations and stream options.</li> </ul> <p>Parsing includes automatic validation of conformance raised when violations occur.</p>"},{"location":"overview/#limitations","title":"Limitations","text":"<ul> <li>Grouped logical stream types are not yet supported.</li> <li>Quoted graphs (RDF-star nested triples) are not supported.</li> <li>Multi-dataset streams cannot currently be parsed into a single <code>Dataset</code>.</li> <li>Logical stream type detection is not automatic; it must be set explicitly via options.</li> </ul>"},{"location":"contributing/","title":"Contributing to pyjelly","text":"<p>Hi! This guide explains how to get started with developing pyjelly and contributing to it.</p>"},{"location":"contributing/#quick-start","title":"Quick start","text":"<ol> <li> <p>Clone the project with <code>git clone git@github.com:Jelly-RDF/pyjelly.git</code>.</p> </li> <li> <p>We use <code>uv</code> for package management. If you don't already have it, install uv.</p> <ul> <li>On Linux this is: <code>curl -LsSf https://astral.sh/uv/install.sh | sh</code></li> </ul> </li> <li> <p>Run <code>uv sync</code> to install the project.</p> <ul> <li>If you use an IDE, make sure that it uses the Python interpreter from the environment that will be created in the <code>.venv</code> directory.</li> <li>If you get an error about the uv version being incorrect, run <code>uv self update</code></li> </ul> </li> <li> <p>Activate the environment or use <code>uv run</code> to run commands and code. </p> </li> </ol>"},{"location":"contributing/#giving-feedback","title":"Giving feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Jelly-RDF/pyjelly/issues</p> <p>If you are proposing a feature:</p> <ol> <li>Explain how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Contributions are always welcome! Consider if you can help with implementing the feature.</li> </ol>"},{"location":"contributing/#contributing-code","title":"Contributing code","text":"<ol> <li>Every major pull request should be connected to an issue. If you see a problem, first create an issue.<ul> <li>For minor issues (typos, small fixes) make sure you describe your problem well in the PR.</li> </ul> </li> <li>When opening a pull request:<ul> <li>Use a descriptive title.</li> <li>Reference the related issue in the description.</li> </ul> </li> <li>Please make sure your code passes all the checks:<ul> <li>Tests (<code>pytest</code>)</li> <li>Type safety (<code>mypy</code>)</li> <li>Formatting and linting (<code>ruff</code> or via <code>pre-commit</code>) This helps us follow best practices and keep the codebase in shape.</li> </ul> </li> </ol>"},{"location":"contributing/#contributing-documentation","title":"Contributing documentation","text":"<p>The documentation is written in Markdown and built using MkDocs, using Material for MkDocs.</p> <p>To edit a documentation page, simply click the  button in the top-right of the page.</p> <p>It will take you to GitHub, where you can edit the Markdown file and submit a pull request. You can also clone the repository and edit the files locally. The source files are in the <code>docs</code> directory.</p>"},{"location":"contributing/#previewing-documentation-locally","title":"Previewing documentation locally","text":"<p>Install dependencies for docs:</p> <pre><code>uv sync --group docs\n</code></pre> <p>Then, start a local docs server:</p> <pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"contributing/#further-reading","title":"Further reading","text":"<ul> <li>More information on editing Jelly docs</li> <li>Material for MkDocs reference</li> <li>MkDocs documentation</li> <li>Macro plugin documentation</li> </ul>"},{"location":"contributing/#making-releases","title":"Making releases","text":"<ol> <li>Make sure you are on the <code>main</code> branch and that it is up-to-date: <code>git checkout main &amp;&amp; git pull</code>.</li> <li>Checkout a new branch.</li> <li>Update the version in <code>pyproject.toml</code> with either:<ul> <li><code>uv version X.Y.Z</code></li> <li><code>uv version --bump major|minor|patch</code></li> </ul> </li> <li>Commit the changes, push the branch, and open a pull request.</li> <li>Once the pull request is merged, go back to the <code>main</code> branch: <code>git checkout main &amp;&amp; git pull</code>.</li> <li>Create a new tag for the release. For example, for version 1.2.3: <code>git tag v1.2.3</code>. The tag must start with <code>v</code>!</li> <li>Push the tag to GitHub: <code>git push origin v1.2.3</code>.</li> <li>The release will be automatically built and published to PyPI.</li> </ol>"},{"location":"contributing/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"contributing/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at community@neverblink.eu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/code_of_conduct/#attribution","title":"Attribution","text":"<p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"examples/","title":"Index","text":"<p>Code examples for using pyjelly in practice.</p> <p>The examples will be executed in alphabetical order, so you can number them accordingly.</p>"}]}