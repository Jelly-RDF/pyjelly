{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyjelly","text":"<p>Early development</p> <p>pyjelly is in early development, so some breaking changes may still occur from time to time.</p> <p>pyjelly is a Python implementation of Jelly, a high-performance binary serialization format and streaming protocol for RDF knowledge graphs. It works great with rdflib.</p> <ul> <li>Getting started: Installation instructions and basic usage examples.</li> <li>Overview: An introduction to the Jelly protocol and the pyjelly library.</li> <li>API reference: Detailed documentation of the pyjelly API, including classes, methods, and functions.</li> <li>Contributing: Guidelines for contributing to the pyjelly project, including how to report issues, submit pull requests, and participate in discussions.</li> <li>Code of conduct: The code of conduct for the pyjelly community, outlining expected behavior and guidelines for respectful interactions.</li> </ul>"},{"location":"#license","title":"License","text":"<p>The pyjelly library is licensed under the Apache 2.0 license.</p>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p> <p>The development of the Jelly protocol, its implementations, and supporting tooling was co-funded by the European Union. More details.</p> <p></p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#pyjelly","title":"<code>pyjelly</code>","text":"<p>Modules:</p> Name Description <code>errors</code> <code>integrations</code> <code>jelly</code> <code>options</code> <code>parse</code> <code>serialize</code>"},{"location":"api/#pyjelly.errors","title":"<code>errors</code>","text":"<p>Classes:</p> Name Description <code>JellyConformanceError</code> <p>Raised when Jelly conformance is violated.</p> <code>JellyAssertionError</code> <p>Raised when a recommended assertion from the specification fails.</p> <code>JellyNotImplementedError</code> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.errors.JellyConformanceError","title":"<code>JellyConformanceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when Jelly conformance is violated.</p>"},{"location":"api/#pyjelly.errors.JellyAssertionError","title":"<code>JellyAssertionError</code>","text":"<p>               Bases: <code>AssertionError</code></p> <p>Raised when a recommended assertion from the specification fails.</p>"},{"location":"api/#pyjelly.errors.JellyNotImplementedError","title":"<code>JellyNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.integrations","title":"<code>integrations</code>","text":"<p>Modules:</p> Name Description <code>rdflib</code>"},{"location":"api/#pyjelly.integrations.rdflib","title":"<code>rdflib</code>","text":"<p>Modules:</p> Name Description <code>serialize</code> <p>Functions:</p> Name Description <code>register_extension_to_rdflib</code> <p>Make rdflib.util.guess_format discover Jelly format.</p>"},{"location":"api/#pyjelly.integrations.rdflib.register_extension_to_rdflib","title":"<code>register_extension_to_rdflib(extension='.jelly')</code>","text":"<p>Make rdflib.util.guess_format discover Jelly format.</p> <p>rdflib.util.guess_format(\"foo.jelly\") register_extension_to_rdflib() rdflib.util.guess_format(\"foo.jelly\") 'jelly'</p> Source code in <code>pyjelly/integrations/rdflib/__init__.py</code> <pre><code>def register_extension_to_rdflib(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Make [rdflib.util.guess_format][] discover Jelly format.\n\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    &gt;&gt;&gt; register_extension_to_rdflib()\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    'jelly'\n    \"\"\"\n    rdflib.util.SUFFIX_FORMAT_MAP[extension.removeprefix(\".\")] = \"jelly\"\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.serialize","title":"<code>serialize</code>","text":"<p>Classes:</p> Name Description <code>RDFLibJellySerializer</code> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <code>RDFLibJellySerializer(store)</code> <p>               Bases: <code>Serializer</code></p> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Handles streaming RDF terms into Jelly frames using internal encoders. Supports only graphs and datasets (not quoted graphs).</p> <p>Methods:</p> Name Description <code>guess_options</code> <p>Guess the serializer options based on the store type.</p> <code>guess_stream</code> <p>Return an appropriate stream implementation for the given options.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def __init__(self, store: Graph) -&gt; None:\n    if isinstance(store, QuotedGraph):\n        msg = \"N3 format is not supported\"\n        raise NotImplementedError(msg)\n    super().__init__(store)\n</code></pre> <code>guess_options()</code> <p>Guess the serializer options based on the store type.</p> <p>RDFLibJellySerializer(Graph()).guess_options().logical_type 1 RDFLibJellySerializer(Dataset()).guess_options().logical_type 2</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_options(self) -&gt; SerializerOptions:\n    \"\"\"\n    Guess the serializer options based on the store type.\n\n    &gt;&gt;&gt; RDFLibJellySerializer(Graph()).guess_options().logical_type\n    1\n    &gt;&gt;&gt; RDFLibJellySerializer(Dataset()).guess_options().logical_type\n    2\n    \"\"\"\n    logical_type = (\n        jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS\n        if isinstance(self.store, Dataset)\n        else jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES\n    )\n    return SerializerOptions(logical_type=logical_type)\n</code></pre> <code>guess_stream(options)</code> <p>Return an appropriate stream implementation for the given options.</p> <p>graph_ser = RDFLibJellySerializer(Graph()) ds_ser = RDFLibJellySerializer(Dataset())</p> <p>type(graph_ser.guess_stream(graph_ser.guess_options()))  type(ds_ser.guess_stream(ds_ser.guess_options()))  Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_stream(self, options: SerializerOptions) -&gt; Stream:\n    \"\"\"\n    Return an appropriate stream implementation for the given options.\n\n    &gt;&gt;&gt; graph_ser = RDFLibJellySerializer(Graph())\n    &gt;&gt;&gt; ds_ser = RDFLibJellySerializer(Dataset())\n\n    &gt;&gt;&gt; type(graph_ser.guess_stream(graph_ser.guess_options()))\n    &lt;class 'pyjelly.serialize.streams.TripleStream'&gt;\n    &gt;&gt;&gt; type(ds_ser.guess_stream(ds_ser.guess_options()))\n    &lt;class 'pyjelly.serialize.streams.QuadStream'&gt;\n    \"\"\"\n    stream_cls: type[Stream]\n    if options.logical_type != jelly.LOGICAL_STREAM_TYPE_GRAPHS and isinstance(\n        self.store, Dataset\n    ):\n        stream_cls = QuadStream\n    else:\n        stream_cls = TripleStream\n    return stream_cls.for_rdflib(options=options)\n</code></pre>"},{"location":"api/#pyjelly.jelly","title":"<code>jelly</code>","text":"<p>Modules:</p> Name Description <code>rdf_pb2</code> <p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.jelly.rdf_pb2","title":"<code>rdf_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.options","title":"<code>options</code>","text":"<p>Functions:</p> Name Description <code>register_mimetypes</code> <p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>Attributes:</p> Name Type Description <code>INTEGRATION_SIDE_EFFECTS</code> <code>bool</code> <p>Whether to allow integration module imports to trigger side effects.</p>"},{"location":"api/#pyjelly.options.INTEGRATION_SIDE_EFFECTS","title":"<code>INTEGRATION_SIDE_EFFECTS = True</code>","text":"<p>Whether to allow integration module imports to trigger side effects.</p> <p>These side effects are cheap and may include populating some registries for guessing the defaults for external integrations that work with Jelly.</p>"},{"location":"api/#pyjelly.options.register_mimetypes","title":"<code>register_mimetypes(extension='.jelly')</code>","text":"<p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>register_mimetypes() mimetypes.guess_type(\"out.jelly\") ('application/x-jelly-rdf', None)</p> Source code in <code>pyjelly/options.py</code> <pre><code>def register_mimetypes(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Associate files that have Jelly extension with Jelly MIME types.\n\n    &gt;&gt;&gt; register_mimetypes()\n    &gt;&gt;&gt; mimetypes.guess_type(\"out.jelly\")\n    ('application/x-jelly-rdf', None)\n    \"\"\"\n    for mimetype in MIMETYPES:\n        mimetypes.add_type(mimetype, extension)\n</code></pre>"},{"location":"api/#pyjelly.parse","title":"<code>parse</code>","text":"<p>Modules:</p> Name Description <code>ioutils</code> <code>lookup</code>"},{"location":"api/#pyjelly.parse.ioutils","title":"<code>ioutils</code>","text":"<p>Functions:</p> Name Description <code>delimited_jelly_hint</code> <p>Detect whether a Jelly file is delimited from its first 3 bytes.</p>"},{"location":"api/#pyjelly.parse.ioutils.delimited_jelly_hint","title":"<code>delimited_jelly_hint(header)</code>","text":"<p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <p>Truth table (notation: <code>0A</code> = <code>0x0A</code>, <code>NN</code> = <code>not 0x0A</code>, <code>??</code> = don't care):</p> Byte 1 Byte 2 Byte 3 Result <code>NN</code> <code>??</code> <code>??</code> Delimited <code>0A</code> <code>NN</code> <code>??</code> Non-delimited <code>0A</code> <code>0A</code> <code>NN</code> Delimited (size = 10) <code>0A</code> <code>0A</code> <code>0A</code> Non-delimited (stream options size = 10) <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x00])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A])) False</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def delimited_jelly_hint(header: bytes) -&gt; bool:\n    \"\"\"\n    Detect whether a Jelly file is delimited from its first 3 bytes.\n\n    Truth table (notation: `0A` = `0x0A`, `NN` = `not 0x0A`, `??` = _don't care_):\n\n    | Byte 1 | Byte 2 | Byte 3 | Result                                   |\n    |--------|--------|--------|------------------------------------------|\n    | `NN`   |  `??`  |  `??`  | Delimited                                |\n    | `0A`   |  `NN`  |  `??`  | Non-delimited                            |\n    | `0A`   |  `0A`  |  `NN`  | Delimited (size = 10)                    |\n    | `0A`   |  `0A`  |  `0A`  | Non-delimited (stream options size = 10) |\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x00]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A]))\n    False\n    \"\"\"\n    magic = 0x0A\n    return len(header) == 3 and (  # noqa: PLR2004\n        header[0] != magic or (header[1] == magic and header[2] != magic)\n    )\n</code></pre>"},{"location":"api/#pyjelly.parse.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>LookupDecoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.parse.lookup.LookupDecoder","title":"<code>LookupDecoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required Source code in <code>pyjelly/parse/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    if lookup_size &gt; MAX_LOOKUP_SIZE:\n        msg = f\"lookup size must be less than {MAX_LOOKUP_SIZE}\"\n        raise JellyAssertionError(msg)\n    self.lookup_size = lookup_size\n    placeholders = (None,) * lookup_size\n    self.data: deque[str | None] = deque(placeholders, maxlen=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre>"},{"location":"api/#pyjelly.serialize","title":"<code>serialize</code>","text":"<p>Modules:</p> Name Description <code>encode</code> <code>flows</code> <code>lookup</code>"},{"location":"api/#pyjelly.serialize.encode","title":"<code>encode</code>","text":"<p>Classes:</p> Name Description <code>Slot</code> <p>Slots for encoding RDF terms.</p>"},{"location":"api/#pyjelly.serialize.encode.Slot","title":"<code>Slot</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Slots for encoding RDF terms.</p>"},{"location":"api/#pyjelly.serialize.flows","title":"<code>flows</code>","text":"<p>Classes:</p> Name Description <code>FrameFlow</code> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <code>ManualFrameFlow</code> <p>Produces frames only when manually requested (never automatically).</p> <code>BoundedFrameFlow</code> <p>Produces frames automatically when a fixed number of rows is reached.</p>"},{"location":"api/#pyjelly.serialize.flows.FrameFlow","title":"<code>FrameFlow</code>","text":"<p>               Bases: <code>UserList[RdfStreamRow]</code></p> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <p>Collects stream rows and assembles them into RdfStreamFrame objects when ready.</p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Treat the current rows as a graph and produce a frame.</p> <code>frame_from_dataset</code> <p>Treat the current rows as a dataset and produce a frame.</p> <code>frame_from_graph()</code> <p>Treat the current rows as a graph and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a graph and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>frame_from_dataset()</code> <p>Treat the current rows as a dataset and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a dataset and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.ManualFrameFlow","title":"<code>ManualFrameFlow(initlist=None, *, logical_type=jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produces frames only when manually requested (never automatically).</p> <p>Warning</p> <p>All stream rows are kept in memory until <code>to_stream_frame()</code> is called. This may lead to high memory usage for large streams.</p> <p>Used for non-delimited serialization.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType = jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.BoundedFrameFlow","title":"<code>BoundedFrameFlow(initlist=None, *, frame_size=None)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produces frames automatically when a fixed number of rows is reached.</p> <p>Used for delimited encoding (default mode).</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    frame_size: int | None = None,\n) -&gt; None:\n    super().__init__(initlist)\n    self.frame_size = frame_size or DEFAULT_FRAME_SIZE\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>Lookup</code> <p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <code>LookupEncoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.serialize.lookup.Lookup","title":"<code>Lookup(max_size)</code>","text":"<p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <ul> <li>Assigns incrementing indices starting from 1.</li> <li>After reaching the maximum size, reuses the existing indices from evicting   the least-recently-used entries.</li> <li>Index 0 is reserved for delta encoding in Jelly streams.</li> </ul> <p>To check if a key exists, use <code>.move(key)</code> and catch <code>KeyError</code>. If <code>KeyError</code> is raised, the key can be inserted with <code>.insert(key)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of entries. Zero disables lookup.</p> required Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, max_size: int) -&gt; None:\n    self.data = OrderedDict[str, int]()\n    self.max_size = max_size\n    self._evicting = False\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup.LookupEncoder","title":"<code>LookupEncoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required <p>Methods:</p> Name Description <code>encode_entry_index</code> <p>Get or assign the index to use in an entry.</p> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    self.lookup = Lookup(max_size=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre> <code>encode_entry_index(key)</code> <p>Get or assign the index to use in an entry.</p> <p>Returns:</p> Type Description <code>int or None</code> <ul> <li>0 if the new index is sequential (<code>last_assigned_index + 1</code>)</li> <li>actual assigned/reused index otherwise</li> <li>None if the key already exists</li> </ul> <code>If the return value is None, the entry is already in the lookup and does not</code> <code>need to be emitted. Any integer value (including 0) means the entry is new</code> <code>and should be emitted.</code> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def encode_entry_index(self, key: str) -&gt; int | None:\n    \"\"\"\n    Get or assign the index to use in an entry.\n\n    Returns\n    -------\n    int or None\n        - 0 if the new index is sequential (`last_assigned_index + 1`)\n        - actual assigned/reused index otherwise\n        - None if the key already exists\n\n    If the return value is None, the entry is already in the lookup and does not\n    need to be emitted. Any integer value (including 0) means the entry is new\n    and should be emitted.\n\n    \"\"\"\n    try:\n        self.lookup.make_last_to_evict(key)\n        return None  # noqa: TRY300\n    except KeyError:\n        previous_index = self.last_assigned_index\n        index = self.lookup.insert(key)\n        self.last_assigned_index = index\n        if index == previous_index + 1:\n            return 0\n        return index\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v020-2025-06-03","title":"v0.2.0 (2025-06-03)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added changelog (#103)</li> <li>Stream types inference (#120)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>RDFLib exposed as an optional dependency installable with <code>pyjelly[rdflib]</code> (#129)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>A bug where empty prefixes were not serialized (#127)</li> </ul>"},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog. This project adheres to Semantic Versioning.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide shows how to install pyjelly and prepare your environment for use with RDFLib.</p>"},{"location":"getting-started/#installation-with-rdflib","title":"Installation (with RDFLib)","text":"<p>Install pyjelly from PyPI:</p> <pre><code>pip install pyjelly[rdflib]\n</code></pre> <p>pyjelly requires Python 3.9 or newer and works on all major platforms (Linux, macOS, Windows).</p>"},{"location":"getting-started/#usage-with-rdflib","title":"Usage with RDFLib","text":"<p>Once installed, pyjelly integrates with RDFLib automatically. You can immediately serialize and parse <code>.jelly</code> files using the standard RDFLib API.</p>"},{"location":"getting-started/#serialization","title":"Serialization","text":"<p>To serialize a graph to the Jelly format:</p> <pre><code>from rdflib import Graph\nfrom pyjelly.serialize.streams import Stream\nfrom pyjelly.options import StreamOptions, StreamTypes\nfrom pyjelly import jelly\n\ng = Graph()\ng.parse(\"http://xmlns.com/foaf/spec/index.rdf\")\ng.serialize(destination=\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>This creates a delimited Jelly stream using default options.</p>"},{"location":"getting-started/#parsing","title":"Parsing","text":"<p>To load RDF data from a <code>.jelly</code> file:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"foaf.jelly\")\n\nprint(\"Parsed triples:\")\nfor s, p, o in g:\n    print(f\"{s} {p} {o}\")\n</code></pre> <p>RDFLib will reconstruct the graph from the serialized Jelly stream.</p>"},{"location":"getting-started/#file-extension-support","title":"File extension support","text":"<p>You can omit the <code>format=\"jelly\"</code> parameter if the file ends in <code>.jelly</code> \u2013 RDFLib will auto-detect the format using pyjelly's entry point:</p> <pre><code>g.parse(\"foaf.jelly\")  # format inferred automatically\n</code></pre>"},{"location":"overview/","title":"Overview and supported features","text":""},{"location":"overview/#what-is-jelly-and-what-is-pyjelly","title":"What is Jelly and what is pyjelly?","text":"<p>Jelly is a serialization format and streaming protocol for RDF knowledge graphs. It enables fast, compact, and flexible transmission of RDF data with Protobuf, supporting both flat and structured streams of triples, quads, graphs, and datasets. Jelly is designed to work well in both batch and real-time settings, including use over files, sockets, or stream processing systems like Kafka or gRPC.</p> <p>pyjelly is a Python implementation of the Jelly protocol. It provides:</p> <ul> <li>Full support for reading and writing Jelly-encoded RDF data</li> <li>Seamless integration with RDFLib (\"works just like Turtle\")</li> <li>Support for all Jelly stream types</li> <li>Tools for working with delimited and non-delimited Jelly streams</li> <li>Fine-grained control over serialization options, compression, and framing</li> </ul>"},{"location":"overview/#overview","title":"Overview","text":""},{"location":"overview/#use-cases","title":"Use cases","text":"<p>pyjelly is suitable for:</p> <ul> <li>Compact serialization of large RDF graphs and datasets.</li> <li>Incremental or streaming processing of RDF data.</li> <li>Writing or reading <code>.jelly</code> files in data pipelines.</li> <li>Efficient on-disk storage of RDF collections.</li> <li>Interchange of RDF data between systems.</li> </ul>"},{"location":"overview/#supported-stream-types","title":"Supported stream types","text":"<p>pyjelly supports all physical stream types including <code>TRIPLES</code>, <code>QUADS</code> and <code>GRAPHS</code>.</p> <p>However, only the following logical stream types are currently supported: <code>UNSPECIFIED</code>, <code>FLAT_TRIPLES</code>, <code>FLAT_QUADS</code>.</p> <p>Warning</p> <p>Grouped logical stream types are not yet supported. Frames with grouped logical types will raise an error at parse time.</p> <p>See the full stream type matrix for an overview of valid combinations.</p>"},{"location":"overview/#conformance-to-the-jelly-protocol","title":"Conformance to the Jelly protocol","text":"<p>pyjelly is designed to conform to version dev of the Jelly specification. It adheres to:</p> <ul> <li>Stream header structure and metadata.</li> <li>Frame structure and ordering guarantees.</li> <li>Compression rules and lookup tables.</li> <li>Namespace declarations and stream options.</li> </ul> <p>Parsing includes automatic validation of conformance raised when violations occur.</p>"},{"location":"overview/#limitations","title":"Limitations","text":"<ul> <li>Grouped logical stream types are not yet supported.</li> <li>Quoted graphs (RDF-star nested triples) are not supported.</li> <li>Multi-dataset streams cannot currently be parsed into a single <code>Dataset</code>.</li> <li>Logical stream type detection is not automatic; it must be set explicitly via options.</li> </ul>"},{"location":"contributing/","title":"Contributing to pyjelly","text":"<p>Hi! This guide explains how to get started with developing pyjelly and contributing to it.</p>"},{"location":"contributing/#quick-start","title":"Quick start","text":"<ol> <li> <p>Clone the project with <code>git clone git@github.com:Jelly-RDF/pyjelly.git</code>.</p> </li> <li> <p>We use <code>uv</code> for package management. If you don't already have it, install uv.</p> <ul> <li>On Linux this is: <code>curl -LsSf https://astral.sh/uv/install.sh | sh</code></li> </ul> </li> <li> <p>Run <code>uv sync</code> to install the project.</p> <ul> <li>If you use an IDE, make sure that it uses the Python interpreter from the environment that will be created in the <code>.venv</code> directory.</li> <li>If you get an error about the uv version being incorrect, run <code>uv self update</code></li> </ul> </li> <li> <p>Activate the environment or use <code>uv run</code> to run commands and code. </p> </li> </ol>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Jelly-RDF/pyjelly/issues</p> <p>If you are proposing a feature:</p> <ol> <li>Explain how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Contributions are always welcome! Consider if you can help with implementing the feature.</li> </ol>"},{"location":"contributing/#contributions","title":"Contributions","text":"<ol> <li>Every major pull request should be connected to an issue. If you see a problem, first create an issue.<ul> <li>For minor issues (typos, small fixes) make sure you describe your problem well in the PR.</li> </ul> </li> <li>When opening a pull request:<ul> <li>Use a descriptive title.</li> <li>Reference the related issue in the description.</li> </ul> </li> <li>Please make sure your code passes all the checks:<ul> <li>Tests (<code>pytest</code>)</li> <li>Type safety (<code>mypy</code>)</li> <li>Formatting and linting (<code>ruff</code> or via <code>pre-commit</code>) This helps us follow best practices and keep the codebase in shape.</li> </ul> </li> </ol>"},{"location":"contributing/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"contributing/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at community@neverblink.eu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/code_of_conduct/#attribution","title":"Attribution","text":"<p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"}]}