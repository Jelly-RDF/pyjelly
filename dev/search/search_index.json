{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyjelly","text":"<p>pyjelly is a Python implementation of Jelly, a high-performance binary serialization format and streaming protocol for RDF knowledge graphs. It works great with RDFLib.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast reading and writing of RDF knowledge graphs in the Jelly format</li> <li>Seamless integration with RDFLib</li> <li>Stream processing support for large datasets or streams of many RDF graphs/datasets</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting started</li> <li>Overview and supported features</li> <li>Generic interface (usage without RDFLib)</li> <li>API reference</li> <li>Contributing \u2013 how to report issues, contribute code, and request features</li> </ul>"},{"location":"#compatibility","title":"Compatibility","text":"<p>pyjelly is compatible with Python 3.10 and newer. Python 3.10\u20133.14 are tested in CI and are guaranteed to work.</p> <p>The following table shows the compatibility of the pyjelly implementation with other libraries:</p> pyjelly Python RDFLib 0.7.0 \u2013 0.6.2 3.10 \u2013 3.14 7.x (&gt;= 7.1.4) 0.1.0 \u2013 0.6.2 3.9 \u2013 3.13 7.x (&gt;= 7.1.4) <p>See the release notes on GitHub for more details.</p>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p>"},{"location":"#license","title":"License","text":"<p>The pyjelly library is licensed under the Apache 2.0 license.</p> <p>The development of the Jelly protocol, its implementations, and supporting tooling was co-funded by the European Union. More details.</p> <p></p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#pyjelly","title":"<code>pyjelly</code>","text":"<p>Modules:</p> Name Description <code>errors</code> <code>integrations</code> <code>jelly</code> <code>options</code> <code>parse</code> <code>serialize</code>"},{"location":"api/#pyjelly.errors","title":"<code>errors</code>","text":"<p>Classes:</p> Name Description <code>JellyConformanceError</code> <p>Raised when Jelly conformance is violated.</p> <code>JellyAssertionError</code> <p>Raised when a recommended assertion from the specification fails.</p> <code>JellyNotImplementedError</code> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.errors.JellyConformanceError","title":"<code>JellyConformanceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when Jelly conformance is violated.</p>"},{"location":"api/#pyjelly.errors.JellyAssertionError","title":"<code>JellyAssertionError</code>","text":"<p>               Bases: <code>AssertionError</code></p> <p>Raised when a recommended assertion from the specification fails.</p>"},{"location":"api/#pyjelly.errors.JellyNotImplementedError","title":"<code>JellyNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.integrations","title":"<code>integrations</code>","text":"<p>Modules:</p> Name Description <code>generic</code> <code>rdflib</code>"},{"location":"api/#pyjelly.integrations.generic","title":"<code>generic</code>","text":"<p>Modules:</p> Name Description <code>generic_sink</code> <code>parse</code> <code>serialize</code>"},{"location":"api/#pyjelly.integrations.generic.generic_sink","title":"<code>generic_sink</code>","text":"<p>Classes:</p> Name Description <code>BlankNode</code> <p>Class for blank nodes, storing BN's identifier as a string.</p> <code>IRI</code> <p>Class for IRIs, storing IRI as a string.</p> <code>Literal</code> <p>Class for literals.</p> <code>Triple</code> <p>Class for RDF triples.</p> <code>Quad</code> <p>Class for RDF quads.</p> <code>Prefix</code> <p>Class for generic namespace declaration.</p> <code>GenericStatementSink</code> <code>BlankNode(identifier)</code> <p>Class for blank nodes, storing BN's identifier as a string.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, identifier: str) -&gt; None:\n    self._identifier: str = identifier\n</code></pre> <code>IRI(iri)</code> <p>Class for IRIs, storing IRI as a string.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, iri: str) -&gt; None:\n    self._iri: str = iri\n</code></pre> <code>Literal(lex, langtag=None, datatype=None)</code> <p>Class for literals.</p> <p>Notes:     Consists of: lexical form, and optional language tag and datatype.     All parts of literal are stored as strings.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(\n    self, lex: str, langtag: str | None = None, datatype: str | None = None\n) -&gt; None:\n    self._lex: str = lex\n    self._langtag: str | None = langtag\n    self._datatype: str | None = datatype\n</code></pre> <code>Triple</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for RDF triples.</p> <code>Quad</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for RDF quads.</p> <code>Prefix</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for generic namespace declaration.</p> <code>GenericStatementSink(identifier=DefaultGraph)</code> <p>Notes:     _store preserves the order of statements.</p> <p>Args:     identifier (str, optional): Identifier for a sink.         Defaults to DefaultGraph.</p> <p>Attributes:</p> Name Type Description <code>is_triples_sink</code> <code>bool</code> <p>Check if the sink contains triples or quads.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, identifier: GraphName = DefaultGraph) -&gt; None:\n    \"\"\"\n    Initialize statements storage, namespaces dictionary, and parser.\n\n    Notes:\n        _store preserves the order of statements.\n\n    Args:\n        identifier (str, optional): Identifier for a sink.\n            Defaults to DefaultGraph.\n\n    \"\"\"\n    self._store: deque[Triple | Quad] = deque()\n    self._namespaces: dict[str, IRI] = {}\n    self._identifier = identifier\n</code></pre> <code>is_triples_sink</code> <p>Check if the sink contains triples or quads.</p> <p>Returns:     bool: true, if length of statement is 3.</p>"},{"location":"api/#pyjelly.integrations.generic.parse","title":"<code>parse</code>","text":"<p>Classes:</p> Name Description <code>GenericStatementSinkAdapter</code> <p>Implement Adapter for generic statements.</p> <code>GenericTriplesAdapter</code> <p>Triples adapted implementation for GenericStatementSink.</p> <code>GenericQuadsAdapter</code> <p>Extends GenericQuadsBaseAdapter for QUADS physical type.</p> <code>GenericGraphsAdapter</code> <p>Extends GenericQuadsBaseAdapter for GRAPHS physical type.</p> <p>Functions:</p> Name Description <code>parse_triples_stream</code> <p>Parse flat triple stream.</p> <code>parse_quads_stream</code> <p>Parse flat quads stream.</p> <code>parse_jelly_grouped</code> <p>Take a jelly file and return generators of generic statements sinks.</p> <code>parse_jelly_to_graph</code> <p>Add statements from Generator to GenericStatementSink.</p> <code>parse_jelly_flat</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <code>GenericStatementSinkAdapter(*args, **kwargs)</code> <p>               Bases: <code>Adapter</code></p> <p>Implement Adapter for generic statements.</p> <p>Notes:     Returns custom RDF terms expected by GenericStatementSink,     handles namespace declarations, and quoted triples.</p> <p>Args:     Adapter (type): base Adapter class</p> <code>GenericTriplesAdapter(options)</code> <p>               Bases: <code>GenericStatementSinkAdapter</code></p> <p>Triples adapted implementation for GenericStatementSink.</p> <p>Args:     GenericStatementSinkAdapter (type): base GenericStatementSink         adapter implementation that handles terms and namespaces.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>GenericQuadsAdapter(options)</code> <p>               Bases: <code>GenericQuadsBaseAdapter</code></p> <p>Extends GenericQuadsBaseAdapter for QUADS physical type.</p> <p>Args:     GenericQuadsBaseAdapter (type): quads adapter that handles         base quads processing.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def __init__(self, options: ParserOptions) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>GenericGraphsAdapter(options)</code> <p>               Bases: <code>GenericQuadsBaseAdapter</code></p> <p>Extends GenericQuadsBaseAdapter for GRAPHS physical type.</p> <p>Notes:     introduces graph start/end, checks if graph exists.</p> <p>Args:     GenericQuadsBaseAdapter (type): quads adapter that handles         base quads processing.</p> <p>Raises:     JellyConformanceError: raised if graph start message was not received.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n    self._graph_id = None\n</code></pre> <code>parse_triples_stream(frames, options, frame_metadata=None)</code> <p>Parse flat triple stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options     frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable             used for extracting frame metadata</p> <p>Yields:     Generator[Iterable[Triple | Prefix]]:         Generator of iterables of Triple or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_triples_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n    frame_metadata: ContextVar[MutableMapping[str, bytes]] | None = None,\n) -&gt; Generator[Iterable[Triple | Prefix]]:\n    \"\"\"\n    Parse flat triple stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n        frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable\n                used for extracting frame metadata\n\n    Yields:\n        Generator[Iterable[Triple | Prefix]]:\n            Generator of iterables of Triple or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter = GenericTriplesAdapter(options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        if frame_metadata is not None:\n            frame_metadata.set(\n                frame.metadata\n            ) if frame.metadata else frame_metadata.set({})\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_quads_stream(frames, options, frame_metadata=None)</code> <p>Parse flat quads stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options     frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable             used for extracting frame metadata</p> <p>Yields:     Generator[Iterable[Quad | Prefix]]:         Generator of iterables of Quad or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_quads_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n    frame_metadata: ContextVar[MutableMapping[str, bytes]] | None = None,\n) -&gt; Generator[Iterable[Quad | Prefix]]:\n    \"\"\"\n    Parse flat quads stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n        frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable\n                used for extracting frame metadata\n\n    Yields:\n        Generator[Iterable[Quad | Prefix]]:\n            Generator of iterables of Quad or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter_class: type[GenericQuadsBaseAdapter]\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_QUADS:\n        adapter_class = GenericQuadsAdapter\n    else:\n        adapter_class = GenericGraphsAdapter\n    adapter = adapter_class(options=options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        if frame_metadata is not None:\n            frame_metadata.set(\n                frame.metadata\n            ) if frame.metadata else frame_metadata.set({})\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_jelly_grouped(inp, sink_factory=lambda: GenericStatementSink(), *, logical_type_strict=False, frame_metadata=None)</code> <p>Take a jelly file and return generators of generic statements sinks.</p> <p>Yields one generic statements sink per frame.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream     sink_factory (Callable): lambda to construct a statement sink.         By default, creates an empty in-memory GenericStatementSink.     logical_type_strict (bool): If True, validate the logical type         in stream options and require a grouped logical type.         Otherwise, only the physical type is used to route parsing.     frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable             used for extracting frame metadata</p> <p>Raises:     NotImplementedError: is raised if a physical type is not implemented</p> <p>Yields:     Generator[GenericStatementSink]:         returns generators for GenericStatementSink, regardless of stream type.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_jelly_grouped(\n    inp: IO[bytes],\n    sink_factory: Callable[[], GenericStatementSink] = lambda: GenericStatementSink(),\n    *,\n    logical_type_strict: bool = False,\n    frame_metadata: ContextVar[MutableMapping[str, bytes]] | None = None,\n) -&gt; Generator[GenericStatementSink]:\n    \"\"\"\n    Take a jelly file and return generators of generic statements sinks.\n\n    Yields one generic statements sink per frame.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream\n        sink_factory (Callable): lambda to construct a statement sink.\n            By default, creates an empty in-memory GenericStatementSink.\n        logical_type_strict (bool): If True, validate the *logical* type\n            in stream options and require a grouped logical type.\n            Otherwise, only the physical type is used to route parsing.\n        frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable\n                used for extracting frame metadata\n\n    Raises:\n        NotImplementedError: is raised if a physical type is not implemented\n\n    Yields:\n        Generator[GenericStatementSink]:\n            returns generators for GenericStatementSink, regardless of stream type.\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (\n        st is None\n        or st.logical_type == jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED\n        or st.flat\n    ):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected GROUPED logical type, got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for graph in parse_triples_stream(\n            frames=frames,\n            options=options,\n            **{\"frame_metadata\": frame_metadata} if frame_metadata is not None else {},\n        ):\n            sink = sink_factory()\n            for graph_item in graph:\n                if isinstance(graph_item, Prefix):\n                    sink.bind(graph_item.prefix, graph_item.iri)\n                else:\n                    sink.add(graph_item)\n            yield sink\n        return\n    elif options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for dataset in parse_quads_stream(\n            frames=frames,\n            options=options,\n            **{\"frame_metadata\": frame_metadata} if frame_metadata is not None else {},\n        ):\n            sink = sink_factory()\n            for item in dataset:\n                if isinstance(item, Prefix):\n                    sink.bind(item.prefix, item.iri)\n                else:\n                    sink.add(item)\n            yield sink\n        return\n\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre> <code>parse_jelly_to_graph(inp, sink_factory=lambda: GenericStatementSink())</code> <p>Add statements from Generator to GenericStatementSink.</p> <p>Args:     inp (IO[bytes]): input jelly stream.     sink_factory (Callable[[], GenericStatementSink]): factory to create         statement sink.         By default creates an empty in-memory GenericStatementSink.         Has no division for datasets/graphs,         utilizes the same underlying data structures.</p> <p>Returns:     GenericStatementSink: GenericStatementSink with statements.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_jelly_to_graph(\n    inp: IO[bytes],\n    sink_factory: Callable[[], GenericStatementSink] = lambda: GenericStatementSink(),\n) -&gt; GenericStatementSink:\n    \"\"\"\n    Add statements from Generator to GenericStatementSink.\n\n    Args:\n        inp (IO[bytes]): input jelly stream.\n        sink_factory (Callable[[], GenericStatementSink]): factory to create\n            statement sink.\n            By default creates an empty in-memory GenericStatementSink.\n            Has no division for datasets/graphs,\n            utilizes the same underlying data structures.\n\n    Returns:\n        GenericStatementSink: GenericStatementSink with statements.\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n    sink = sink_factory()\n\n    for item in parse_jelly_flat(\n        inp=inp, frames=frames, options=options, logical_type_strict=False\n    ):\n        if isinstance(item, Prefix):\n            sink.bind(item.prefix, item.iri)  # type: ignore[union-attr, unused-ignore]\n        else:\n            sink.add(item)\n    return sink\n</code></pre> <code>parse_jelly_flat(inp, frames=None, options=None, *, logical_type_strict=False)</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream.     frames (Iterable[jelly.RdfStreamFrame | None):         jelly frames if read before.     options (ParserOptions | None): stream options         if read before.     logical_type_strict (bool): If True, validate the logical type         in stream options and require FLAT (TRIPLES/QUADS).         Otherwise, only the physical type is used to route parsing.</p> <p>Raises:     NotImplementedError: if physical type is not supported</p> <p>Yields:     Generator[Statement | Prefix]: Generator of stream events</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_jelly_flat(\n    inp: IO[bytes],\n    frames: Iterable[jelly.RdfStreamFrame] | None = None,\n    options: ParserOptions | None = None,\n    *,\n    logical_type_strict: bool = False,\n) -&gt; Generator[Statement | Prefix]:  # type: ignore[valid-type, unused-ignore]\n    \"\"\"\n    Parse jelly file with FLAT logical type into a Generator of stream events.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream.\n        frames (Iterable[jelly.RdfStreamFrame | None):\n            jelly frames if read before.\n        options (ParserOptions | None): stream options\n            if read before.\n        logical_type_strict (bool): If True, validate the *logical* type\n            in stream options and require FLAT (TRIPLES/QUADS).\n            Otherwise, only the physical type is used to route parsing.\n\n    Raises:\n        NotImplementedError: if physical type is not supported\n\n    Yields:\n        Generator[Statement | Prefix]: Generator of stream events\n\n    \"\"\"\n    if frames is None or options is None:\n        options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (st is None or not st.flat):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected FLAT logical type (TRIPLES/QUADS), got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for triples in parse_triples_stream(frames=frames, options=options):\n            yield from triples\n        return\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for quads in parse_quads_stream(frames=frames, options=options):\n            yield from quads\n        return\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#pyjelly.integrations.generic.serialize","title":"<code>serialize</code>","text":"<p>Modules:</p> Name Description <code>jelly</code> <p>Generated protocol buffer code.</p> <p>Classes:</p> Name Description <code>BlankNode</code> <p>Class for blank nodes, storing BN's identifier as a string.</p> <code>GenericSinkTermEncoder</code> <code>GenericStatementSink</code> <code>GraphStream</code> <code>IRI</code> <p>Class for IRIs, storing IRI as a string.</p> <code>Literal</code> <p>Class for literals.</p> <code>Quad</code> <p>Class for RDF quads.</p> <code>QuadStream</code> <code>Slot</code> <p>mypyc filler docstring</p> <code>Stream</code> <code>TermEncoder</code> <code>Triple</code> <p>Class for RDF triples.</p> <code>TripleStream</code> <p>Functions:</p> Name Description <code>stream_frames</code> <p>Attributes:</p> Name Type Description <code>HasGraph</code> <p>Represent a PEP 604 union type</p> <code>QUAD_ARITY</code> <p>int([x]) -&gt; integer</p> <code>Statement</code> <p>Represent a PEP 604 union type</p> <code>__file__</code> <p>str(object='') -&gt; str</p> <code>__name__</code> <p>str(object='') -&gt; str</p> <code>__package__</code> <p>str(object='') -&gt; str</p> <code>HasGraph = rdf_pb2.RdfQuad | rdf_pb2.RdfGraphStart</code> <p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p> <code>QUAD_ARITY = 4</code> <p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p> <code>Statement = rdf_pb2.RdfQuad | rdf_pb2.RdfTriple</code> <p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p> <code>__file__ = '/home/runner/work/pyjelly/pyjelly/pyjelly/integrations/generic/serialize.cpython-310-x86_64-linux-gnu.so'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__name__ = 'pyjelly.integrations.generic.serialize'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__package__ = 'pyjelly.integrations.generic'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>BlankNode(identifier)</code> <p>Class for blank nodes, storing BN's identifier as a string.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, identifier: str) -&gt; None:\n    self._identifier: str = identifier\n</code></pre> <code>GenericSinkTermEncoder(*args, **kwargs)</code> <p>               Bases: <code>pyjelly.serialize.encode.TermEncoder</code></p> <p>Methods:</p> Name Description <code>__new__</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <p>Attributes:</p> Name Type Description <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>__mypyc_attrs__</code> <p>Built-in immutable sequence.</p> <code>__doc__ = ''</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.integrations.generic.serialize'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__mypyc_attrs__ = ('lookup_preset', 'names', 'prefixes', 'datatypes')</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>__new__(*args, **kwargs)</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <code>GenericStatementSink(identifier=DefaultGraph)</code> <p>Notes:     _store preserves the order of statements.</p> <p>Args:     identifier (str, optional): Identifier for a sink.         Defaults to DefaultGraph.</p> <p>Attributes:</p> Name Type Description <code>is_triples_sink</code> <code>bool</code> <p>Check if the sink contains triples or quads.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, identifier: GraphName = DefaultGraph) -&gt; None:\n    \"\"\"\n    Initialize statements storage, namespaces dictionary, and parser.\n\n    Notes:\n        _store preserves the order of statements.\n\n    Args:\n        identifier (str, optional): Identifier for a sink.\n            Defaults to DefaultGraph.\n\n    \"\"\"\n    self._store: deque[Triple | Quad] = deque()\n    self._namespaces: dict[str, IRI] = {}\n    self._identifier = identifier\n</code></pre> <code>is_triples_sink</code> <p>Check if the sink contains triples or quads.</p> <p>Returns:     bool: true, if length of statement is 3.</p> <code>GraphStream(*, encoder, options=None)</code> <p>               Bases: <code>TripleStream</code></p> <p>Methods:</p> Name Description <code>graph</code> <p>Process one graph into a sequence of jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>graph(graph_id, graph)</code> <p>Process one graph into a sequence of jelly frames.</p> <p>Args:     graph_id (object): graph id (BN, Literal, iri, default)     graph (Iterable[Iterable[object]]): iterable of triples (graph's content)</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def graph(\n    self,\n    graph_id: object,\n    graph: Iterable[Iterable[object]],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Process one graph into a sequence of jelly frames.\n\n    Args:\n        graph_id (object): graph id (BN, Literal, iri, default)\n        graph (Iterable[Iterable[object]]): iterable of triples (graph's content)\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    graph_start = jelly.RdfGraphStart()\n    [*graph_rows] = self.encoder.encode_graph(graph_id, graph_start)\n    start_row = jelly.RdfStreamRow(graph_start=graph_start)\n    graph_rows.append(start_row)\n    self.flow.extend(graph_rows)\n    for triple in graph:\n        if frame := self.triple(triple):  # has frame slicing inside\n            yield frame\n    end_row = jelly.RdfStreamRow(graph_end=jelly.RdfGraphEnd())\n    self.flow.append(end_row)\n    if frame := self.flow.frame_from_bounds():\n        yield frame\n</code></pre> <code>IRI(iri)</code> <p>Class for IRIs, storing IRI as a string.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, iri: str) -&gt; None:\n    self._iri: str = iri\n</code></pre> <code>Literal(lex, langtag=None, datatype=None)</code> <p>Class for literals.</p> <p>Notes:     Consists of: lexical form, and optional language tag and datatype.     All parts of literal are stored as strings.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(\n    self, lex: str, langtag: str | None = None, datatype: str | None = None\n) -&gt; None:\n    self._lex: str = lex\n    self._langtag: str | None = langtag\n    self._datatype: str | None = datatype\n</code></pre> <code>Quad</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for RDF quads.</p> <code>QuadStream(*, encoder, options=None)</code> <p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>quad</code> <p>Process one quad to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>quad(terms)</code> <p>Process one quad to Protobuf messages.</p> <p>Args:     terms (Iterable[object]): terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def quad(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one quad to Protobuf messages.\n\n    Args:\n        terms (Iterable[object]): terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_quad(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre> <code>Slot</code> <p>               Bases: <code>enum.IntEnum</code></p> <p>mypyc filler docstring</p> <p>Attributes:</p> Name Type Description <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>graph</code> <p>mypyc filler docstring</p> <code>object</code> <p>mypyc filler docstring</p> <code>predicate</code> <p>mypyc filler docstring</p> <code>subject</code> <p>mypyc filler docstring</p> <code>__doc__ = 'mypyc filler docstring'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.serialize.encode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>graph = &lt;Slot.graph: 3&gt;</code> <p>mypyc filler docstring</p> <code>object = &lt;Slot.object: 2&gt;</code> <p>mypyc filler docstring</p> <code>predicate = &lt;Slot.predicate: 1&gt;</code> <p>mypyc filler docstring</p> <code>subject = &lt;Slot.subject: 0&gt;</code> <p>mypyc filler docstring</p> <code>Stream(*, encoder, options=None)</code> <p>Methods:</p> Name Description <code>infer_flow</code> <p>Return flow based on the stream options provided.</p> <code>enroll</code> <p>Initialize start of the stream.</p> <code>stream_options</code> <p>Encode and append stream options row to the current flow.</p> <code>namespace_declaration</code> <p>Add namespace declaration to jelly stream.</p> <code>for_rdflib</code> <p>Initialize stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>infer_flow()</code> <p>Return flow based on the stream options provided.</p> <p>Returns:     FrameFlow: initialised FrameFlow object.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def infer_flow(self) -&gt; FrameFlow:\n    \"\"\"\n    Return flow based on the stream options provided.\n\n    Returns:\n        FrameFlow: initialised FrameFlow object.\n\n    \"\"\"\n    flow: FrameFlow\n    if self.options.params.delimited:\n        if self.options.logical_type != jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED:\n            flow_class = flow_for_type(self.options.logical_type)\n        else:\n            flow_class = self.default_delimited_flow_class\n\n        if self.options.logical_type in (\n            jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES,\n            jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS,\n        ):\n            flow = flow_class(\n                logical_type=self.options.logical_type,\n                frame_size=self.options.frame_size,\n            )\n        else:\n            flow = flow_class(logical_type=self.options.logical_type)\n    else:\n        flow = ManualFrameFlow(logical_type=self.options.logical_type)\n    return flow\n</code></pre> <code>enroll()</code> <p>Initialize start of the stream.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def enroll(self) -&gt; None:\n    \"\"\"Initialize start of the stream.\"\"\"\n    if not self.enrolled:\n        self.stream_options()\n        self.enrolled = True\n</code></pre> <code>stream_options()</code> <p>Encode and append stream options row to the current flow.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_options(self) -&gt; None:\n    \"\"\"Encode and append stream options row to the current flow.\"\"\"\n    self.flow.append(\n        encode_options(\n            stream_types=self.stream_types,\n            params=self.options.params,\n            lookup_preset=self.options.lookup_preset,\n        )\n    )\n</code></pre> <code>namespace_declaration(name, iri)</code> <p>Add namespace declaration to jelly stream.</p> <p>Args:     name (str): namespace prefix label     iri (str): namespace iri</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def namespace_declaration(self, name: str, iri: str) -&gt; None:\n    \"\"\"\n    Add namespace declaration to jelly stream.\n\n    Args:\n        name (str): namespace prefix label\n        iri (str): namespace iri\n\n    \"\"\"\n    rows = encode_namespace_declaration(\n        name=name,\n        value=iri,\n        term_encoder=self.encoder,\n    )\n    self.flow.extend(rows)\n</code></pre> <code>for_rdflib(options=None)</code> <p>Initialize stream with RDFLib encoder.</p> <p>Args:     options (SerializerOptions | None, optional): Stream options.         Defaults to None.</p> <p>Raises:     TypeError: if Stream is passed, and not a Stream for specific physical type.</p> <p>Returns:     Stream: initialized stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>@classmethod\ndef for_rdflib(cls, options: SerializerOptions | None = None) -&gt; Stream:\n    \"\"\"\n    Initialize stream with RDFLib encoder.\n\n    Args:\n        options (SerializerOptions | None, optional): Stream options.\n            Defaults to None.\n\n    Raises:\n        TypeError: if Stream is passed, and not a Stream for specific physical type.\n\n    Returns:\n        Stream: initialized stream with RDFLib encoder.\n\n    \"\"\"\n    if cls is Stream:\n        msg = \"Stream is an abstract base class, use a subclass instead\"\n        raise TypeError(msg)\n    from pyjelly.integrations.rdflib.serialize import RDFLibTermEncoder\n\n    lookup_preset: LookupPreset | None = None\n    if options is not None:\n        lookup_preset = options.lookup_preset\n    return cls(\n        encoder=RDFLibTermEncoder(lookup_preset=lookup_preset),\n        options=options,\n    )\n</code></pre> <code>TermEncoder(*args, **kwargs)</code> <p>Methods:</p> Name Description <code>__new__</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <p>Attributes:</p> Name Type Description <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>__mypyc_attrs__</code> <p>Built-in immutable sequence.</p> <code>__doc__ = ''</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.serialize.encode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__mypyc_attrs__ = ('lookup_preset', 'names', 'prefixes', 'datatypes')</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>__new__(*args, **kwargs)</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <code>Triple</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for RDF triples.</p> <code>TripleStream(*, encoder, options=None)</code> <p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>triple</code> <p>Process one triple to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>triple(terms)</code> <p>Process one triple to Protobuf messages.</p> <p>Note:     Adds new rows to the current flow and returns StreamFrame if     frame size conditions are met.</p> <p>Args:     terms (Iterable[object]): RDF terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def triple(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one triple to Protobuf messages.\n\n    Note:\n        Adds new rows to the current flow and returns StreamFrame if\n        frame size conditions are met.\n\n    Args:\n        terms (Iterable[object]): RDF terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_triple(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre> <code>stream_frames()</code> <code>jelly</code> <p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.integrations.rdflib","title":"<code>rdflib</code>","text":"<p>Modules:</p> Name Description <code>parse</code> <code>serialize</code> <p>Functions:</p> Name Description <code>register_extension_to_rdflib</code> <p>Make rdflib.util.guess_format discover Jelly format.</p>"},{"location":"api/#pyjelly.integrations.rdflib.register_extension_to_rdflib","title":"<code>register_extension_to_rdflib(extension='.jelly')</code>","text":"<p>Make rdflib.util.guess_format discover Jelly format.</p> <p>rdflib.util.guess_format(\"foo.jelly\") register_extension_to_rdflib() rdflib.util.guess_format(\"foo.jelly\") 'jelly'</p> Source code in <code>pyjelly/integrations/rdflib/__init__.py</code> <pre><code>def register_extension_to_rdflib(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Make [rdflib.util.guess_format][] discover Jelly format.\n\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    &gt;&gt;&gt; register_extension_to_rdflib()\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    'jelly'\n    \"\"\"\n    rdflib.util.SUFFIX_FORMAT_MAP[extension.removeprefix(\".\")] = \"jelly\"\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.parse","title":"<code>parse</code>","text":"<p>Classes:</p> Name Description <code>Triple</code> <p>Describe RDFLib triple.</p> <code>Quad</code> <p>Describe RDFLib quad.</p> <code>Prefix</code> <p>Describe RDF Prefix(i.e, namespace declaration).</p> <code>RDFLibAdapter</code> <p>RDFLib adapter class, is extended by triples and quads implementations.</p> <code>RDFLibTriplesAdapter</code> <p>Triples adapter RDFLib implementation.</p> <code>RDFLibQuadsAdapter</code> <p>Extended RDFLib adapter for the QUADS physical type.</p> <code>RDFLibGraphsAdapter</code> <p>Extension of RDFLibQuadsBaseAdapter for the GRAPHS physical type.</p> <code>RDFLibJellyParser</code> <p>Functions:</p> Name Description <code>parse_triples_stream</code> <p>Parse flat triple stream.</p> <code>parse_quads_stream</code> <p>Parse flat quads stream.</p> <code>parse_jelly_grouped</code> <p>Take jelly file and return generators based on the detected physical type.</p> <code>parse_jelly_to_graph</code> <p>Add statements from Generator to provided Graph/Dataset.</p> <code>parse_jelly_flat</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <code>Triple</code> <p>               Bases: <code>tuple[Node, Node, Node]</code></p> <p>Describe RDFLib triple.</p> <p>Args:     tuple (Node, Node, Node): s/p/o tuple of RDFLib Nodes.</p> <p>Returns:     Triple: triple as tuple.</p> <code>Quad</code> <p>               Bases: <code>tuple[Node, Node, Node, GraphName]</code></p> <p>Describe RDFLib quad.</p> <p>Args:     tuple (Node, Node, Node, GraphName):         s/p/o/g as a tuple of RDFLib nodes and a GraphName,</p> <p>Returns:     Quad: quad as tuple.</p> <code>Prefix</code> <p>               Bases: <code>tuple[str, URIRef]</code></p> <p>Describe RDF Prefix(i.e, namespace declaration).</p> <p>Args:     tuple (str, rdflib.URIRef): expects prefix as a string,         and full namespace URI as Rdflib.URIRef.</p> <p>Returns:     Prefix: prefix as tuple(prefix, iri).</p> <code>RDFLibAdapter(*args, **kwargs)</code> <p>               Bases: <code>Adapter</code></p> <p>RDFLib adapter class, is extended by triples and quads implementations.</p> <p>Args:     Adapter (): abstract adapter class</p> <code>RDFLibTriplesAdapter(options)</code> <p>               Bases: <code>RDFLibAdapter</code></p> <p>Triples adapter RDFLib implementation.</p> <p>Notes: returns triple/namespace declaration as soon as receives them.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>RDFLibQuadsAdapter(options)</code> <p>               Bases: <code>RDFLibQuadsBaseAdapter</code></p> <p>Extended RDFLib adapter for the QUADS physical type.</p> <p>Args:     RDFLibQuadsBaseAdapter (RDFLibAdapter): base quads adapter         (shared with graphs physical type)</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(self, options: ParserOptions) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>RDFLibGraphsAdapter(options)</code> <p>               Bases: <code>RDFLibQuadsBaseAdapter</code></p> <p>Extension of RDFLibQuadsBaseAdapter for the GRAPHS physical type.</p> <p>Notes: introduces graph start/end, checks if graph exists.</p> <p>Args:     RDFLibQuadsBaseAdapter (RDFLibAdapter): base adapter for quads management.</p> <p>Raises:     JellyConformanceError: if no graph_start was encountered</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n    self._graph_id = None\n</code></pre> <code>RDFLibJellyParser</code> <p>               Bases: <code>Parser</code></p> <p>Methods:</p> Name Description <code>parse</code> <p>Parse jelly file into provided RDFLib Graph.</p> <code>parse(source, sink)</code> <p>Parse jelly file into provided RDFLib Graph.</p> <p>Args:     source (InputSource): jelly file as buffered binary stream InputSource obj     sink (Graph): RDFLib Graph</p> <p>Raises:     TypeError: raises error if invalid input</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse(\n    self,\n    source: InputSource,\n    sink: Graph,\n) -&gt; None:\n    \"\"\"\n    Parse jelly file into provided RDFLib Graph.\n\n    Args:\n        source (InputSource): jelly file as buffered binary stream InputSource obj\n        sink (Graph): RDFLib Graph\n\n    Raises:\n        TypeError: raises error if invalid input\n\n    \"\"\"\n    inp: BytesIO = source.getByteStream()  # type: ignore[no-untyped-call]\n    if inp is None:\n        msg = \"expected source to be a stream of bytes\"\n        raise TypeError(msg)\n    parse_jelly_to_graph(\n        inp,\n        graph_factory=lambda: Graph(store=sink.store, identifier=sink.identifier),\n        dataset_factory=lambda: Dataset(store=sink.store),\n    )\n</code></pre> <code>parse_triples_stream(frames, options, frame_metadata=None)</code> <p>Parse flat triple stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options     frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable         used for extracting frame metadata</p> <p>Yields:     Generator[Iterable[Triple | Prefix]]:         Generator of iterables of Triple or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_triples_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n    frame_metadata: ContextVar[MutableMapping[str, bytes]] | None = None,\n) -&gt; Generator[Iterable[Triple | Prefix]]:\n    \"\"\"\n    Parse flat triple stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n        frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable\n            used for extracting frame metadata\n\n    Yields:\n        Generator[Iterable[Triple | Prefix]]:\n            Generator of iterables of Triple or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter = RDFLibTriplesAdapter(options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        if frame_metadata is not None:\n            frame_metadata.set(\n                frame.metadata\n            ) if frame.metadata else frame_metadata.set({})\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_quads_stream(frames, options, frame_metadata=None)</code> <p>Parse flat quads stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options     frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable         used for extracting frame metadata</p> <p>Yields:     Generator[Iterable[Quad | Prefix]]:         Generator of iterables of Quad or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_quads_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n    frame_metadata: ContextVar[MutableMapping[str, bytes]] | None = None,\n) -&gt; Generator[Iterable[Quad | Prefix]]:\n    \"\"\"\n    Parse flat quads stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n        frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable\n            used for extracting frame metadata\n\n    Yields:\n        Generator[Iterable[Quad | Prefix]]:\n            Generator of iterables of Quad or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter_class: type[RDFLibQuadsBaseAdapter]\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_QUADS:\n        adapter_class = RDFLibQuadsAdapter\n    else:\n        adapter_class = RDFLibGraphsAdapter\n    adapter = adapter_class(options=options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        if frame_metadata is not None:\n            frame_metadata.set(\n                frame.metadata\n            ) if frame.metadata else frame_metadata.set({})\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_jelly_grouped(inp, graph_factory=lambda: Graph(), dataset_factory=lambda: Dataset(), *, logical_type_strict=False, frame_metadata=None)</code> <p>Take jelly file and return generators based on the detected physical type.</p> <p>Yields one graph/dataset per frame.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream     graph_factory (Callable): lambda to construct a Graph.         By default creates an empty in-memory Graph,         but you can pass something else here.     dataset_factory (Callable): lambda to construct a Dataset.         By default creates an empty in-memory Dataset,         but you can pass something else here.     logical_type_strict (bool): If True, validate the logical type in         stream options and require a grouped logical type. Otherwise, only the         physical type is used to route parsing.     frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable         used for extracting frame metadata</p> <p>Raises:     NotImplementedError: is raised if a physical type is not implemented</p> <p>Yields:     Generator[Graph] | Generator[Dataset]:         returns generators for graphs/datasets based on the type of input</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_grouped(\n    inp: IO[bytes],\n    graph_factory: Callable[[], Graph] = lambda: Graph(),\n    dataset_factory: Callable[[], Dataset] = lambda: Dataset(),\n    *,\n    logical_type_strict: bool = False,\n    frame_metadata: ContextVar[MutableMapping[str, bytes]] | None = None,\n) -&gt; Generator[Graph] | Generator[Dataset]:\n    \"\"\"\n    Take jelly file and return generators based on the detected physical type.\n\n    Yields one graph/dataset per frame.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream\n        graph_factory (Callable): lambda to construct a Graph.\n            By default creates an empty in-memory Graph,\n            but you can pass something else here.\n        dataset_factory (Callable): lambda to construct a Dataset.\n            By default creates an empty in-memory Dataset,\n            but you can pass something else here.\n        logical_type_strict (bool): If True, validate the *logical* type in\n            stream options and require a grouped logical type. Otherwise, only the\n            physical type is used to route parsing.\n        frame_metadata: (ContextVar[ScalarMap[str, bytes]]): context variable\n            used for extracting frame metadata\n\n\n\n    Raises:\n        NotImplementedError: is raised if a physical type is not implemented\n\n    Yields:\n        Generator[Graph] | Generator[Dataset]:\n            returns generators for graphs/datasets based on the type of input\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (\n        st is None\n        or st.logical_type == jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED\n        or st.flat\n    ):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected GROUPED logical type, got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for graph in parse_triples_stream(\n            frames=frames,\n            options=options,\n            frame_metadata=frame_metadata,\n        ):\n            sink = graph_factory()\n            for graph_item in graph:\n                if isinstance(graph_item, Prefix):\n                    sink.bind(graph_item.prefix, graph_item.iri)\n                else:\n                    sink.add(graph_item)\n            yield sink\n        return\n    elif options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for dataset in parse_quads_stream(\n            frames=frames, options=options, frame_metadata=frame_metadata\n        ):\n            sink = dataset_factory()\n            for item in dataset:\n                if isinstance(item, Prefix):\n                    sink.bind(item.prefix, item.iri)\n                else:\n                    s, p, o, graph_name = item\n                    context = sink.get_context(graph_name)\n                    sink.add((s, p, o, context))\n            yield sink\n        return\n\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre> <code>parse_jelly_to_graph(inp, graph_factory=lambda: Graph(), dataset_factory=lambda: Dataset())</code> <p>Add statements from Generator to provided Graph/Dataset.</p> <p>Args:     inp (IO[bytes]): input jelly stream.     graph_factory (Callable[[], Graph]): factory to create Graph.         By default creates an empty in-memory Graph,         but you can pass something else here.     dataset_factory (Callable[[], Dataset]): factory to create Dataset.         By default creates an empty in-memory Dataset,         but you can pass something else here.</p> <p>Returns:     Dataset | Graph: Dataset or Graph with statements.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_to_graph(\n    inp: IO[bytes],\n    graph_factory: Callable[[], Graph] = lambda: Graph(),\n    dataset_factory: Callable[[], Dataset] = lambda: Dataset(),\n) -&gt; Graph | Dataset:\n    \"\"\"\n    Add statements from Generator to provided Graph/Dataset.\n\n    Args:\n        inp (IO[bytes]): input jelly stream.\n        graph_factory (Callable[[], Graph]): factory to create Graph.\n            By default creates an empty in-memory Graph,\n            but you can pass something else here.\n        dataset_factory (Callable[[], Dataset]): factory to create Dataset.\n            By default creates an empty in-memory Dataset,\n            but you can pass something else here.\n\n    Returns:\n        Dataset | Graph: Dataset or Graph with statements.\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        sink = graph_factory()\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        quad_sink = dataset_factory()\n        sink = quad_sink\n\n    for item in parse_jelly_flat(inp=inp, frames=frames, options=options):\n        if isinstance(item, Prefix):\n            sink.bind(item.prefix, item.iri)\n        if isinstance(item, Triple):\n            sink.add(item)\n        if isinstance(item, Quad):\n            s, p, o, graph_name = item\n            context = quad_sink.get_context(graph_name)\n            quad_sink.add((s, p, o, context))\n    return sink\n</code></pre> <code>parse_jelly_flat(inp, frames=None, options=None, *, logical_type_strict=False)</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream.     frames (Iterable[jelly.RdfStreamFrame | None):         jelly frames if read before.     options (ParserOptions | None): stream options         if read before.     logical_type_strict (bool): If True, validate the logical type in         stream options and require FLAT_(TRIPLES|QUADS). Otherwise, only the         physical type is used to route parsing.</p> <p>Raises:     NotImplementedError: if physical type is not supported</p> <p>Yields:     Generator[Statement | Prefix]: Generator of stream events</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_flat(\n    inp: IO[bytes],\n    frames: Iterable[jelly.RdfStreamFrame] | None = None,\n    options: ParserOptions | None = None,\n    *,\n    logical_type_strict: bool = False,\n) -&gt; Generator[Statement | Prefix]:\n    \"\"\"\n    Parse jelly file with FLAT logical type into a Generator of stream events.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream.\n        frames (Iterable[jelly.RdfStreamFrame | None):\n            jelly frames if read before.\n        options (ParserOptions | None): stream options\n            if read before.\n        logical_type_strict (bool): If True, validate the *logical* type in\n            stream options and require FLAT_(TRIPLES|QUADS). Otherwise, only the\n            physical type is used to route parsing.\n\n    Raises:\n        NotImplementedError: if physical type is not supported\n\n    Yields:\n        Generator[Statement | Prefix]: Generator of stream events\n\n    \"\"\"\n    if frames is None or options is None:\n        options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (st is None or not st.flat):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected FLAT logical type (TRIPLES/QUADS), got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for triples in parse_triples_stream(frames=frames, options=options):\n            yield from triples\n        return\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for quads in parse_quads_stream(frames=frames, options=options):\n            yield from quads\n        return\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.serialize","title":"<code>serialize</code>","text":"<p>Classes:</p> Name Description <code>RDFLibTermEncoder</code> <code>RDFLibJellySerializer</code> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Functions:</p> Name Description <code>triples_stream_frames</code> <p>Serialize a Graph/Dataset into jelly frames.</p> <code>quads_stream_frames</code> <p>Serialize a Dataset into jelly frames.</p> <code>graphs_stream_frames</code> <p>Serialize a Dataset into jelly frames as a stream of graphs.</p> <code>guess_options</code> <p>Guess the serializer options based on the store type.</p> <code>guess_stream</code> <p>Return an appropriate stream implementation for the given options.</p> <code>grouped_stream_to_frames</code> <p>Transform Graphs/Datasets into Jelly frames, one frame per Graph/Dataset.</p> <code>grouped_stream_to_file</code> <p>Write stream of Graphs/Datasets to a binary file.</p> <code>flat_stream_to_frames</code> <p>Serialize a stream of raw triples or quads into Jelly frames.</p> <code>flat_stream_to_file</code> <p>Write Triple or Quad events to a binary file in Jelly flat format.</p> <code>RDFLibTermEncoder(*args, **kwargs)</code> <p>               Bases: <code>TermEncoder</code></p> <p>Methods:</p> Name Description <code>encode_spo</code> <p>Encode s/p/o term based on its RDFLib object.</p> <code>encode_graph</code> <p>Encode graph name term based on its RDFLib object.</p> <code>encode_spo(term, slot, statement)</code> <p>Encode s/p/o term based on its RDFLib object.</p> <p>Args:     term (object): term to encode     slot (Slot): its place in statement.     statement (Statement): Triple/Quad message to fill with s/p/o terms.</p> <p>Returns:     Rows: encoded extra rows</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def encode_spo(self, term: object, slot: Slot, statement: Statement) -&gt; Rows:\n    \"\"\"\n    Encode s/p/o term based on its RDFLib object.\n\n    Args:\n        term (object): term to encode\n        slot (Slot): its place in statement.\n        statement (Statement): Triple/Quad message to fill with s/p/o terms.\n\n    Returns:\n        Rows: encoded extra rows\n\n    \"\"\"\n    if isinstance(term, rdflib.URIRef):\n        iri = self.get_iri_field(statement, slot)\n        return self.encode_iri(term, iri)\n\n    if isinstance(term, rdflib.Literal):\n        literal = self.get_literal_field(statement, slot)\n        return self.encode_literal(\n            lex=str(term),\n            language=term.language,\n            # `datatype` is cast to `str` explicitly because\n            # `URIRef.__eq__` overrides `str.__eq__` in an incompatible manner\n            datatype=term.datatype and str(term.datatype),\n            literal=literal,\n        )\n\n    if isinstance(term, rdflib.BNode):\n        self.set_bnode_field(statement, slot, str(term))\n        return ()\n\n    return super().encode_spo(term, slot, statement)  # error if not handled\n</code></pre> <code>encode_graph(term, statement)</code> <p>Encode graph name term based on its RDFLib object.</p> <p>Args:     term (object): term to encode     statement (HasGraph): Quad/GraphStart message to fill g_{} in.</p> <p>Returns:     Rows: encoded extra rows</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def encode_graph(self, term: object, statement: HasGraph) -&gt; Rows:\n    \"\"\"\n    Encode graph name term based on its RDFLib object.\n\n    Args:\n        term (object): term to encode\n        statement (HasGraph): Quad/GraphStart message to fill g_{} in.\n\n    Returns:\n        Rows: encoded extra rows\n\n    \"\"\"\n    if term == DATASET_DEFAULT_GRAPH_ID:\n        return self.encode_default_graph(statement.g_default_graph)\n\n    if isinstance(term, rdflib.URIRef):\n        return self.encode_iri(term, statement.g_iri)\n\n    if isinstance(term, rdflib.BNode):\n        statement.g_bnode = str(term)\n        return ()\n    return super().encode_graph(term, statement)  # error if not handled\n</code></pre> <code>RDFLibJellySerializer(store)</code> <p>               Bases: <code>Serializer</code></p> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Handles streaming RDF terms into Jelly frames using internal encoders. Supports only graphs and datasets (not quoted graphs).</p> <p>Methods:</p> Name Description <code>serialize</code> <p>Serialize self.store content to Jelly format.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def __init__(self, store: Graph) -&gt; None:\n    if isinstance(store, QuotedGraph):\n        msg = \"N3 format is not supported\"\n        raise NotImplementedError(msg)\n    super().__init__(store)\n</code></pre> <code>serialize(out, /, *, stream=None, options=None, **unused)</code> <p>Serialize self.store content to Jelly format.</p> <p>Args:     out (IO[bytes]): output buffered writer     stream (Stream | None, optional): Jelly stream object. Defaults to None.     options (SerializerOptions | None, optional): Serializer options         if defined beforehand, e.g., read from a separate file.         Defaults to None.     **unused(Any): unused args for RDFLib serialize</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@override\ndef serialize(  # type: ignore[override]\n    self,\n    out: IO[bytes],\n    /,\n    *,\n    stream: Stream | None = None,\n    options: SerializerOptions | None = None,\n    **unused: Any,\n) -&gt; None:\n    \"\"\"\n    Serialize self.store content to Jelly format.\n\n    Args:\n        out (IO[bytes]): output buffered writer\n        stream (Stream | None, optional): Jelly stream object. Defaults to None.\n        options (SerializerOptions | None, optional): Serializer options\n            if defined beforehand, e.g., read from a separate file.\n            Defaults to None.\n        **unused(Any): unused args for RDFLib serialize\n\n    \"\"\"\n    if options is None:\n        options = guess_options(self.store)\n    if stream is None:\n        stream = guess_stream(options, self.store)\n    write = write_delimited if stream.options.params.delimited else write_single\n    for stream_frame in stream_frames(stream, self.store):\n        write(stream_frame, out)\n</code></pre> <code>triples_stream_frames(stream, data)</code> <p>Serialize a Graph/Dataset into jelly frames.</p> <p>Args:     stream (TripleStream): stream that specifies triples processing     data (Graph | Dataset | Generator[Triple]):         Graph/Dataset/Statements to serialize.</p> <p>Notes:     if Dataset is given, its graphs are unpacked and iterated over     if flow is GraphsFrameFlow, emits a frame per graph.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(TripleStream)\ndef triples_stream_frames(\n    stream: TripleStream,\n    data: Graph | Dataset | Generator[Triple],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Graph/Dataset into jelly frames.\n\n    Args:\n        stream (TripleStream): stream that specifies triples processing\n        data (Graph | Dataset | Generator[Triple]):\n            Graph/Dataset/Statements to serialize.\n\n    Notes:\n        if Dataset is given, its graphs are unpacked and iterated over\n        if flow is GraphsFrameFlow, emits a frame per graph.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    stream.enroll()\n    if isinstance(data, Graph) and stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)\n\n    graphs = (data,) if not isinstance(data, Dataset) else data.graphs()\n    for graph in graphs:\n        for terms in graph:\n            if frame := stream.triple(terms):\n                yield frame\n        if frame := stream.flow.frame_from_graph():\n            yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>quads_stream_frames(stream, data)</code> <p>Serialize a Dataset into jelly frames.</p> <p>Notes:     Emits one frame per dataset if flow is of DatasetsFrameFlow.</p> <p>Args:     stream (QuadStream): stream that specifies quads processing     data (Dataset | Generator[Quad]): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(QuadStream)\ndef quads_stream_frames(\n    stream: QuadStream,\n    data: Dataset | Generator[Quad],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Dataset into jelly frames.\n\n    Notes:\n        Emits one frame per dataset if flow is of DatasetsFrameFlow.\n\n    Args:\n        stream (QuadStream): stream that specifies quads processing\n        data (Dataset | Generator[Quad]): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)  # type: ignore[arg-type]\n    iterator: Generator[Quad, None, None]\n    if isinstance(data, Dataset):\n        iterator = cast(Generator[Quad, None, None], data.quads())\n    else:\n        iterator = data\n\n    for terms in iterator:\n        if frame := stream.quad(terms):\n            yield frame\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>graphs_stream_frames(stream, data)</code> <p>Serialize a Dataset into jelly frames as a stream of graphs.</p> <p>Notes:     If flow of DatasetsFrameFlow type, the whole dataset     will be encoded into one frame.</p> <p>Args:     stream (GraphStream): stream that specifies graphs processing     data (Dataset | Generator[Quad]): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(GraphStream)\ndef graphs_stream_frames(\n    stream: GraphStream,\n    data: Dataset | Generator[Quad],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Dataset into jelly frames as a stream of graphs.\n\n    Notes:\n        If flow of DatasetsFrameFlow type, the whole dataset\n        will be encoded into one frame.\n\n    Args:\n        stream (GraphStream): stream that specifies graphs processing\n        data (Dataset | Generator[Quad]): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)  # type: ignore[arg-type]\n\n    if isinstance(data, Dataset):\n        graphs = data.graphs()\n    else:\n        ds = Dataset()\n        for quad in data:\n            ctx = ds.get_context(quad.g)\n            ctx.add((quad.s, quad.p, quad.o))\n        graphs = ds.graphs()\n\n    for graph in graphs:\n        yield from stream.graph(graph_id=graph.identifier, graph=graph)\n\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>guess_options(sink)</code> <p>Guess the serializer options based on the store type.</p> <p>guess_options(Graph()).logical_type 1 guess_options(Dataset()).logical_type 2</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_options(sink: Graph | Dataset) -&gt; SerializerOptions:\n    \"\"\"\n    Guess the serializer options based on the store type.\n\n    &gt;&gt;&gt; guess_options(Graph()).logical_type\n    1\n    &gt;&gt;&gt; guess_options(Dataset()).logical_type\n    2\n    \"\"\"\n    logical_type = (\n        jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS\n        if isinstance(sink, Dataset)\n        else jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES\n    )\n    # RDFLib doesn't support RDF-star and generalized statements by default\n    # as it requires specific handling for quoted triples and non-standard RDF terms\n    params = StreamParameters(generalized_statements=False, rdf_star=False)\n    return SerializerOptions(logical_type=logical_type, params=params)\n</code></pre> <code>guess_stream(options, sink)</code> <p>Return an appropriate stream implementation for the given options.</p> <p>Notes: if base(!) logical type is GRAPHS and Dataset is given,     initializes TripleStream</p> <p>graph_ser = RDFLibJellySerializer(Graph()) ds_ser = RDFLibJellySerializer(Dataset())</p> <p>type(guess_stream(guess_options(graph_ser.store), graph_ser.store))  type(guess_stream(guess_options(ds_ser.store), ds_ser.store))  Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_stream(options: SerializerOptions, sink: Graph | Dataset) -&gt; Stream:\n    \"\"\"\n    Return an appropriate stream implementation for the given options.\n\n    Notes: if base(!) logical type is GRAPHS and Dataset is given,\n        initializes TripleStream\n\n    &gt;&gt;&gt; graph_ser = RDFLibJellySerializer(Graph())\n    &gt;&gt;&gt; ds_ser = RDFLibJellySerializer(Dataset())\n\n    &gt;&gt;&gt; type(guess_stream(guess_options(graph_ser.store), graph_ser.store))\n    &lt;class 'pyjelly.serialize.streams.TripleStream'&gt;\n    &gt;&gt;&gt; type(guess_stream(guess_options(ds_ser.store), ds_ser.store))\n    &lt;class 'pyjelly.serialize.streams.QuadStream'&gt;\n    \"\"\"\n    stream_cls: type[Stream]\n    if (options.logical_type % 10) != jelly.LOGICAL_STREAM_TYPE_GRAPHS and isinstance(\n        sink, Dataset\n    ):\n        stream_cls = QuadStream\n    else:\n        stream_cls = TripleStream\n    return stream_cls.for_rdflib(options=options)\n</code></pre> <code>grouped_stream_to_frames(sink_generator, options=None)</code> <p>Transform Graphs/Datasets into Jelly frames, one frame per Graph/Dataset.</p> <p>Note: options are guessed if not provided.</p> <p>Args:     sink_generator (Generator[Graph] | Generator[Dataset]): Generator of         Graphs/Dataset to transform.     options (SerializerOptions | None, optional): stream options to use.         Options are guessed based on the sink store type. Defaults to None.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: produced Jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def grouped_stream_to_frames(\n    sink_generator: Generator[Graph] | Generator[Dataset],\n    options: SerializerOptions | None = None,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Transform Graphs/Datasets into Jelly frames, one frame per Graph/Dataset.\n\n    Note: options are guessed if not provided.\n\n    Args:\n        sink_generator (Generator[Graph] | Generator[Dataset]): Generator of\n            Graphs/Dataset to transform.\n        options (SerializerOptions | None, optional): stream options to use.\n            Options are guessed based on the sink store type. Defaults to None.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: produced Jelly frames\n\n    \"\"\"\n    stream = None\n    for sink in sink_generator:\n        if not stream:\n            if options is None:\n                options = guess_options(sink)\n            stream = guess_stream(options, sink)\n        yield from stream_frames(stream, sink)\n</code></pre> <code>grouped_stream_to_file(stream, output_file, **kwargs)</code> <p>Write stream of Graphs/Datasets to a binary file.</p> <p>Args:     stream (Generator[Graph] | Generator[Dataset]): Generator of         Graphs/Dataset to transform.     output_file (IO[bytes]): output buffered writer.     **kwargs (Any): options to pass to stream.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def grouped_stream_to_file(\n    stream: Generator[Graph] | Generator[Dataset],\n    output_file: IO[bytes],\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Write stream of Graphs/Datasets to a binary file.\n\n    Args:\n        stream (Generator[Graph] | Generator[Dataset]): Generator of\n            Graphs/Dataset to transform.\n        output_file (IO[bytes]): output buffered writer.\n        **kwargs (Any): options to pass to stream.\n\n    \"\"\"\n    for frame in grouped_stream_to_frames(stream, **kwargs):\n        write_delimited(frame, output_file)\n</code></pre> <code>flat_stream_to_frames(statements, options=None)</code> <p>Serialize a stream of raw triples or quads into Jelly frames.</p> <p>Args:     statements (Generator[Triple | Quad]):       s/p/o triples or s/p/o/g quads to serialize.     options (SerializerOptions | None, optional):         if omitted, guessed based on the first tuple.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: generated frames.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def flat_stream_to_frames(\n    statements: Generator[Triple | Quad],\n    options: SerializerOptions | None = None,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a stream of raw triples or quads into Jelly frames.\n\n    Args:\n        statements (Generator[Triple | Quad]):\n          s/p/o triples or s/p/o/g quads to serialize.\n        options (SerializerOptions | None, optional):\n            if omitted, guessed based on the first tuple.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: generated frames.\n\n    \"\"\"\n    first = next(statements, None)\n    if first is None:\n        return\n\n    sink = Dataset() if len(first) == QUAD_ARITY else Graph()\n    if options is None:\n        options = guess_options(sink)\n    stream = guess_stream(options, sink)\n\n    combined: Generator[Triple | Quad] | Graph = (\n        item for item in chain([first], statements)\n    )\n\n    yield from stream_frames(stream, combined)\n</code></pre> <code>flat_stream_to_file(statements, output_file, options=None)</code> <p>Write Triple or Quad events to a binary file in Jelly flat format.</p> <p>Args:     statements (Generator[Triple | Quad]): statements to serialize.     output_file (IO[bytes]): output buffered writer.     options (SerializerOptions | None, optional): stream options.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def flat_stream_to_file(\n    statements: Generator[Triple | Quad],\n    output_file: IO[bytes],\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    \"\"\"\n    Write Triple or Quad events to a binary file in Jelly flat format.\n\n    Args:\n        statements (Generator[Triple | Quad]): statements to serialize.\n        output_file (IO[bytes]): output buffered writer.\n        options (SerializerOptions | None, optional): stream options.\n\n    \"\"\"\n    for frame in flat_stream_to_frames(statements, options):\n        write_delimited(frame, output_file)\n</code></pre>"},{"location":"api/#pyjelly.jelly","title":"<code>jelly</code>","text":"<p>Modules:</p> Name Description <code>rdf_pb2</code> <p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.jelly.rdf_pb2","title":"<code>rdf_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.options","title":"<code>options</code>","text":"<p>Classes:</p> Name Description <code>StreamTypes</code> <p>Functions:</p> Name Description <code>register_mimetypes</code> <p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>Attributes:</p> Name Type Description <code>INTEGRATION_SIDE_EFFECTS</code> <code>bool</code> <p>Whether to allow integration module imports to trigger side effects.</p>"},{"location":"api/#pyjelly.options.INTEGRATION_SIDE_EFFECTS","title":"<code>INTEGRATION_SIDE_EFFECTS = True</code>","text":"<p>Whether to allow integration module imports to trigger side effects.</p> <p>These side effects are cheap and may include populating some registries for guessing the defaults for external integrations that work with Jelly.</p>"},{"location":"api/#pyjelly.options.StreamTypes","title":"<code>StreamTypes(physical_type=jelly.PHYSICAL_STREAM_TYPE_UNSPECIFIED, logical_type=jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED)</code>","text":"<p>Methods:</p> Name Description <code>__repr__</code> <p>Return the representation of StreamTypes.</p>"},{"location":"api/#pyjelly.options.StreamTypes.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the representation of StreamTypes.</p> <p>repr(StreamTypes(9999, 8888)) 'StreamTypes(9999, 8888)'</p> Source code in <code>pyjelly/options.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return the representation of StreamTypes.\n\n    &gt;&gt;&gt; repr(StreamTypes(9999, 8888))\n    'StreamTypes(9999, 8888)'\n    \"\"\"\n    with suppress(ValueError):\n        physical_type_name = jelly.PhysicalStreamType.Name(self.physical_type)\n        logical_type_name = jelly.LogicalStreamType.Name(self.logical_type)\n        return f\"StreamTypes({physical_type_name}, {logical_type_name})\"\n    return f\"StreamTypes({self.physical_type}, {self.logical_type})\"\n</code></pre>"},{"location":"api/#pyjelly.options.register_mimetypes","title":"<code>register_mimetypes(extension='.jelly')</code>","text":"<p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>register_mimetypes() mimetypes.guess_type(\"out.jelly\") ('application/x-jelly-rdf', None)</p> Source code in <code>pyjelly/options.py</code> <pre><code>def register_mimetypes(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Associate files that have Jelly extension with Jelly MIME types.\n\n    &gt;&gt;&gt; register_mimetypes()\n    &gt;&gt;&gt; mimetypes.guess_type(\"out.jelly\")\n    ('application/x-jelly-rdf', None)\n    \"\"\"\n    for mimetype in MIMETYPES:\n        mimetypes.add_type(mimetype, extension)\n</code></pre>"},{"location":"api/#pyjelly.parse","title":"<code>parse</code>","text":"<p>Modules:</p> Name Description <code>decode</code> <code>ioutils</code> <code>lookup</code>"},{"location":"api/#pyjelly.parse.decode","title":"<code>decode</code>","text":"<p>Modules:</p> Name Description <code>jelly</code> <p>Generated protocol buffer code.</p> <p>Classes:</p> Name Description <code>Adapter</code> <code>Decoder</code> <code>LookupDecoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p> <code>ParserOptions</code> <p>mypyc filler docstring</p> <code>ParsingMode</code> <p>mypyc filler docstring</p> <code>StreamTypes</code> <p>Attributes:</p> Name Type Description <code>MAX_VERSION</code> <p>int([x]) -&gt; integer</p> <code>__file__</code> <p>str(object='') -&gt; str</p> <code>__name__</code> <p>str(object='') -&gt; str</p> <code>__package__</code> <p>str(object='') -&gt; str</p>"},{"location":"api/#pyjelly.parse.decode.MAX_VERSION","title":"<code>MAX_VERSION = 2</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"api/#pyjelly.parse.decode.__file__","title":"<code>__file__ = '/home/runner/work/pyjelly/pyjelly/pyjelly/parse/decode.cpython-310-x86_64-linux-gnu.so'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.parse.decode.__name__","title":"<code>__name__ = 'pyjelly.parse.decode'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.parse.decode.__package__","title":"<code>__package__ = 'pyjelly.parse'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.parse.decode.Adapter","title":"<code>Adapter(*args, **kwargs)</code>","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <p>Attributes:</p> Name Type Description <code>__module__</code> <p>str(object='') -&gt; str</p> <code>__mypyc_attrs__</code> <p>Built-in immutable sequence.</p> <code>__module__ = 'pyjelly.parse.decode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__mypyc_attrs__ = ('options', 'parsing_mode')</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>__new__(*args, **kwargs)</code> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"api/#pyjelly.parse.decode.Decoder","title":"<code>Decoder(*args, **kwargs)</code>","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <p>Attributes:</p> Name Type Description <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>__mypyc_attrs__</code> <p>Built-in immutable sequence.</p> <code>__doc__ = ''</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.parse.decode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__mypyc_attrs__ = ('adapter', 'names', 'prefixes', 'datatypes', 'repeated_terms', 'row_handlers', 'term_handlers')</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>__new__(*args, **kwargs)</code> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"api/#pyjelly.parse.decode.LookupDecoder","title":"<code>LookupDecoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required Source code in <code>pyjelly/parse/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    if lookup_size &gt; MAX_LOOKUP_SIZE:\n        msg = f\"lookup size cannot be larger than {MAX_LOOKUP_SIZE}\"\n        raise JellyAssertionError(msg)\n    self.lookup_size = lookup_size\n    placeholders = (None,) * lookup_size\n    self.data: deque[str | None] = deque(placeholders, maxlen=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre>"},{"location":"api/#pyjelly.parse.decode.ParserOptions","title":"<code>ParserOptions</code>","text":"<p>               Bases: <code>builtins.tuple</code></p> <p>mypyc filler docstring</p> <p>Attributes:</p> Name Type Description <code>__annotations__</code> <p>dict() -&gt; new empty dictionary</p> <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__match_args__</code> <p>Built-in immutable sequence.</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>__slots__</code> <p>Built-in immutable sequence.</p> <code>lookup_preset</code> <p>Alias for field number 1</p> <code>params</code> <p>Alias for field number 2</p> <code>stream_types</code> <p>Alias for field number 0</p> <code>__annotations__ = {'stream_types': &lt;class 'pyjelly.options.StreamTypes'&gt;, 'lookup_preset': &lt;class 'pyjelly.options.LookupPreset'&gt;, 'params': &lt;class 'pyjelly.options.StreamParameters'&gt;}</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>__doc__ = 'mypyc filler docstring'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__match_args__ = ('stream_types', 'lookup_preset', 'params')</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>__module__ = 'pyjelly.parse.decode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__slots__ = ()</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>lookup_preset = _tuplegetter(1, 'Alias for field number 1')</code> <p>Alias for field number 1</p> <code>params = _tuplegetter(2, 'Alias for field number 2')</code> <p>Alias for field number 2</p> <code>stream_types = _tuplegetter(0, 'Alias for field number 0')</code> <p>Alias for field number 0</p>"},{"location":"api/#pyjelly.parse.decode.ParsingMode","title":"<code>ParsingMode</code>","text":"<p>               Bases: <code>enum.Enum</code></p> <p>mypyc filler docstring</p> <p>Attributes:</p> Name Type Description <code>FLAT</code> <p>mypyc filler docstring</p> <code>GROUPED</code> <p>mypyc filler docstring</p> <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>FLAT = &lt;ParsingMode.FLAT: 1&gt;</code> <p>mypyc filler docstring</p> <code>GROUPED = &lt;ParsingMode.GROUPED: 2&gt;</code> <p>mypyc filler docstring</p> <code>__doc__ = 'mypyc filler docstring'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.parse.decode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.parse.decode.StreamTypes","title":"<code>StreamTypes(physical_type=jelly.PHYSICAL_STREAM_TYPE_UNSPECIFIED, logical_type=jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED)</code>","text":"<p>Methods:</p> Name Description <code>__repr__</code> <p>Return the representation of StreamTypes.</p> <code>__repr__()</code> <p>Return the representation of StreamTypes.</p> <p>repr(StreamTypes(9999, 8888)) 'StreamTypes(9999, 8888)'</p> Source code in <code>pyjelly/options.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return the representation of StreamTypes.\n\n    &gt;&gt;&gt; repr(StreamTypes(9999, 8888))\n    'StreamTypes(9999, 8888)'\n    \"\"\"\n    with suppress(ValueError):\n        physical_type_name = jelly.PhysicalStreamType.Name(self.physical_type)\n        logical_type_name = jelly.LogicalStreamType.Name(self.logical_type)\n        return f\"StreamTypes({physical_type_name}, {logical_type_name})\"\n    return f\"StreamTypes({self.physical_type}, {self.logical_type})\"\n</code></pre>"},{"location":"api/#pyjelly.parse.decode.jelly","title":"<code>jelly</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.parse.ioutils","title":"<code>ioutils</code>","text":"<p>Functions:</p> Name Description <code>delimited_jelly_hint</code> <p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <code>get_options_and_frames</code> <p>Return stream options and frames from the buffered binary stream.</p>"},{"location":"api/#pyjelly.parse.ioutils.delimited_jelly_hint","title":"<code>delimited_jelly_hint(header)</code>","text":"<p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <p>Truth table (notation: <code>0A</code> = <code>0x0A</code>, <code>NN</code> = <code>not 0x0A</code>, <code>??</code> = don't care):</p> Byte 1 Byte 2 Byte 3 Result <code>NN</code> <code>??</code> <code>??</code> Delimited <code>0A</code> <code>NN</code> <code>??</code> Non-delimited <code>0A</code> <code>0A</code> <code>NN</code> Delimited (size = 10) <code>0A</code> <code>0A</code> <code>0A</code> Non-delimited (stream options size = 10) <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x00])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A])) False</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def delimited_jelly_hint(header: bytes) -&gt; bool:\n    \"\"\"\n    Detect whether a Jelly file is delimited from its first 3 bytes.\n\n    Truth table (notation: `0A` = `0x0A`, `NN` = `not 0x0A`, `??` = _don't care_):\n\n    | Byte 1 | Byte 2 | Byte 3 | Result                                   |\n    |--------|--------|--------|------------------------------------------|\n    | `NN`   |  `??`  |  `??`  | Delimited                                |\n    | `0A`   |  `NN`  |  `??`  | Non-delimited                            |\n    | `0A`   |  `0A`  |  `NN`  | Delimited (size = 10)                    |\n    | `0A`   |  `0A`  |  `0A`  | Non-delimited (stream options size = 10) |\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x00]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A]))\n    False\n    \"\"\"\n    magic = 0x0A\n    return len(header) &gt;= 3 and (  # noqa: PLR2004\n        header[0] != magic or (header[1] == magic and header[2] != magic)\n    )\n</code></pre>"},{"location":"api/#pyjelly.parse.ioutils.get_options_and_frames","title":"<code>get_options_and_frames(inp)</code>","text":"<p>Return stream options and frames from the buffered binary stream.</p> <p>Args:     inp (IO[bytes]): jelly buffered binary stream</p> <p>Raises:     JellyConformanceError: if no non-empty frames detected in the delimited stream     JellyConformanceError: if non-delimited,         error is raised if no rows are detected (empty frame)</p> <p>Returns:     tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]: ParserOptions holds:         stream types, lookup presets and other stream options</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def get_options_and_frames(\n    inp: IO[bytes],\n) -&gt; tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]:\n    \"\"\"\n    Return stream options and frames from the buffered binary stream.\n\n    Args:\n        inp (IO[bytes]): jelly buffered binary stream\n\n    Raises:\n        JellyConformanceError: if no non-empty frames detected in the delimited stream\n        JellyConformanceError: if non-delimited,\n            error is raised if no rows are detected (empty frame)\n\n    Returns:\n        tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]: ParserOptions holds:\n            stream types, lookup presets and other stream options\n\n    \"\"\"\n    if not inp.seekable():\n        # Input may not be seekable (e.g. a network stream) -- then we need to buffer\n        # it to determine if it's delimited.\n        # See also: https://github.com/Jelly-RDF/pyjelly/issues/298\n        inp = io.BufferedReader(inp)  # type: ignore[arg-type, type-var, unused-ignore]\n        is_delimited = delimited_jelly_hint(inp.peek(3))\n    else:\n        is_delimited = delimited_jelly_hint(bytes_read := inp.read(3))\n        inp.seek(-len(bytes_read), os.SEEK_CUR)\n\n    if is_delimited:\n        first_frame = None\n        skipped_frames = []\n        frames = frame_iterator(inp)\n        for frame in frames:\n            if not frame.rows:\n                skipped_frames.append(frame)\n            else:\n                first_frame = frame\n                break\n        if first_frame is None:\n            msg = \"No non-empty frames found in the stream\"\n            raise JellyConformanceError(msg)\n\n        options = options_from_frame(first_frame, delimited=True)\n        return options, chain(skipped_frames, (first_frame,), frames)\n\n    frame = parse(jelly.RdfStreamFrame, inp.read())\n\n    if not frame.rows:\n        msg = \"The stream is corrupted (only contains an empty frame)\"\n        raise JellyConformanceError(msg)\n\n    options = options_from_frame(frame, delimited=False)\n    return options, iter((frame,))\n</code></pre>"},{"location":"api/#pyjelly.parse.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>LookupDecoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.parse.lookup.LookupDecoder","title":"<code>LookupDecoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required Source code in <code>pyjelly/parse/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    if lookup_size &gt; MAX_LOOKUP_SIZE:\n        msg = f\"lookup size cannot be larger than {MAX_LOOKUP_SIZE}\"\n        raise JellyAssertionError(msg)\n    self.lookup_size = lookup_size\n    placeholders = (None,) * lookup_size\n    self.data: deque[str | None] = deque(placeholders, maxlen=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre>"},{"location":"api/#pyjelly.serialize","title":"<code>serialize</code>","text":"<p>Modules:</p> Name Description <code>encode</code> <code>flows</code> <code>lookup</code> <code>streams</code>"},{"location":"api/#pyjelly.serialize.encode","title":"<code>encode</code>","text":"<p>Modules:</p> Name Description <code>jelly</code> <p>Generated protocol buffer code.</p> <code>options</code> <p>Classes:</p> Name Description <code>JellyConformanceError</code> <p>Raised when Jelly conformance is violated.</p> <code>LookupEncoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p> <code>Slot</code> <p>mypyc filler docstring</p> <code>TermEncoder</code> <p>Attributes:</p> Name Type Description <code>HasGraph</code> <p>Represent a PEP 604 union type</p> <code>Statement</code> <p>Represent a PEP 604 union type</p> <code>T</code> <p>Type variable.</p> <code>Terms</code> <p>Represent a PEP 604 union type</p> <code>__file__</code> <p>str(object='') -&gt; str</p> <code>__name__</code> <p>str(object='') -&gt; str</p> <code>__package__</code> <p>str(object='') -&gt; str</p>"},{"location":"api/#pyjelly.serialize.encode.HasGraph","title":"<code>HasGraph = rdf_pb2.RdfQuad | rdf_pb2.RdfGraphStart</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"api/#pyjelly.serialize.encode.Statement","title":"<code>Statement = rdf_pb2.RdfQuad | rdf_pb2.RdfTriple</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"api/#pyjelly.serialize.encode.T","title":"<code>T = ~T</code>","text":"<p>Type variable.</p> <p>Usage::</p> <p>T = TypeVar('T')  # Can be anything   A = TypeVar('A', str, bytes)  # Must be str or bytes</p> <p>Type variables exist primarily for the benefit of static type checkers.  They serve as the parameters for generic types as well as for generic function definitions.  See class Generic for more information on generic types.  Generic functions work as follows:</p> <p>def repeat(x: T, n: int) -&gt; List[T]:       '''Return a list containing n references to x.'''       return [x]*n</p> <p>def longest(x: A, y: A) -&gt; A:       '''Return the longest of two strings.'''       return x if len(x) &gt;= len(y) else y</p> <p>The latter example's signature is essentially the overloading of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note that if the arguments are instances of some subclass of str, the return type is still plain str.</p> <p>At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.</p> <p>Type variables defined with covariant=True or contravariant=True can be used to declare covariant or contravariant generic types. See PEP 484 for more details. By default generic types are invariant in all type variables.</p> <p>Type variables can be introspected. e.g.:</p> <p>T.name == 'T'   T.constraints == ()   T.covariant == False   T.contravariant = False   A.constraints == (str, bytes)</p> <p>Note that only type variables defined in global scope can be pickled.</p>"},{"location":"api/#pyjelly.serialize.encode.Terms","title":"<code>Terms = rdf_pb2.RdfIri | rdf_pb2.RdfLiteral | str | rdf_pb2.RdfDefaultGraph | rdf_pb2.RdfTriple</code>","text":"<p>Represent a PEP 604 union type</p> <p>E.g. for int | str</p>"},{"location":"api/#pyjelly.serialize.encode.__file__","title":"<code>__file__ = '/home/runner/work/pyjelly/pyjelly/pyjelly/serialize/encode.cpython-310-x86_64-linux-gnu.so'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.serialize.encode.__name__","title":"<code>__name__ = 'pyjelly.serialize.encode'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.serialize.encode.__package__","title":"<code>__package__ = 'pyjelly.serialize'</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"api/#pyjelly.serialize.encode.JellyConformanceError","title":"<code>JellyConformanceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when Jelly conformance is violated.</p>"},{"location":"api/#pyjelly.serialize.encode.LookupEncoder","title":"<code>LookupEncoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required <p>Methods:</p> Name Description <code>encode_entry_index</code> <p>Get or assign the index to use in an entry.</p> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    self.lookup = Lookup(max_size=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre> <code>encode_entry_index(key)</code> <p>Get or assign the index to use in an entry.</p> <p>Returns:</p> Type Description <code>int or None</code> <ul> <li>0 if the new index is sequential (<code>last_assigned_index + 1</code>)</li> <li>actual assigned/reused index otherwise</li> <li>None if the key already exists</li> </ul> <code>If the return value is None, the entry is already in the lookup and does not</code> <code>need to be emitted. Any integer value (including 0) means the entry is new</code> <code>and should be emitted.</code> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def encode_entry_index(self, key: str) -&gt; int | None:\n    \"\"\"\n    Get or assign the index to use in an entry.\n\n    Returns\n    -------\n    int or None\n        - 0 if the new index is sequential (`last_assigned_index + 1`)\n        - actual assigned/reused index otherwise\n        - None if the key already exists\n\n    If the return value is None, the entry is already in the lookup and does not\n    need to be emitted. Any integer value (including 0) means the entry is new\n    and should be emitted.\n\n    \"\"\"\n    try:\n        self.lookup.make_last_to_evict(key)\n        return None  # noqa: TRY300\n    except KeyError:\n        previous_index = self.last_assigned_index\n        index = self.lookup.insert(key)\n        self.last_assigned_index = index\n        if index == previous_index + 1:\n            return 0\n        return index\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.Slot","title":"<code>Slot</code>","text":"<p>               Bases: <code>enum.IntEnum</code></p> <p>mypyc filler docstring</p> <p>Attributes:</p> Name Type Description <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>graph</code> <p>mypyc filler docstring</p> <code>object</code> <p>mypyc filler docstring</p> <code>predicate</code> <p>mypyc filler docstring</p> <code>subject</code> <p>mypyc filler docstring</p> <code>__doc__ = 'mypyc filler docstring'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.serialize.encode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>graph = &lt;Slot.graph: 3&gt;</code> <p>mypyc filler docstring</p> <code>object = &lt;Slot.object: 2&gt;</code> <p>mypyc filler docstring</p> <code>predicate = &lt;Slot.predicate: 1&gt;</code> <p>mypyc filler docstring</p> <code>subject = &lt;Slot.subject: 0&gt;</code> <p>mypyc filler docstring</p>"},{"location":"api/#pyjelly.serialize.encode.TermEncoder","title":"<code>TermEncoder(*args, **kwargs)</code>","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>Create and return a new object.  See help(type) for accurate signature.</p> <p>Attributes:</p> Name Type Description <code>__doc__</code> <p>str(object='') -&gt; str</p> <code>__module__</code> <p>str(object='') -&gt; str</p> <code>__mypyc_attrs__</code> <p>Built-in immutable sequence.</p> <code>__doc__ = ''</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__module__ = 'pyjelly.serialize.encode'</code> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p> <code>__mypyc_attrs__ = ('lookup_preset', 'names', 'prefixes', 'datatypes')</code> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p> <code>__new__(*args, **kwargs)</code> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"api/#pyjelly.serialize.encode.jelly","title":"<code>jelly</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.serialize.encode.options","title":"<code>options</code>","text":"<p>Classes:</p> Name Description <code>StreamTypes</code> <p>Functions:</p> Name Description <code>register_mimetypes</code> <p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>Attributes:</p> Name Type Description <code>INTEGRATION_SIDE_EFFECTS</code> <code>bool</code> <p>Whether to allow integration module imports to trigger side effects.</p> <code>INTEGRATION_SIDE_EFFECTS = True</code> <p>Whether to allow integration module imports to trigger side effects.</p> <p>These side effects are cheap and may include populating some registries for guessing the defaults for external integrations that work with Jelly.</p> <code>StreamTypes(physical_type=jelly.PHYSICAL_STREAM_TYPE_UNSPECIFIED, logical_type=jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED)</code> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return the representation of StreamTypes.</p> <code>__repr__()</code> <p>Return the representation of StreamTypes.</p> <p>repr(StreamTypes(9999, 8888)) 'StreamTypes(9999, 8888)'</p> Source code in <code>pyjelly/options.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return the representation of StreamTypes.\n\n    &gt;&gt;&gt; repr(StreamTypes(9999, 8888))\n    'StreamTypes(9999, 8888)'\n    \"\"\"\n    with suppress(ValueError):\n        physical_type_name = jelly.PhysicalStreamType.Name(self.physical_type)\n        logical_type_name = jelly.LogicalStreamType.Name(self.logical_type)\n        return f\"StreamTypes({physical_type_name}, {logical_type_name})\"\n    return f\"StreamTypes({self.physical_type}, {self.logical_type})\"\n</code></pre> <code>register_mimetypes(extension='.jelly')</code> <p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>register_mimetypes() mimetypes.guess_type(\"out.jelly\") ('application/x-jelly-rdf', None)</p> Source code in <code>pyjelly/options.py</code> <pre><code>def register_mimetypes(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Associate files that have Jelly extension with Jelly MIME types.\n\n    &gt;&gt;&gt; register_mimetypes()\n    &gt;&gt;&gt; mimetypes.guess_type(\"out.jelly\")\n    ('application/x-jelly-rdf', None)\n    \"\"\"\n    for mimetype in MIMETYPES:\n        mimetypes.add_type(mimetype, extension)\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows","title":"<code>flows</code>","text":"<p>Classes:</p> Name Description <code>FrameFlow</code> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <code>ManualFrameFlow</code> <p>Produces frames only when manually requested (never automatically).</p> <code>BoundedFrameFlow</code> <p>Produce frames automatically when a fixed number of rows is reached.</p> <code>GraphsFrameFlow</code> <code>DatasetsFrameFlow</code> <p>Functions:</p> Name Description <code>flow_for_type</code> <p>Return flow based on logical type requested.</p>"},{"location":"api/#pyjelly.serialize.flows.FrameFlow","title":"<code>FrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>UserList[RdfStreamRow]</code></p> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <p>Collects stream rows and assembles them into RdfStreamFrame objects when ready.</p> <p>Allows for passing LogicalStreamType, required for     logical subtypes and non-delimited streams.</p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Treat the current rows as a graph and produce a frame.</p> <code>frame_from_dataset</code> <p>Treat the current rows as a dataset and produce a frame.</p> <code>to_stream_frame</code> <p>Create stream frame from flow content.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre> <code>frame_from_graph()</code> <p>Treat the current rows as a graph and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a graph and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>frame_from_dataset()</code> <p>Treat the current rows as a dataset and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a dataset and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>to_stream_frame()</code> <p>Create stream frame from flow content.</p> <p>Notes:     Clears flow content after creating the frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def to_stream_frame(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Create stream frame from flow content.\n\n    Notes:\n        Clears flow content after creating the frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame\n\n    \"\"\"\n    if not self:\n        return None\n    frame = jelly.RdfStreamFrame(rows=self)\n    self.clear()\n    return frame\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.ManualFrameFlow","title":"<code>ManualFrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produces frames only when manually requested (never automatically).</p> <p>Warning</p> <p>All stream rows are kept in memory until <code>to_stream_frame()</code> is called. This may lead to high memory usage for large streams.</p> <p>Used for non-delimited serialization.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.BoundedFrameFlow","title":"<code>BoundedFrameFlow(initlist=None, logical_type=None, *, frame_size=None)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produce frames automatically when a fixed number of rows is reached.</p> <p>Used for delimited encoding (default mode).</p> <p>Methods:</p> Name Description <code>frame_from_bounds</code> <p>Emit frame from flow if full.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>@override\ndef __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    logical_type: jelly.LogicalStreamType | None = None,\n    *,\n    frame_size: int | None = None,\n) -&gt; None:\n    super().__init__(initlist, logical_type=logical_type)\n    self.frame_size = frame_size or DEFAULT_FRAME_SIZE\n</code></pre> <code>frame_from_bounds()</code> <p>Emit frame from flow if full.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>@override\ndef frame_from_bounds(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit frame from flow if full.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame\n\n    \"\"\"\n    if len(self) &gt;= self.frame_size:\n        return self.to_stream_frame()\n    return None\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.GraphsFrameFlow","title":"<code>GraphsFrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Emit current flow content (one graph) as jelly frame.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre> <code>frame_from_graph()</code> <p>Emit current flow content (one graph) as jelly frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: jelly frame or none if         flow is empty.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit current flow content (one graph) as jelly frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: jelly frame or none if\n            flow is empty.\n\n    \"\"\"\n    return self.to_stream_frame()\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.DatasetsFrameFlow","title":"<code>DatasetsFrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Methods:</p> Name Description <code>frame_from_dataset</code> <p>Emit current flow content (dataset) as jelly frame.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre> <code>frame_from_dataset()</code> <p>Emit current flow content (dataset) as jelly frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: jelly frame or none if         flow is empty.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit current flow content (dataset) as jelly frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: jelly frame or none if\n            flow is empty.\n\n    \"\"\"\n    return self.to_stream_frame()\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.flow_for_type","title":"<code>flow_for_type(logical_type)</code>","text":"<p>Return flow based on logical type requested.</p> <p>Note: uses base logical type for subtypes (i.e., SUBJECT_GRAPHS uses     the same flow as its base type GRAPHS).</p> <p>Args:     logical_type (jelly.LogicalStreamType): logical type requested.</p> <p>Raises:     NotImplementedError: if (base) logical stream type is not supported.</p> <p>Returns:     type[FrameFlow]: FrameFlow for respective logical type.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def flow_for_type(logical_type: jelly.LogicalStreamType) -&gt; type[FrameFlow]:\n    \"\"\"\n    Return flow based on logical type requested.\n\n    Note: uses base logical type for subtypes (i.e., SUBJECT_GRAPHS uses\n        the same flow as its base type GRAPHS).\n\n    Args:\n        logical_type (jelly.LogicalStreamType): logical type requested.\n\n    Raises:\n        NotImplementedError: if (base) logical stream type is not supported.\n\n    Returns:\n        type[FrameFlow]: FrameFlow for respective logical type.\n\n    \"\"\"\n    try:\n        base_logical_type_value = logical_type % 10\n        base_name = jelly.LogicalStreamType.Name(base_logical_type_value)\n        return FLOW_DISPATCH[getattr(jelly.LogicalStreamType, base_name)]\n    except KeyError:\n        msg = (\n            \"unsupported logical stream type: \"\n            f\"{jelly.LogicalStreamType.Name(logical_type)}\"\n        )\n        raise NotImplementedError(msg) from None\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>Lookup</code> <p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <code>LookupEncoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.serialize.lookup.Lookup","title":"<code>Lookup(max_size)</code>","text":"<p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <ul> <li>Assigns incrementing indices starting from 1.</li> <li>After reaching the maximum size, reuses the existing indices from evicting   the least-recently-used entries.</li> <li>Index 0 is reserved for delta encoding in Jelly streams.</li> </ul> <p>To check if a key exists, use <code>.move(key)</code> and catch <code>KeyError</code>. If <code>KeyError</code> is raised, the key can be inserted with <code>.insert(key)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of entries. Zero disables lookup.</p> required Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, max_size: int) -&gt; None:\n    self.data = OrderedDict[str, int]()\n    self.max_size = max_size\n    self._evicting = False\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup.LookupEncoder","title":"<code>LookupEncoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required <p>Methods:</p> Name Description <code>encode_entry_index</code> <p>Get or assign the index to use in an entry.</p> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    self.lookup = Lookup(max_size=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre> <code>encode_entry_index(key)</code> <p>Get or assign the index to use in an entry.</p> <p>Returns:</p> Type Description <code>int or None</code> <ul> <li>0 if the new index is sequential (<code>last_assigned_index + 1</code>)</li> <li>actual assigned/reused index otherwise</li> <li>None if the key already exists</li> </ul> <code>If the return value is None, the entry is already in the lookup and does not</code> <code>need to be emitted. Any integer value (including 0) means the entry is new</code> <code>and should be emitted.</code> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def encode_entry_index(self, key: str) -&gt; int | None:\n    \"\"\"\n    Get or assign the index to use in an entry.\n\n    Returns\n    -------\n    int or None\n        - 0 if the new index is sequential (`last_assigned_index + 1`)\n        - actual assigned/reused index otherwise\n        - None if the key already exists\n\n    If the return value is None, the entry is already in the lookup and does not\n    need to be emitted. Any integer value (including 0) means the entry is new\n    and should be emitted.\n\n    \"\"\"\n    try:\n        self.lookup.make_last_to_evict(key)\n        return None  # noqa: TRY300\n    except KeyError:\n        previous_index = self.last_assigned_index\n        index = self.lookup.insert(key)\n        self.last_assigned_index = index\n        if index == previous_index + 1:\n            return 0\n        return index\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams","title":"<code>streams</code>","text":"<p>Classes:</p> Name Description <code>Stream</code> <code>TripleStream</code> <code>QuadStream</code> <code>GraphStream</code> <p>Functions:</p> Name Description <code>stream_for_type</code> <p>Give a Stream based on physical type specified.</p>"},{"location":"api/#pyjelly.serialize.streams.Stream","title":"<code>Stream(*, encoder, options=None)</code>","text":"<p>Methods:</p> Name Description <code>infer_flow</code> <p>Return flow based on the stream options provided.</p> <code>enroll</code> <p>Initialize start of the stream.</p> <code>stream_options</code> <p>Encode and append stream options row to the current flow.</p> <code>namespace_declaration</code> <p>Add namespace declaration to jelly stream.</p> <code>for_rdflib</code> <p>Initialize stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>infer_flow()</code> <p>Return flow based on the stream options provided.</p> <p>Returns:     FrameFlow: initialised FrameFlow object.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def infer_flow(self) -&gt; FrameFlow:\n    \"\"\"\n    Return flow based on the stream options provided.\n\n    Returns:\n        FrameFlow: initialised FrameFlow object.\n\n    \"\"\"\n    flow: FrameFlow\n    if self.options.params.delimited:\n        if self.options.logical_type != jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED:\n            flow_class = flow_for_type(self.options.logical_type)\n        else:\n            flow_class = self.default_delimited_flow_class\n\n        if self.options.logical_type in (\n            jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES,\n            jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS,\n        ):\n            flow = flow_class(\n                logical_type=self.options.logical_type,\n                frame_size=self.options.frame_size,\n            )\n        else:\n            flow = flow_class(logical_type=self.options.logical_type)\n    else:\n        flow = ManualFrameFlow(logical_type=self.options.logical_type)\n    return flow\n</code></pre> <code>enroll()</code> <p>Initialize start of the stream.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def enroll(self) -&gt; None:\n    \"\"\"Initialize start of the stream.\"\"\"\n    if not self.enrolled:\n        self.stream_options()\n        self.enrolled = True\n</code></pre> <code>stream_options()</code> <p>Encode and append stream options row to the current flow.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_options(self) -&gt; None:\n    \"\"\"Encode and append stream options row to the current flow.\"\"\"\n    self.flow.append(\n        encode_options(\n            stream_types=self.stream_types,\n            params=self.options.params,\n            lookup_preset=self.options.lookup_preset,\n        )\n    )\n</code></pre> <code>namespace_declaration(name, iri)</code> <p>Add namespace declaration to jelly stream.</p> <p>Args:     name (str): namespace prefix label     iri (str): namespace iri</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def namespace_declaration(self, name: str, iri: str) -&gt; None:\n    \"\"\"\n    Add namespace declaration to jelly stream.\n\n    Args:\n        name (str): namespace prefix label\n        iri (str): namespace iri\n\n    \"\"\"\n    rows = encode_namespace_declaration(\n        name=name,\n        value=iri,\n        term_encoder=self.encoder,\n    )\n    self.flow.extend(rows)\n</code></pre> <code>for_rdflib(options=None)</code> <p>Initialize stream with RDFLib encoder.</p> <p>Args:     options (SerializerOptions | None, optional): Stream options.         Defaults to None.</p> <p>Raises:     TypeError: if Stream is passed, and not a Stream for specific physical type.</p> <p>Returns:     Stream: initialized stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>@classmethod\ndef for_rdflib(cls, options: SerializerOptions | None = None) -&gt; Stream:\n    \"\"\"\n    Initialize stream with RDFLib encoder.\n\n    Args:\n        options (SerializerOptions | None, optional): Stream options.\n            Defaults to None.\n\n    Raises:\n        TypeError: if Stream is passed, and not a Stream for specific physical type.\n\n    Returns:\n        Stream: initialized stream with RDFLib encoder.\n\n    \"\"\"\n    if cls is Stream:\n        msg = \"Stream is an abstract base class, use a subclass instead\"\n        raise TypeError(msg)\n    from pyjelly.integrations.rdflib.serialize import RDFLibTermEncoder\n\n    lookup_preset: LookupPreset | None = None\n    if options is not None:\n        lookup_preset = options.lookup_preset\n    return cls(\n        encoder=RDFLibTermEncoder(lookup_preset=lookup_preset),\n        options=options,\n    )\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.TripleStream","title":"<code>TripleStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>triple</code> <p>Process one triple to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>triple(terms)</code> <p>Process one triple to Protobuf messages.</p> <p>Note:     Adds new rows to the current flow and returns StreamFrame if     frame size conditions are met.</p> <p>Args:     terms (Iterable[object]): RDF terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def triple(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one triple to Protobuf messages.\n\n    Note:\n        Adds new rows to the current flow and returns StreamFrame if\n        frame size conditions are met.\n\n    Args:\n        terms (Iterable[object]): RDF terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_triple(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.QuadStream","title":"<code>QuadStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>quad</code> <p>Process one quad to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>quad(terms)</code> <p>Process one quad to Protobuf messages.</p> <p>Args:     terms (Iterable[object]): terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def quad(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one quad to Protobuf messages.\n\n    Args:\n        terms (Iterable[object]): terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_quad(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.GraphStream","title":"<code>GraphStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>TripleStream</code></p> <p>Methods:</p> Name Description <code>graph</code> <p>Process one graph into a sequence of jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>graph(graph_id, graph)</code> <p>Process one graph into a sequence of jelly frames.</p> <p>Args:     graph_id (object): graph id (BN, Literal, iri, default)     graph (Iterable[Iterable[object]]): iterable of triples (graph's content)</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def graph(\n    self,\n    graph_id: object,\n    graph: Iterable[Iterable[object]],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Process one graph into a sequence of jelly frames.\n\n    Args:\n        graph_id (object): graph id (BN, Literal, iri, default)\n        graph (Iterable[Iterable[object]]): iterable of triples (graph's content)\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    graph_start = jelly.RdfGraphStart()\n    [*graph_rows] = self.encoder.encode_graph(graph_id, graph_start)\n    start_row = jelly.RdfStreamRow(graph_start=graph_start)\n    graph_rows.append(start_row)\n    self.flow.extend(graph_rows)\n    for triple in graph:\n        if frame := self.triple(triple):  # has frame slicing inside\n            yield frame\n    end_row = jelly.RdfStreamRow(graph_end=jelly.RdfGraphEnd())\n    self.flow.append(end_row)\n    if frame := self.flow.frame_from_bounds():\n        yield frame\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.stream_for_type","title":"<code>stream_for_type(physical_type)</code>","text":"<p>Give a Stream based on physical type specified.</p> <p>Args:     physical_type (jelly.PhysicalStreamType): jelly stream physical type.</p> <p>Raises:     NotImplementedError: if no stream for requested physical type is available.</p> <p>Returns:     type[Stream]: jelly stream</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_for_type(physical_type: jelly.PhysicalStreamType) -&gt; type[Stream]:\n    \"\"\"\n    Give a Stream based on physical type specified.\n\n    Args:\n        physical_type (jelly.PhysicalStreamType): jelly stream physical type.\n\n    Raises:\n        NotImplementedError: if no stream for requested physical type is available.\n\n    Returns:\n        type[Stream]: jelly stream\n\n    \"\"\"\n    try:\n        stream_cls = STREAM_DISPATCH[physical_type]\n    except KeyError:\n        msg = (\n            \"no stream class for physical type \"\n            f\"{jelly.PhysicalStreamType.Name(physical_type)}\"\n        )\n        raise NotImplementedError(msg) from None\n    return stream_cls\n</code></pre>"},{"location":"generic-sink/","title":"Generic API","text":"<p>This guide explains how to use pyjelly\u2019s generic API to write and read RDF statements into the\u00a0Jelly\u00a0format without any external library.</p>"},{"location":"generic-sink/#installation","title":"Installation","text":"<p>Install pyjelly from PyPI:</p> <pre><code>pip install pyjelly\n</code></pre>"},{"location":"generic-sink/#requirements","title":"Requirements","text":"<ul> <li>Python\u00a03.10 or newer  </li> <li>Linux, macOS, or Windows</li> </ul>"},{"location":"generic-sink/#usage-without-external-libraries","title":"Usage without external libraries","text":"<p>Unlike the example in getting started, the Generic API does not use the RDFLib or any other third-party libraries, but it works in much the same way.</p>"},{"location":"generic-sink/#serializing-statements-to-a-jelly-file","title":"Serializing statements to a Jelly file","text":"<p>To make a set of triples/quads and write them to a Jelly file, use:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\n\n# Create a generic sink object\ngeneric_sink = GenericStatementSink()\n\n# Let's add triples one by one\ngeneric_sink.add(\n    Triple(\n        IRI(\"http://example.com/subject\"),\n        IRI(\"http://example.com/predicate\"),\n        Literal(\"Hello\", langtag=\"en\"),\n    )\n)\ngeneric_sink.add(\n    Triple(\n        BlankNode(\"B1\"),\n        IRI(\"http://example.com/hasName\"),\n        Literal(\"Bob\"),\n    )\n)\n\n# Write into a Jelly file\nwith open(\"output.jelly\", \"wb\") as out_file:\n    generic_sink.serialize(out_file)\n\nprint(\"All done.\")\n</code></pre> <p>This example uses pyjelly\u2019s simple custom triple/quad type, which is easy to create and work with.</p>"},{"location":"generic-sink/#parsing-statements-from-a-jelly-file","title":"Parsing statements from a Jelly file","text":"<p>To load triples/quads into your python object from a <code>.jelly</code> file, see:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\n\n# Create a generic sink object\ngeneric_sink = GenericStatementSink()\n\n# Load triples from the Jelly file\nwith open(\"output.jelly\", \"rb\") as in_file:\n    generic_sink.parse(in_file)\n\n# Let's inspect them statement by statement\nfor statement in generic_sink:\n    if isinstance(statement, Triple):\n        print(statement)\n\nprint(\"All done.\")\n</code></pre> <p>Which retrieves data from your <code>.jelly</code> file.</p>"},{"location":"generic-sink/#parsing-a-stream-of-graphs","title":"Parsing a stream of graphs","text":"<p>Similarly, to process a Jelly stream as a stream of graphs through generic API, see:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.generic.parse import parse_jelly_grouped\n\n# Dataset: Katrina weather measurements (10k graphs)\n# Documentation: https://w3id.org/riverbench/datasets/lod-katrina/dev\nurl = \"https://w3id.org/riverbench/datasets/lod-katrina/dev/files/jelly_10K.jelly.gz\"\n\n# Load, uncompress .gz file, and pass to Jelly parser, all in a streaming manner\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    # Parse into sinks (one per graph)\n    graphs = parse_jelly_grouped(jelly_stream)\n\n    # First 50\n    for i, graph in enumerate(graphs):\n        print(f\"Graph {i} in the stream has {len(graph)} triples\")\n        if i &gt;= 50:\n            break\n</code></pre> <p>Where we use a dataset of weather measurements and count the number of triples in each graph.</p>"},{"location":"generic-sink/#parsing-a-stream-of-statements","title":"Parsing a stream of statements","text":"<p>You can also process a Jelly stream as a flat stream with only generic API:</p> <p>We look through a fragment of Denmark's OpenStreetMap to find all city names:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.generic.generic_sink import *\nfrom pyjelly.integrations.generic.parse import parse_jelly_flat\n\n# Dataset: OpenStreetMap data for Denmark (first 10k objects)\n# Documentation: https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev\nurl = (\n    \"https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev/files/jelly_10K.jelly.gz\"\n)\n\n# We are looking for city names in the dataset\npredicate_to_look_for = IRI(\"https://www.openstreetmap.org/wiki/Key:addr:city\")\ncity_names = set()\n\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    for event in parse_jelly_flat(jelly_stream):\n        if isinstance(event, Triple):\n            if str(event.p) == str(predicate_to_look_for):\n                city_names.add(str(event.o))\n\nprint(f\"Found {len(city_names)} unique city names in the dataset.\")\nprint(\"Sample city names:\")\nfor city in list(city_names)[:10]:\n    print(f\"- {city}\")\n</code></pre> <p>We get a generator of stream events, which allows us to process the file statement-by-statement, however with no external libraries used.</p>"},{"location":"generic-sink/#streaming-data","title":"Streaming data","text":"<p>If you need to process a certain quantity of statements both efficiently and iteratively, you can provide a simple generator:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\n\n\n# Helper generator that streams statements from a Jelly file path\ndef stream_triples(jelly_path):\n    generic_sink = GenericStatementSink()\n    with open(jelly_path, \"rb\") as f:\n        generic_sink.parse(f)\n    yield from (stmt for stmt in generic_sink)\n\n\n# Example usage, just printing:\nfor triple in stream_triples(\"output.jelly\"):\n    print(triple)\n\nprint(\"All done.\")\n</code></pre> <p>With this method you avoid storing all statements in memory, which greatly improves performance.</p>"},{"location":"generic-sink/#serializing-a-stream-of-graphs","title":"Serializing a stream of graphs","text":"<p>If you have a generator object containing graphs, you can use a generic approach for serialization:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\nfrom pyjelly.integrations.generic.serialize import grouped_stream_to_file\nimport random\n\n\n# Helper function to generate a generator of graphs\ndef generate_sample_sinks():\n    content = (\n        IRI(\"http://example.com/sensor\"),\n        IRI(\"http://example.com/humidity\"),\n        IRI(f\"http://example.com/{random.random()}\"),\n    )\n    for _ in range(10):\n        sink = GenericStatementSink()\n        sink.add(Triple(*content))\n        yield sink\n\n\noutput_file = \"output.jelly\"\nprint(f\"Streaming graphs into {output_file}\u2026\")\nwith open(output_file, \"wb\") as out_f:\n    grouped_stream_to_file(generate_sample_sinks(), out_f)\nprint(\"All done.\")\n</code></pre> <p>Grouped data is streamed in its original form, no need for additional RDF libraries like RDFLib. </p>"},{"location":"generic-sink/#serializing-a-stream-of-statements","title":"Serializing a stream of statements","text":"<p>Serializing a generator object of statements to <code>.jelly</code> file through generic API:</p> <pre><code>from pyjelly.integrations.generic.serialize import flat_stream_to_file\nfrom pyjelly.integrations.generic.generic_sink import *\nimport random\n\n\n# Example generator that yields raw triples\ndef generate_sample_triples():\n    content = (\n        IRI(\"http://example.com/sensor\"),\n        IRI(\"http://example.com/humidity\"),\n        IRI(f\"http://example.com/{random.random()}\"),\n    )\n    for _ in range(10):\n        yield Triple(*content)\n\n\noutput_file = \"flat_output.jelly\"\nprint(f\"Streaming triples into {output_file}\u2026\")\nsample_triples = generate_sample_triples()\nwith open(output_file, \"wb\") as out_f:\n    flat_stream_to_file(sample_triples, out_f)\nprint(\"All done.\")\n</code></pre> <p>Data is transmitted and kept ordered and simple.</p>"},{"location":"generic-sink/#working-with-byte-buffers-and-kafka","title":"Working with byte buffers and Kafka","text":"<p>When working with Kafka or other message brokers, you may want to write Jelly data to a byte buffer instead of a file. You can do this by using the <code>BytesIO</code> class from the <code>io</code> module:</p> <pre><code>import io\n\nfrom pyjelly.integrations.generic.generic_sink import *\n\ng1 = GenericStatementSink()\n\ng1.add(\n    Triple(\n        IRI(\"http://example.com/subject\"),\n        IRI(\"http://example.com/predicate\"),\n        Literal(\"Hello\", langtag=\"en\"),\n    )\n)\n\n# Write the data into a byte buffer (bytes type)\nwith io.BytesIO() as write_buffer:\n    g1.serialize(write_buffer)\n    data = write_buffer.getvalue()\n\nprint(f\"Serialized data size: {len(data)} bytes\")\n\n# Parse the data back\ng2 = GenericStatementSink()\nwith io.BytesIO(data) as read_buffer:\n    g2.parse(read_buffer)\n\nprint(\"\\nParsed triples:\")\nfor statement in g2:\n    print(statement)\n</code></pre> <p>The <code>data</code> variable is of type <code>bytes</code>, and can be passed to Kafka with <code>KafkaProducer.send(value=data)</code>, or any other API that accepts byte buffers. Same trick may be used when working with the RDFLib integration.</p> <p>When working with Kafka, you should be aware of the broker's offset management and partitioning strategies. Data within one Jelly stream must be strictly ordered and no frames may be dropped. If you have less strict ordering guarantees, you should split up the stream into multiple Jelly streams, each with guaranteed consistency.</p>"},{"location":"generic-sink/#accessing-stream-frame-metadata","title":"Accessing stream frame metadata","text":"<p>It is possible to access <code>RdfStreamFrame</code> metadata in pyjelly via context variables. To do that, define a context variable before parsing and pass it as argument to parser functions, e.g.:</p> <pre><code>from contextvars import ContextVar\nfrom google.protobuf.internal.containers import ScalarMap\nimport urllib.request\nfrom pyjelly.integrations.rdflib.parse import parse_jelly_grouped\n\nframe_metadata: ContextVar[ScalarMap[str, bytes]] = ContextVar(\"frame_metadata\")\n\nurl = \"https://registry.petapico.org/nanopubs.jelly\"\nwith urllib.request.urlopen(url) as response:\n    graphs = parse_jelly_grouped(response, frame_metadata=frame_metadata)\n    for i, graph in enumerate(graphs):\n        if i == 1:  # Just show first instance\n            break\n        print(f\"Graph {i} in the stream has {len(graph)} triples.\")\n        metadata = frame_metadata.get()\n        print(f\"Graph #{i}: {metadata}\")\n</code></pre>"},{"location":"generic-sink/#see-also","title":"See also","text":"<p>If you are familiar with RDFLib, you can use pyjelly together with RDFLib in a similar way. See the dedicated guide.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide walks you through installing and working with pyjelly and RDFLib.</p>"},{"location":"getting-started/#installation-with-rdflib","title":"Installation (with RDFLib)","text":"<p>Install pyjelly from PyPI:</p> <pre><code>pip install pyjelly[rdflib]\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python\u00a03.10 or newer  </li> <li>Linux, macOS, or Windows</li> </ul>"},{"location":"getting-started/#usage-with-rdflib","title":"Usage with RDFLib","text":"<p>Once you install pyjelly, it integrates automatically with RDFLib through standard RDFLib API.</p>"},{"location":"getting-started/#serializing-a-graph","title":"Serializing a graph","text":"<p>To serialize a graph to the Jelly format see:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"https://www.w3.org/TR/vocab-ssn/integrated/examples/sunspots.ttl\")\ng.serialize(destination=\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>This creates a delimited Jelly stream using default options.</p>"},{"location":"getting-started/#including-namespace-declarations-prefixes","title":"Including namespace declarations (prefixes)","text":"<p>By default, Jelly serializes only triples/quads. To also include namespace declarations (prefixes) in the output, enable the <code>namespace_declarations</code> option. Prefixes bound in RDFLib's namespace manager will then be written into the Jelly stream and restored on parsing.</p> <pre><code>from rdflib import Graph, Namespace, URIRef, Literal\nfrom pyjelly.integrations.rdflib.serialize import SerializerOptions, StreamParameters\n\n# Build a tiny graph and bind a prefix\ng = Graph()\nEX = Namespace(\"http://example.org/\")\ng.namespace_manager.bind(\"ex\", EX)\ng.add((EX.alice, URIRef(\"http://xmlns.com/foaf/0.1/name\"), Literal(\"Alice\")))\n\nprint(\"IN  namespaces:\", dict(g.namespaces()))\n\n# Enable namespace declarations in Jelly output\noptions = SerializerOptions(params=StreamParameters(namespace_declarations=True))\n\n# Serialize with options\ng.serialize(\"sample_test.jelly\", format=\"jelly\", options=options)\n\n# Parse back and check namespaces\ng_new = Graph()\ng_new.parse(\"sample_test.jelly\", format=\"jelly\")\nprint(\"OUT namespaces:\", dict(g_new.namespaces()))\n</code></pre> <p>Tip</p> <p>For an existing graph you can (re)bind a prefix just before saving:</p> <pre><code>g.namespace_manager.bind(\"ex\", EX, replace=True)\n</code></pre>"},{"location":"getting-started/#parsing-a-graph","title":"Parsing a graph","text":"<p>To load RDF data from a <code>.jelly</code> file see:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"foaf.jelly\", format=\"jelly\")\n\nprint(\"Parsed triples:\")\nfor s, p, o in g:\n    print(f\"{s} {p} {o}\")\n</code></pre> <p>RDFLib will reconstruct the graph from the Jelly file.</p>"},{"location":"getting-started/#parsing-a-stream-of-graphs","title":"Parsing a stream of graphs","text":"<p>You can process a Jelly stream as a stream of graphs. A Jelly file consists of \"frames\" (batches of statements) \u2013 we can load each frame as a separate RDFLib graph.</p> <p>In this example, we use a dataset of weather measurements. We count the number of triples in each graph:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.rdflib.parse import parse_jelly_grouped\n\n# Dataset: Katrina weather measurements (10k graphs)\n# Documentation: https://w3id.org/riverbench/datasets/lod-katrina/dev\nurl = \"https://w3id.org/riverbench/datasets/lod-katrina/dev/files/jelly_10K.jelly.gz\"\n\n# Load, uncompress .gz file, and pass to Jelly parser, all in a streaming manner\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    graphs = parse_jelly_grouped(jelly_stream)\n    for i, graph in enumerate(graphs):\n        print(f\"Graph {i} in the stream has {len(graph)} triples\")\n        # Limit to 50 graphs for demonstration -- the rest will not be parsed\n        if i &gt;= 50:\n            break\n</code></pre> <p>Each iteration receives only one graph, allowing for processing large datasets efficiently, without exhausting memory.</p>"},{"location":"getting-started/#parsing-a-stream-of-triples","title":"Parsing a stream of triples","text":"<p>You can also process a Jelly stream as a flat stream of triples.</p> <p>We look through a fragment of Denmark's OpenStreetMap to find all city names:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.rdflib.parse import parse_jelly_flat, Triple\nfrom rdflib import URIRef\n\n# Dataset: OpenStreetMap data for Denmark (first 10k objects)\n# Documentation: https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev\nurl = (\n    \"https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev/files/jelly_10K.jelly.gz\"\n)\n\n# We are looking for city names in the dataset\npredicate_to_look_for = URIRef(\"https://www.openstreetmap.org/wiki/Key:addr:city\")\ncity_names = set()\n\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    for event in parse_jelly_flat(jelly_stream):\n        if isinstance(event, Triple):  # we are only interested in triples\n            if event.p == predicate_to_look_for:\n                city_names.add(event.o)\n\nprint(f\"Found {len(city_names)} unique city names in the dataset.\")\nprint(\"10 random city names:\")\nfor city in list(city_names)[:10]:\n    print(f\"- {city}\")\n</code></pre> <p><code>parse_jelly_flat</code> returns a generator of stream events (i.e., statements parsed). This case allows you to efficiently process the file triple-by-triple and build custom aggregations from the stream.</p>"},{"location":"getting-started/#serializing-a-stream-of-graphs","title":"Serializing a stream of graphs","text":"<p>If you have a generator object containing graphs, you can easily serialize it into the Jelly format: </p> <pre><code>from pyjelly.integrations.rdflib.serialize import grouped_stream_to_file\n\nfrom rdflib import Graph, Literal, Namespace\nimport random\n\n\ndef generate_sample_graphs():\n    ex = Namespace(\"http://example.org/\")\n    for _ in range(10):\n        g = Graph()\n        g.add((ex.sensor, ex.temperature, Literal(random.random())))\n        g.add((ex.sensor, ex.humidity, Literal(random.random())))\n        yield g\n\n\noutput_file_name = \"output.jelly\"\n\nprint(f\"Streaming graphs into {output_file_name}\u2026\")\nsample_graphs = generate_sample_graphs()\nwith open(output_file_name, \"wb\") as out_file:\n    grouped_stream_to_file(sample_graphs, out_file)\nprint(\"All done.\")\n</code></pre> <p>This method allows for transmitting logically grouped data, preserving their original division.  For more precise control over frame serialization you can use lower-level API</p>"},{"location":"getting-started/#serializing-a-stream-of-statements","title":"Serializing a stream of statements","text":"<p>If you have a generator object containing statements, you can easily serialize it into the Jelly format: </p> <pre><code>from pyjelly.integrations.rdflib.serialize import flat_stream_to_file\nfrom rdflib import Literal, Namespace\nimport random\n\n\n# example generator with triples statements\ndef generate_sample_triples():\n    ex = Namespace(\"http://example.org/\")\n    for _ in range(10):\n        yield (ex.sensor, ex.temperature, Literal(random.random()))\n\n\noutput_file_name = \"flat_output.jelly\"\n\nprint(f\"Streaming triples into {output_file_name}\u2026\")\nsample_triples = generate_sample_triples()\nwith open(output_file_name, \"wb\") as out_file:\n    flat_stream_to_file(sample_triples, out_file)\nprint(\"All done.\")\n</code></pre> <p>The flat method transmits the data as a continuous sequence of statements, keeping it simple and ordered. For more precise control over frame serialization you can use lower-level API</p>"},{"location":"getting-started/#file-extension-support","title":"File extension support","text":"<p>You can generally omit the <code>format=\"jelly\"</code> parameter if the file ends in <code>.jelly</code> \u2013 RDFLib will auto-detect the format:</p> <pre><code>from rdflib import Graph\nimport pyjelly.integrations.rdflib\n\ng = Graph()\ng.parse(\"foaf.jelly\")\n</code></pre> <p>Warning</p> <p>Unfortunately, the way this is implemented in RDFLib is a bit wonky, so it will only work if you explicitly import <code>pyjelly.integrations.rdflib</code>, or you used <code>format=\"jelly\"</code> in the <code>serialize()</code> or <code>parse()</code> call before.</p>"},{"location":"getting-started/#see-also","title":"See also","text":"<ul> <li>Working with byte buffers and Kafka</li> <li>Usage without RDFLib</li> <li>API reference</li> </ul>"},{"location":"networkx-integration/","title":"NetworkX","text":"<p>NetworkX is a Python package that represents complex networks as graphs and allows for their manipulation.</p> <p>Install the following libraries:</p> <pre><code>pip install pyjelly[rdflib] networkx==3.2.1 matplotlib==3.9.4\n</code></pre> <p>Below there are few useful examples to follow.</p>"},{"location":"networkx-integration/#parse-graph-show-it","title":"Parse graph, show it","text":"<p>Let's investigate relationships between worldwide political figures (support and opposition relations)! We are given a graph in <code>.jelly</code> containing information about political stances extracted from news articles. Let's dive in and get some useful information!</p> <p>We can easily load it:  </p> <pre><code># Parse RDF from the Jelly format\nrdf_g = Graph()\nrdf_g.parse(example_file, format=\"jelly\")\nprint(f\"Loaded graph with {len(rdf_g)} instances.\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Loaded graph with 90000 instances.\n</code></pre> <p>Convert it into a convenient NetworkX graph:</p> <pre><code># Convert to a NetworkX graph\nnx_g = rdflib_to_networkx_graph(rdf_g_filtered)\n</code></pre> <p>Is our graph fully connected? It's important to know (are all political relations tied together?), let's check here:</p> <pre><code># Example calculation, get the number of connected components in a graph\nnum_components = nx.number_connected_components(nx_g)\nprint(f\"Connected components: {num_components}\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Connected components: 24\n</code></pre> <p>Which nodes are connected the most (have most connections?), let's see top 5 of them:</p> <pre><code># Example calculation, get top 5 objects with highest degrees, simple in NetworkX\ntop5 = sorted(nx_g.degree, key=lambda x: x[1], reverse=True)[:5]\nprint(\"Top 5 nodes sorted by degree:\")\nfor node, deg in top5:\n    print(f\"{node}: {deg}\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Top 5 nodes sorted by degree:\nSocrates: 241\nCavaco: 189\nPassos Coelho: 187\nCosta: 179\nAntonio Costa: 168\n</code></pre> <p>What is the shortest path between two nodes? We can check:</p> <pre><code># Example calculation, shortest path between two nodes (provided at least two nodes)\nsource = next(n for n in nx_g if norm(n) == \"socrates\")\ntarget = next(n for n in nx_g if norm(n) == \"obama\")\npath = nx.shortest_path(nx_g, source=source, target=target)\nprint(f\"Shortest path from {source} to {target}: {' -&gt; '.join(path)}\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Shortest path from Socrates to Obama: Socrates -&gt; Marcelo Rebelo de Sousa -&gt; Durao Barroso -&gt; Obama\n</code></pre> <p>However, it's best to see the full picture (for our example we truncate to 10 nodes for clarity):</p> <pre><code># Take first 10 nodes\nnodes = list(nx_g)[:10]\nsubg = nx_g.subgraph(nodes)\n\n# Draw and display the graph\npos_sub = nx.spring_layout(subg, k=5, iterations=200, scale=3, seed=24)\nplt.figure(figsize=(10, 10))\n\n# Introduce your own settings for display\nnx.draw_networkx(subg, pos_sub, font_size=14, node_size=220, linewidths=0.7)\nplt.axis(\"off\")\nplt.show()\n</code></pre> <p>The graph presents as follows</p> <p>In summary:</p> Entire example <pre><code>import urllib.request, gzip, tempfile, shutil, os\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom rdflib import Graph, URIRef, BNode, Literal\nfrom rdflib.extras.external_graph_libs import rdflib_to_networkx_graph\n\n# Filter predicates for people\nTARGET_PREDICATES = {\n    URIRef(\"http://www.politiquices.pt/ent2_str\"),\n    URIRef(\"http://www.politiquices.pt/ent1_str\"),\n}\n\n# URL to the dataset\nurl = \"https://w3id.org/riverbench/datasets/politiquices/1.0.3/files/jelly_10K.jelly.gz\"\n\n# Load example jelly file\nwith urllib.request.urlopen(url) as r:\n    fd, example_file = tempfile.mkstemp(suffix=\".jelly\")\n    os.close(fd)\n    with gzip.GzipFile(fileobj=r) as g, open(example_file, \"wb\") as out:\n        shutil.copyfileobj(g, out)\n\n# Parse RDF from the Jelly format\nrdf_g = Graph()\nrdf_g.parse(example_file, format=\"jelly\")\nprint(f\"Loaded graph with {len(rdf_g)} instances.\")\n\n# First step for filtering the graph\nrdf_g_filtered = Graph()\nfor s, p, o in rdf_g.triples((None, None, None)):\n    if p in TARGET_PREDICATES:\n        rdf_g_filtered.add((s, p, o))\n\n# Just filtering the graph for clarity of visualization, can be omitted\nrelated = URIRef(\"http://www.politiquices.pt/related\")\nfor b in list(rdf_g_filtered.subjects()):\n    if isinstance(b, BNode):\n        ent1 = ent2 = None\n        for p, o in rdf_g_filtered.predicate_objects(b):\n            if p == URIRef(\"http://www.politiquices.pt/ent1_str\") and isinstance(\n                o, Literal\n            ):\n                ent1 = o\n            elif p == URIRef(\"http://www.politiquices.pt/ent2_str\") and isinstance(\n                o, Literal\n            ):\n                ent2 = o\n        if ent1 and ent2:\n            rdf_g_filtered.add((ent1, related, ent2))\n            rdf_g_filtered.add((ent2, related, ent1))\n        for triple in list(rdf_g_filtered.triples((b, None, None))):\n            rdf_g_filtered.remove(triple)\n\n# Convert to a NetworkX graph\nnx_g = rdflib_to_networkx_graph(rdf_g_filtered)\n\n# Example calculation, get the number of connected components in a graph\nnum_components = nx.number_connected_components(nx_g)\nprint(f\"Connected components: {num_components}\")\n\n# Example calculation, get top 5 objects with highest degrees, simple in NetworkX\ntop5 = sorted(nx_g.degree, key=lambda x: x[1], reverse=True)[:5]\nprint(\"Top 5 nodes sorted by degree:\")\nfor node, deg in top5:\n    print(f\"{node}: {deg}\")\n\n# Helper function\nnorm = (\n    lambda n: str(n.value).strip().lower()\n    if isinstance(n, Literal)\n    else str(n).strip().lower()\n)\n\n# Example calculation, shortest path between two nodes (provided at least two nodes)\nsource = next(n for n in nx_g if norm(n) == \"socrates\")\ntarget = next(n for n in nx_g if norm(n) == \"obama\")\npath = nx.shortest_path(nx_g, source=source, target=target)\nprint(f\"Shortest path from {source} to {target}: {' -&gt; '.join(path)}\")\n\n# Take first 10 nodes\nnodes = list(nx_g)[:10]\nsubg = nx_g.subgraph(nodes)\n\n# Draw and display the graph\npos_sub = nx.spring_layout(subg, k=5, iterations=200, scale=3, seed=24)\nplt.figure(figsize=(10, 10))\n\n# Introduce your own settings for display\nnx.draw_networkx(subg, pos_sub, font_size=14, node_size=220, linewidths=0.7)\nplt.axis(\"off\")\nplt.show()\n\nprint(\"All done.\")\n</code></pre> <p>We converted an RDFLib graph to NetworkX, calculated insightful metrics and visualized the graph.  </p> <p>For more info about the data source please see the Politiquices dataset in RiverBench and its original source (Portuguese).</p>"},{"location":"networkx-integration/#serialize-networkx-graph","title":"Serialize NetworkX graph","text":"<p>This example shows how to write a NetworkX graph to a Jelly file.:</p> <pre><code>import networkx as nx\nfrom rdflib import Graph, URIRef, Namespace\nfrom rdflib.namespace import RDF\n\n# An example NetworkX graph\nnx_g = nx.Graph()\nnx_g.add_node(\"http://example.org/A\")\nnx_g.add_node(\"http://example.org/B\")\nnx_g.add_edge(\"http://example.org/A\", \"http://example.org/B\")\n\n# We define RDFLib graph for further conversion\nrdf_g = Graph()\n\n# Example namespace\nex = Namespace(\"http://example.org/ns#\")\n\n# Add triples through node information in NetworkX graph\nfor node_uri, data in nx_g.nodes(data=True):\n    subj = URIRef(node_uri)\n    rdf_g.add((subj, RDF.type, ex.Node))\n\n# Add triples through edge information in NetworkX graph\nfor u, v, attr in nx_g.edges(data=True):\n    rdf_g.add((URIRef(u), ex.connectedTo, URIRef(v)))\n\n# Serialize graph into a .jelly file\nrdf_g.serialize(destination=\"networkx_graph.jelly\", format=\"jelly\")\nprint(\"All done.\")\n</code></pre> <p>Which converts the NetworkX graph into an RDFLib <code>Graph</code> instance and serializes it.</p>"},{"location":"networkx-integration/#related-sources","title":"Related sources","text":"<p>To get more information, see the following:</p> <ul> <li>NetworkX examples</li> <li>NetworkX repository (github)</li> <li>RDFLib external graph integration</li> </ul>"},{"location":"overview/","title":"Overview and supported features","text":""},{"location":"overview/#what-is-jelly-and-pyjelly","title":"What is Jelly and pyjelly?","text":"<p>Jelly is a high-performance serialization format for RDF knowledge graphs and knowledge graph streams. It's designed to be fast, compact, and flexible. </p> <p>With Jelly, you can transmit both flat and structured streams of triples, quads, graphs, and datasets. Jelly works well in both batch and real-time settings \u2013 including files, sockets, or streaming protocols like Kafka or gRPC.</p> <p>pyjelly is a Python implementation of the Jelly protocol. It provides:</p> <ul> <li>Full support for reading and writing Jelly-encoded RDF data</li> <li>Seamless integration with RDFLib (\"works just like Turtle\")</li> <li>Standalone generic API with no third-party dependencies Generic API</li> <li>Support for all Jelly stream types</li> <li>Tools for working with delimited and non-delimited Jelly streams</li> <li>Fine-grained control over serialization options, compression, and framing</li> </ul>"},{"location":"overview/#overview","title":"Overview","text":""},{"location":"overview/#supported-stream-types","title":"Supported stream types","text":"<p>pyjelly supports all physical stream types: <code>TRIPLES</code>, <code>QUADS</code> and <code>GRAPHS</code>.</p> <p>See the full stream type matrix for an overview of valid combinations.</p>"},{"location":"overview/#conformance-to-the-jelly-specification","title":"Conformance to the Jelly specification","text":"<p>pyjelly is continuously tested for conformance to the Jelly specification. While the vast majority of features are implemented, there are a few edge cases left to resolve.</p> <p>You can track the progress in the conformance test suite definition.</p>"},{"location":"overview/#use-cases","title":"Use cases","text":"<p>Use cases for pyjelly include:</p> <ul> <li>Client-server communication \u2013 link your client app in Python to the server (e.g., Apache Jena, RDF4J) with Jelly to reduce latency and improve user experience.</li> <li>Inter-service communication \u2013 use Jelly to efficiently exchange RDF data between microservices.</li> <li>Data science workflows \u2013 use Jelly to read and write RDF data in data science pipelines, enabling efficient processing of large datasets. <ul> <li>pyjelly is fully streaming, so it can handle large datasets without loading everything into memory at once.</li> <li>We are working on support for pandas and other data science libraries \u2013 stay tuned for updates!</li> </ul> </li> <li>Database dumps and bulk loads \u2013 quickly read and write large RDF datasets with Jelly, reducing storage space and improving database maintenance tasks.</li> </ul>"},{"location":"overview/#pyjelly-integration-with-external-libraries","title":"pyjelly integration with external libraries","text":"<p>To learn how to use popular third-party libraries that connect with RDFLib, please see:</p> <ul> <li>RDFLib-Neo4j integration</li> <li>NetworkX integration</li> </ul>"},{"location":"overview/#generic-api","title":"Generic API","text":"<p>pyjelly includes its own generic API for working with RDF data (no RDFLib or other external RDF libraries required). It provides simple, built-in types for triples and quads, allowing you to create, read, and write data directly in the Jelly format.</p>"},{"location":"rdflib-neo4j-integration/","title":"RDFLib-Neo4j","text":"<p>Info</p> <p>This is an integration with Neo4j via the RDFLib-Neo4j library. It works with all Neo4j instances, including AuraDB, but is limited in features and performance. If you are self-hosting Neo4j (Neo4j Desktop or Community/Enterprise), consider using the Jelly-Neo4j plugin for neosemantics, which offers better performance and more features.</p> <p>RDFLib-Neo4j lets you import RDF triples into Neo4j via the RDFLib API.</p> <p>Install the following library:  </p> <pre><code>pip install pyjelly[rdflib] rdflib-neo4j\n</code></pre>"},{"location":"rdflib-neo4j-integration/#parsing-data-from-a-jelly-file-into-neo4j","title":"Parsing data from a Jelly file into Neo4j","text":"<p>To parse data from a <code>.jelly</code> file into the Neo4j database, use the following example (insert your own credentials to AuraDB):</p> Parsing <pre><code>import urllib.request\nfrom neo4j import GraphDatabase\nfrom rdflib import Graph\nfrom rdflib_neo4j import Neo4jStoreConfig, Neo4jStore, HANDLE_VOCAB_URI_STRATEGY\n\n# Example file from the Riverbench\nexample_file, _ = urllib.request.urlretrieve(\"https://w3id.org/riverbench/v/dev.jelly\")\n\n# Please introduce your credentials\naura_db_uri = \"aura_db_uri\"\naura_db_username = \"neo4j\"\naura_db_pwd = \"aura_db_pwd\"\n\n# Prepare the authentication data to the AuraDB\nauth_data = {\n    \"uri\": aura_db_uri,\n    \"database\": \"neo4j\",\n    \"user\": aura_db_username,\n    \"pwd\": aura_db_pwd,\n}\n\n# Prepare the configuration for Neo4jStore object\nconfig = Neo4jStoreConfig(\n    auth_data=auth_data,\n    handle_vocab_uri_strategy=HANDLE_VOCAB_URI_STRATEGY.IGNORE,\n    batching=True,\n)\n\n# Make a graph with Neo4jStore object\nneo4j_sink = Graph(store=Neo4jStore(config=config))\n\n# Parse the file into the AuraDB\nneo4j_sink.parse(example_file, format=\"jelly\")\n\n# Close the stream\nneo4j_sink.close(True)\n\n# Cypher query to check loaded data\nwith GraphDatabase.driver(\n    aura_db_uri, auth=(aura_db_username, aura_db_pwd)\n).session() as session:\n    count = session.run(\"MATCH ()-[r]-&gt;() RETURN count(r) AS c\").single()[\"c\"]\n    print(f\"Loaded {count} triples\")\n    for r in session.run(\n        \"MATCH (s)-[r]-&gt;(o) RETURN s.uri AS s, type(r) AS p, coalesce(o.uri,o.name) AS o LIMIT 5\"\n    ):\n        print(r[\"s\"], f\"-[{r['p']}]-&gt;\", r[\"o\"])\n\nprint(\"All done.\")\n</code></pre> <p>which inserts your data into your AuraDB database.</p>"},{"location":"rdflib-neo4j-integration/#related-sources","title":"Related sources","text":"<p>For more information, visit:</p> <ul> <li>RDFLib-Neo4j (GitHub)</li> <li>Neo4j Labs: RDFLib-Neo4j</li> <li>Alternative: Jelly-Neo4j plugin for neosemantics</li> </ul>"},{"location":"contributing/","title":"Contributing to pyjelly","text":"<p>Hi! This guide explains how to get started with developing pyjelly and contributing to it.</p>"},{"location":"contributing/#quick-start","title":"Quick start","text":"<p>System requirements: while pyjelly works on any system that supports Python, for development we recommend using Linux, macOS, or WSL on Windows. We advise against using Windows directly, as it has caused many headaches in the past.</p> <p>Clone the project: </p> <pre><code>git clone --recursive git@github.com:Jelly-RDF/pyjelly.git\n</code></pre> <p>We use <code>uv</code> for package management. If you don't already have it, install uv.</p> <p>On Linux this is: </p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Install the project:</p> <pre><code>uv sync\n</code></pre> <p>Note</p> <p>If you use an IDE, make sure that it uses the Python interpreter from the environment that will be created in the <code>.venv</code> directory.</p> <p>If you get an error about the uv version being incorrect, run <code>uv self update</code></p> <p>Activate the environment or use <code>uv run</code> to run commands and code. </p>"},{"location":"contributing/#giving-feedback","title":"Giving feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Jelly-RDF/pyjelly/issues</p> <p>If you are proposing a feature:</p> <ol> <li>Explain how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Contributions are always welcome! Consider if you can help with implementing the feature.</li> </ol>"},{"location":"contributing/#contributing-code","title":"Contributing code","text":"<p>If you've found a major issue (not just a typo) or have a feature request, please open an issue first. This helps us keep track of what needs to be done and allows others to contribute as well.</p> <p>When opening a pull request:</p> <ul> <li>Use a descriptive title.</li> <li>Clearly describe what the pull request does and why it is needed.</li> <li>Reference the related issue in the description.</li> </ul> <p>The CI will check if your code passes all checks. You can run these checks locally:</p> <ul> <li>Tests: <code>uv run pytest</code></li> <li>Type safety: <code>uv run mypy .</code></li> <li>Linter: <code>uv run ruff check --fix</code></li> <li>Formatter: <code>uv run ruff format</code></li> </ul> <p>This helps us follow best practices and keep the codebase in shape.</p>"},{"location":"contributing/#contributing-documentation","title":"Contributing documentation","text":"<p>The documentation is written in Markdown and built using MkDocs, using Material for MkDocs.</p> <p>To edit a documentation page, simply click the  button in the top-right of the page.</p> <p>It will take you to GitHub, where you can edit the Markdown file and submit a pull request. You can also clone the repository and edit the files locally. The source files are in the <code>docs</code> directory.</p>"},{"location":"contributing/#previewing-documentation-locally","title":"Previewing documentation locally","text":"<p>Install dependencies for docs:</p> <pre><code>uv sync --group docs\n</code></pre> <p>Then, start a local docs server:</p> <pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"contributing/#further-reading","title":"Further reading","text":"<ul> <li>More information on editing Jelly docs</li> <li>Material for MkDocs reference</li> <li>MkDocs documentation</li> <li>Macro plugin documentation</li> </ul>"},{"location":"contributing/#making-releases","title":"Making releases","text":"<ol> <li>Make sure you are on the <code>main</code> branch and that it is up-to-date: <code>git checkout main &amp;&amp; git pull</code>.</li> <li>Create a new tag for the release. For example, for version 1.2.3: <code>git tag v1.2.3</code>. The tag must start with <code>v</code>!</li> <li>Push the tag to GitHub: <code>git push origin v1.2.3</code>.</li> <li>The release will be automatically built and published to PyPI.</li> </ol>"},{"location":"contributing/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"contributing/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at community@neverblink.eu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/code_of_conduct/#attribution","title":"Attribution","text":"<p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"examples/","title":"Index","text":"<p>Code examples for using pyjelly in practice.</p> <p>The examples will be executed in alphabetical order, so you can number them accordingly.</p>"}]}