{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyjelly","text":"<p>pyjelly is a Python implementation of Jelly, a high-performance binary serialization format and streaming protocol for RDF knowledge graphs. It works great with RDFLib.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast reading and writing of RDF knowledge graphs in the Jelly format</li> <li>Seamless integration with RDFLib</li> <li>Stream processing support for large datasets or streams of many RDF graphs/datasets</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting started</li> <li>Overview and supported features</li> <li>Generic interface (usage without RDFLib)</li> <li>API reference</li> <li>Contributing \u2013 how to report issues, contribute code, and request features</li> </ul>"},{"location":"#compatibility","title":"Compatibility","text":"<p>pyjelly is compatible with Python 3.9 and newer. Python 3.9\u20133.13 are tested in CI and are guaranteed to work.</p> <p>The following table shows the compatibility of the pyjelly implementation with other libraries:</p> pyjelly Python RDFLib 0.1.0 \u2013 0.6.0 3.9 \u2013 3.13 7.x (&gt;= 7.1.4) <p>See the release notes on GitHub for more details.</p>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p>"},{"location":"#license","title":"License","text":"<p>The pyjelly library is licensed under the Apache 2.0 license.</p> <p>The development of the Jelly protocol, its implementations, and supporting tooling was co-funded by the European Union. More details.</p> <p></p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#pyjelly","title":"<code>pyjelly</code>","text":"<p>Modules:</p> Name Description <code>errors</code> <code>integrations</code> <code>jelly</code> <code>options</code> <code>parse</code> <code>serialize</code>"},{"location":"api/#pyjelly.errors","title":"<code>errors</code>","text":"<p>Classes:</p> Name Description <code>JellyConformanceError</code> <p>Raised when Jelly conformance is violated.</p> <code>JellyAssertionError</code> <p>Raised when a recommended assertion from the specification fails.</p> <code>JellyNotImplementedError</code> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.errors.JellyConformanceError","title":"<code>JellyConformanceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when Jelly conformance is violated.</p>"},{"location":"api/#pyjelly.errors.JellyAssertionError","title":"<code>JellyAssertionError</code>","text":"<p>               Bases: <code>AssertionError</code></p> <p>Raised when a recommended assertion from the specification fails.</p>"},{"location":"api/#pyjelly.errors.JellyNotImplementedError","title":"<code>JellyNotImplementedError</code>","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Raised when a future feature is not yet implemented.</p>"},{"location":"api/#pyjelly.integrations","title":"<code>integrations</code>","text":"<p>Modules:</p> Name Description <code>generic</code> <code>rdflib</code>"},{"location":"api/#pyjelly.integrations.generic","title":"<code>generic</code>","text":"<p>Modules:</p> Name Description <code>generic_sink</code> <code>parse</code> <code>serialize</code>"},{"location":"api/#pyjelly.integrations.generic.generic_sink","title":"<code>generic_sink</code>","text":"<p>Classes:</p> Name Description <code>BlankNode</code> <p>Class for blank nodes, storing BN's identifier as a string.</p> <code>IRI</code> <p>Class for IRIs, storing IRI as a string.</p> <code>Literal</code> <p>Class for literals.</p> <code>Triple</code> <p>Class for RDF triples.</p> <code>Quad</code> <p>Class for RDF quads.</p> <code>Prefix</code> <p>Class for generic namespace declaration.</p> <code>GenericStatementSink</code> <code>BlankNode(identifier)</code> <p>Class for blank nodes, storing BN's identifier as a string.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, identifier: str) -&gt; None:\n    self._identifier: str = identifier\n</code></pre> <code>IRI(iri)</code> <p>Class for IRIs, storing IRI as a string.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, iri: str) -&gt; None:\n    self._iri: str = iri\n</code></pre> <code>Literal(lex, langtag=None, datatype=None)</code> <p>Class for literals.</p> <p>Notes:     Consists of: lexical form, and optional language tag and datatype.     All parts of literal are stored as strings.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(\n    self, lex: str, langtag: str | None = None, datatype: str | None = None\n) -&gt; None:\n    self._lex: str = lex\n    self._langtag: str | None = langtag\n    self._datatype: str | None = datatype\n</code></pre> <code>Triple</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for RDF triples.</p> <code>Quad</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for RDF quads.</p> <code>Prefix</code> <p>               Bases: <code>NamedTuple</code></p> <p>Class for generic namespace declaration.</p> <code>GenericStatementSink(identifier=DefaultGraph)</code> <p>Notes:     _store preserves the order of statements.</p> <p>Args:     identifier (str, optional): Identifier for a sink.         Defaults to DefaultGraph.</p> <p>Attributes:</p> Name Type Description <code>is_triples_sink</code> <code>bool</code> <p>Check if the sink contains triples or quads.</p> Source code in <code>pyjelly/integrations/generic/generic_sink.py</code> <pre><code>def __init__(self, identifier: GraphName = DefaultGraph) -&gt; None:\n    \"\"\"\n    Initialize statements storage, namespaces dictionary, and parser.\n\n    Notes:\n        _store preserves the order of statements.\n\n    Args:\n        identifier (str, optional): Identifier for a sink.\n            Defaults to DefaultGraph.\n\n    \"\"\"\n    self._store: deque[Triple | Quad] = deque()\n    self._namespaces: dict[str, IRI] = {}\n    self._identifier = identifier\n</code></pre> <code>is_triples_sink</code> <p>Check if the sink contains triples or quads.</p> <p>Returns:     bool: true, if length of statement is 3.</p>"},{"location":"api/#pyjelly.integrations.generic.parse","title":"<code>parse</code>","text":"<p>Classes:</p> Name Description <code>GenericStatementSinkAdapter</code> <p>Implement Adapter for generic statements.</p> <code>GenericTriplesAdapter</code> <p>Triples adapted implementation for GenericStatementSink.</p> <code>GenericQuadsAdapter</code> <p>Extends GenericQuadsBaseAdapter for QUADS physical type.</p> <code>GenericGraphsAdapter</code> <p>Extends GenericQuadsBaseAdapter for GRAPHS physical type.</p> <p>Functions:</p> Name Description <code>parse_triples_stream</code> <p>Parse flat triple stream.</p> <code>parse_quads_stream</code> <p>Parse flat quads stream.</p> <code>parse_jelly_grouped</code> <p>Take a jelly file and return generators of generic statements sinks.</p> <code>parse_jelly_to_graph</code> <p>Add statements from Generator to GenericStatementSink.</p> <code>parse_jelly_flat</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <code>GenericStatementSinkAdapter(options, parsing_mode=ParsingMode.FLAT)</code> <p>               Bases: <code>Adapter</code></p> <p>Implement Adapter for generic statements.</p> <p>Notes:     Returns custom RDF terms expected by GenericStatementSink,     handles namespace declarations, and quoted triples.</p> <p>Args:     Adapter (type): base Adapter class</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def __init__(\n    self, options: ParserOptions, parsing_mode: ParsingMode = ParsingMode.FLAT\n) -&gt; None:\n    self.options = options\n    self.parsing_mode = parsing_mode\n</code></pre> <code>GenericTriplesAdapter(options)</code> <p>               Bases: <code>GenericStatementSinkAdapter</code></p> <p>Triples adapted implementation for GenericStatementSink.</p> <p>Args:     GenericStatementSinkAdapter (type): base GenericStatementSink         adapter implementation that handles terms and namespaces.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>GenericQuadsAdapter(options)</code> <p>               Bases: <code>GenericQuadsBaseAdapter</code></p> <p>Extends GenericQuadsBaseAdapter for QUADS physical type.</p> <p>Args:     GenericQuadsBaseAdapter (type): quads adapter that handles         base quads processing.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def __init__(self, options: ParserOptions) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>GenericGraphsAdapter(options)</code> <p>               Bases: <code>GenericQuadsBaseAdapter</code></p> <p>Extends GenericQuadsBaseAdapter for GRAPHS physical type.</p> <p>Notes:     introduces graph start/end, checks if graph exists.</p> <p>Args:     GenericQuadsBaseAdapter (type): quads adapter that handles         base quads processing.</p> <p>Raises:     JellyConformanceError: raised if graph start message was not received.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n    self._graph_id = None\n</code></pre> <code>parse_triples_stream(frames, options)</code> <p>Parse flat triple stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options</p> <p>Yields:     Generator[Iterable[Triple | Prefix]]:         Generator of iterables of Triple or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_triples_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n) -&gt; Generator[Iterable[Triple | Prefix]]:\n    \"\"\"\n    Parse flat triple stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n\n    Yields:\n        Generator[Iterable[Triple | Prefix]]:\n            Generator of iterables of Triple or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter = GenericTriplesAdapter(options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_quads_stream(frames, options)</code> <p>Parse flat quads stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options</p> <p>Yields:     Generator[Iterable[Quad | Prefix]]:         Generator of iterables of Quad or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_quads_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n) -&gt; Generator[Iterable[Quad | Prefix]]:\n    \"\"\"\n    Parse flat quads stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n\n    Yields:\n        Generator[Iterable[Quad | Prefix]]:\n            Generator of iterables of Quad or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter_class: type[GenericQuadsBaseAdapter]\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_QUADS:\n        adapter_class = GenericQuadsAdapter\n    else:\n        adapter_class = GenericGraphsAdapter\n    adapter = adapter_class(options=options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_jelly_grouped(inp, sink_factory=lambda: GenericStatementSink(), *, logical_type_strict=False)</code> <p>Take a jelly file and return generators of generic statements sinks.</p> <p>Yields one generic statements sink per frame.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream     sink_factory (Callable): lambda to construct a statement sink.         By default, creates an empty in-memory GenericStatementSink.     logical_type_strict (bool): If True, validate the logical type         in stream options and require a grouped logical type.         Otherwise, only the physical type is used to route parsing.</p> <p>Raises:     NotImplementedError: is raised if a physical type is not implemented</p> <p>Yields:     Generator[GenericStatementSink]:         returns generators for GenericStatementSink, regardless of stream type.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_jelly_grouped(\n    inp: IO[bytes],\n    sink_factory: Callable[[], GenericStatementSink] = lambda: GenericStatementSink(),\n    *,\n    logical_type_strict: bool = False,\n) -&gt; Generator[GenericStatementSink]:\n    \"\"\"\n    Take a jelly file and return generators of generic statements sinks.\n\n    Yields one generic statements sink per frame.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream\n        sink_factory (Callable): lambda to construct a statement sink.\n            By default, creates an empty in-memory GenericStatementSink.\n        logical_type_strict (bool): If True, validate the *logical* type\n            in stream options and require a grouped logical type.\n            Otherwise, only the physical type is used to route parsing.\n\n    Raises:\n        NotImplementedError: is raised if a physical type is not implemented\n\n    Yields:\n        Generator[GenericStatementSink]:\n            returns generators for GenericStatementSink, regardless of stream type.\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (\n        st is None\n        or st.logical_type == jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED\n        or st.flat\n    ):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected GROUPED logical type, got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for graph in parse_triples_stream(\n            frames=frames,\n            options=options,\n        ):\n            sink = sink_factory()\n            for graph_item in graph:\n                if isinstance(graph_item, Prefix):\n                    sink.bind(graph_item.prefix, graph_item.iri)\n                else:\n                    sink.add(graph_item)\n            yield sink\n        return\n    elif options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for dataset in parse_quads_stream(\n            frames=frames,\n            options=options,\n        ):\n            sink = sink_factory()\n            for item in dataset:\n                if isinstance(item, Prefix):\n                    sink.bind(item.prefix, item.iri)\n                else:\n                    sink.add(item)\n            yield sink\n        return\n\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre> <code>parse_jelly_to_graph(inp, sink_factory=lambda: GenericStatementSink())</code> <p>Add statements from Generator to GenericStatementSink.</p> <p>Args:     inp (IO[bytes]): input jelly stream.     sink_factory (Callable[[], GenericStatementSink]): factory to create         statement sink.         By default creates an empty in-memory GenericStatementSink.         Has no division for datasets/graphs,         utilizes the same underlying data structures.</p> <p>Returns:     GenericStatementSink: GenericStatementSink with statements.</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_jelly_to_graph(\n    inp: IO[bytes],\n    sink_factory: Callable[[], GenericStatementSink] = lambda: GenericStatementSink(),\n) -&gt; GenericStatementSink:\n    \"\"\"\n    Add statements from Generator to GenericStatementSink.\n\n    Args:\n        inp (IO[bytes]): input jelly stream.\n        sink_factory (Callable[[], GenericStatementSink]): factory to create\n            statement sink.\n            By default creates an empty in-memory GenericStatementSink.\n            Has no division for datasets/graphs,\n            utilizes the same underlying data structures.\n\n    Returns:\n        GenericStatementSink: GenericStatementSink with statements.\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n    sink = sink_factory()\n\n    for item in parse_jelly_flat(inp=inp, frames=frames, options=options):\n        if isinstance(item, Prefix):\n            sink.bind(item.prefix, item.iri)\n        else:\n            sink.add(item)\n    return sink\n</code></pre> <code>parse_jelly_flat(inp, frames=None, options=None, *, logical_type_strict=False)</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream.     frames (Iterable[jelly.RdfStreamFrame | None):         jelly frames if read before.     options (ParserOptions | None): stream options         if read before.     logical_type_strict (bool): If True, validate the logical type         in stream options and require FLAT (TRIPLES/QUADS).         Otherwise, only the physical type is used to route parsing.</p> <p>Raises:     NotImplementedError: if physical type is not supported</p> <p>Yields:     Generator[Statement | Prefix]: Generator of stream events</p> Source code in <code>pyjelly/integrations/generic/parse.py</code> <pre><code>def parse_jelly_flat(\n    inp: IO[bytes],\n    frames: Iterable[jelly.RdfStreamFrame] | None = None,\n    options: ParserOptions | None = None,\n    *,\n    logical_type_strict: bool = False,\n) -&gt; Generator[Statement | Prefix]:\n    \"\"\"\n    Parse jelly file with FLAT logical type into a Generator of stream events.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream.\n        frames (Iterable[jelly.RdfStreamFrame | None):\n            jelly frames if read before.\n        options (ParserOptions | None): stream options\n            if read before.\n        logical_type_strict (bool): If True, validate the *logical* type\n            in stream options and require FLAT (TRIPLES/QUADS).\n            Otherwise, only the physical type is used to route parsing.\n\n    Raises:\n        NotImplementedError: if physical type is not supported\n\n    Yields:\n        Generator[Statement | Prefix]: Generator of stream events\n\n    \"\"\"\n    if frames is None or options is None:\n        options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (st is None or not st.flat):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected FLAT logical type (TRIPLES/QUADS), got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for triples in parse_triples_stream(frames=frames, options=options):\n            yield from triples\n        return\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for quads in parse_quads_stream(\n            frames=frames,\n            options=options,\n        ):\n            yield from quads\n        return\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#pyjelly.integrations.generic.serialize","title":"<code>serialize</code>","text":"<p>Classes:</p> Name Description <code>GenericSinkTermEncoder</code> <p>Functions:</p> Name Description <code>triples_stream_frames</code> <p>Serialize a GenericStatementSink into frames using physical type triples stream.</p> <code>quads_stream_frames</code> <p>Serialize a GenericStatementSink into jelly frames using physical type quads stream.</p> <code>graphs_stream_frames</code> <p>Serialize a GenericStatementSink into jelly frames as a stream of graphs.</p> <code>split_to_graphs</code> <p>Split a generator of quads to graphs.</p> <code>guess_options</code> <p>Guess the serializer options based on the store type.</p> <code>guess_stream</code> <p>Return an appropriate stream implementation for the given options.</p> <code>grouped_stream_to_frames</code> <p>Transform multiple GenericStatementSinks into Jelly frames.</p> <code>grouped_stream_to_file</code> <p>Write stream of GenericStatementSink to a binary file.</p> <code>flat_stream_to_frames</code> <p>Serialize a stream of raw GenericStatementSink's triples or quads into Jelly frames.</p> <code>flat_stream_to_file</code> <p>Write Triple or Quad events to a binary file.</p> <code>GenericSinkTermEncoder(lookup_preset=None)</code> <p>               Bases: <code>TermEncoder</code></p> <p>Methods:</p> Name Description <code>encode_spo</code> <p>Encode term based on its GenericSink object.</p> <code>encode_graph</code> <p>Encode graph term based on its GenericSink object.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def __init__(\n    self,\n    lookup_preset: options.LookupPreset | None = None,\n) -&gt; None:\n    if lookup_preset is None:\n        lookup_preset = options.LookupPreset()\n    self.lookup_preset = lookup_preset\n    self.names = LookupEncoder(lookup_size=lookup_preset.max_names)\n    self.prefixes = LookupEncoder(lookup_size=lookup_preset.max_prefixes)\n    self.datatypes = LookupEncoder(lookup_size=lookup_preset.max_datatypes)\n</code></pre> <code>encode_spo(term, slot, statement)</code> <p>Encode term based on its GenericSink object.</p> <p>Args:     term (object): term to encode     slot (Slot): its place in statement.     statement (Statement): Triple/Quad/GraphStart message to fill with terms.</p> <p>Returns:     Rows: encoded extra rows</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def encode_spo(self, term: object, slot: Slot, statement: Statement) -&gt; Rows:\n    \"\"\"\n    Encode term based on its GenericSink object.\n\n    Args:\n        term (object): term to encode\n        slot (Slot): its place in statement.\n        statement (Statement): Triple/Quad/GraphStart message to fill with terms.\n\n    Returns:\n        Rows: encoded extra rows\n\n    \"\"\"\n    if isinstance(term, IRI):\n        iri = self.get_iri_field(statement, slot)\n        return self.encode_iri(term._iri, iri)\n\n    if isinstance(term, Literal):\n        literal = self.get_literal_field(statement, slot)\n        return self.encode_literal(\n            lex=term._lex,\n            language=term._langtag,\n            datatype=term._datatype,\n            literal=literal,\n        )\n\n    if isinstance(term, BlankNode):\n        self.set_bnode_field(\n            statement,\n            slot,\n            term._identifier,\n        )\n        return ()\n\n    if isinstance(term, Triple):\n        quoted_statement = self.get_triple_field(statement, slot)\n        return self.encode_quoted_triple(term, quoted_statement)\n\n    return super().encode_spo(term, slot, statement)  # error if not handled\n</code></pre> <code>encode_graph(term, statement)</code> <p>Encode graph term based on its GenericSink object.</p> <p>Args:     term (object): term to encode     statement (HasGraph): Quad/GraphStart message to fill g_{} in.</p> <p>Returns:     Rows: encoded extra rows</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def encode_graph(self, term: object, statement: HasGraph) -&gt; Rows:\n    \"\"\"\n    Encode graph term based on its GenericSink object.\n\n    Args:\n        term (object): term to encode\n        statement (HasGraph): Quad/GraphStart message to fill g_{} in.\n\n    Returns:\n        Rows: encoded extra rows\n\n    \"\"\"\n    if term == DefaultGraph:\n        return self.encode_default_graph(statement.g_default_graph)\n    if isinstance(term, IRI):\n        return self.encode_iri(term._iri, statement.g_iri)\n\n    if isinstance(term, Literal):\n        return self.encode_literal(\n            lex=term._lex,\n            language=term._langtag,\n            datatype=term._datatype,\n            literal=statement.g_literal,\n        )\n\n    if isinstance(term, BlankNode):\n        statement.g_bnode = term._identifier\n        return ()\n    return super().encode_graph(term, statement)  # error if not handled\n</code></pre> <code>triples_stream_frames(stream, data)</code> <p>Serialize a GenericStatementSink into frames using physical type triples stream.</p> <p>Args:     stream (TripleStream): stream that specifies triples processing     data (GenericStatementSink | Generator[Triple]):         GenericStatementSink/Statements to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>@stream_frames.register(TripleStream)\ndef triples_stream_frames(\n    stream: TripleStream,\n    data: GenericStatementSink | Generator[Triple],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a GenericStatementSink into frames using physical type triples stream.\n\n    Args:\n        stream (TripleStream): stream that specifies triples processing\n        data (GenericStatementSink | Generator[Triple]):\n            GenericStatementSink/Statements to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    stream.enroll()\n    if (\n        isinstance(data, GenericStatementSink)\n        and stream.options.params.namespace_declarations\n    ):\n        namespace_declarations(data, stream)\n\n    graphs = (data,)\n    for graph in graphs:\n        for terms in graph:\n            if frame := stream.triple(terms):\n                yield frame\n        if frame := stream.flow.frame_from_graph():\n            yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>quads_stream_frames(stream, data)</code> <p>Serialize a GenericStatementSink into jelly frames using physical type quads stream.</p> <p>Args:     stream (QuadStream): stream that specifies quads processing     data (GenericStatementSink | Generator[Quad]): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>@stream_frames.register(QuadStream)\ndef quads_stream_frames(\n    stream: QuadStream,\n    data: GenericStatementSink | Generator[Quad],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a GenericStatementSink into jelly frames using physical type quads stream.\n\n    Args:\n        stream (QuadStream): stream that specifies quads processing\n        data (GenericStatementSink | Generator[Quad]): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)  # type: ignore[arg-type]\n\n    iterator: Generator[Quad]\n    if isinstance(data, GenericStatementSink):\n        iterator = cast(Generator[Quad], data.store)\n    else:\n        iterator = data\n\n    for terms in iterator:\n        if frame := stream.quad(terms):\n            yield frame\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>graphs_stream_frames(stream, data)</code> <p>Serialize a GenericStatementSink into jelly frames as a stream of graphs.</p> <p>Notes:     If flow of DatasetsFrameFlow type, the whole dataset     will be encoded into one frame.     Graphs are generated from the GenericStatementSink by     iterating over statements and yielding one new GenericStatementSink     per a sequence of quads with the same g term.</p> <p>Args:     stream (GraphStream): stream that specifies graphs processing     data (GenericStatementSink | Generator[Quad]): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>@stream_frames.register(GraphStream)\ndef graphs_stream_frames(\n    stream: GraphStream,\n    data: GenericStatementSink | Generator[Quad],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a GenericStatementSink into jelly frames as a stream of graphs.\n\n    Notes:\n        If flow of DatasetsFrameFlow type, the whole dataset\n        will be encoded into one frame.\n        Graphs are generated from the GenericStatementSink by\n        iterating over statements and yielding one new GenericStatementSink\n        per a sequence of quads with the same g term.\n\n    Args:\n        stream (GraphStream): stream that specifies graphs processing\n        data (GenericStatementSink | Generator[Quad]): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)  # type: ignore[arg-type]\n\n    statements: Generator[Quad]\n    if isinstance(data, GenericStatementSink):\n        statements = cast(Generator[Quad], data.store)\n        graphs = split_to_graphs(statements)\n    elif iter(data):\n        statements = data\n        graphs = split_to_graphs(statements)\n\n    for graph in graphs:\n        yield from stream.graph(graph_id=graph.identifier, graph=graph)\n\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>split_to_graphs(data)</code> <p>Split a generator of quads to graphs.</p> <p>Notes:     New graph is generated by     iterating over statements and yielding one new GenericStatementSink     per a sequence of quads with the same g term.</p> <p>Args:     data (Generator[Quad]): generator of quads</p> <p>Yields:     Generator[GenericStatementSink]: generator of GenericStatementSinks,     each having triples in store and identifier set.</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def split_to_graphs(data: Generator[Quad]) -&gt; Generator[GenericStatementSink]:\n    \"\"\"\n    Split a generator of quads to graphs.\n\n    Notes:\n        New graph is generated by\n        iterating over statements and yielding one new GenericStatementSink\n        per a sequence of quads with the same g term.\n\n    Args:\n        data (Generator[Quad]): generator of quads\n\n    Yields:\n        Generator[GenericStatementSink]: generator of GenericStatementSinks,\n        each having triples in store and identifier set.\n\n    \"\"\"\n    current_g: GraphName | None = None\n    current_sink: GenericStatementSink | None = None\n    for statement in data:\n        if current_g != statement.g:\n            if current_sink is not None:\n                yield current_sink\n\n            current_g = statement.g\n            current_sink = GenericStatementSink(identifier=current_g)\n\n        assert current_sink is not None\n        current_sink.add(Triple(statement.s, statement.p, statement.o))\n\n    if current_sink is not None:\n        yield current_sink\n</code></pre> <code>guess_options(sink)</code> <p>Guess the serializer options based on the store type.</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def guess_options(sink: GenericStatementSink) -&gt; SerializerOptions:\n    \"\"\"Guess the serializer options based on the store type.\"\"\"\n    logical_type = (\n        jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES\n        if sink.is_triples_sink\n        else jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS\n    )\n    # Generic sink supports both RDF-star and generalized statements by default\n    # as it can handle any term types including quoted triples and generalized RDF terms\n    params = StreamParameters(generalized_statements=True, rdf_star=True)\n    return SerializerOptions(logical_type=logical_type, params=params)\n</code></pre> <code>guess_stream(options, sink)</code> <p>Return an appropriate stream implementation for the given options.</p> <p>Notes: if base(!) logical type is GRAPHS and sink.is_triples_sink is false,     initializes TripleStream</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def guess_stream(options: SerializerOptions, sink: GenericStatementSink) -&gt; Stream:\n    \"\"\"\n    Return an appropriate stream implementation for the given options.\n\n    Notes: if base(!) logical type is GRAPHS and sink.is_triples_sink is false,\n        initializes TripleStream\n    \"\"\"\n    stream_cls: type[Stream]\n    if (\n        options.logical_type % 10\n    ) != jelly.LOGICAL_STREAM_TYPE_GRAPHS and not sink.is_triples_sink:\n        stream_cls = QuadStream\n    else:\n        stream_cls = TripleStream\n    if options is not None:\n        lookup_preset = options.lookup_preset\n    return stream_cls(\n        encoder=GenericSinkTermEncoder(lookup_preset=lookup_preset),\n        options=options,\n    )\n</code></pre> <code>grouped_stream_to_frames(sink_generator, options=None)</code> <p>Transform multiple GenericStatementSinks into Jelly frames.</p> <p>Notes:     One frame per GenericStatementSink.</p> <p>Note: options are guessed if not provided.</p> <p>Args:     sink_generator (Generator[GenericStatementSink]): Generator of         GenericStatementSink to transform.     options (SerializerOptions | None, optional): stream options to use.         Options are guessed based on the sink store type. Defaults to None.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: produced Jelly frames</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def grouped_stream_to_frames(\n    sink_generator: Generator[GenericStatementSink],\n    options: SerializerOptions | None = None,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Transform multiple GenericStatementSinks into Jelly frames.\n\n    Notes:\n        One frame per GenericStatementSink.\n\n    Note: options are guessed if not provided.\n\n    Args:\n        sink_generator (Generator[GenericStatementSink]): Generator of\n            GenericStatementSink to transform.\n        options (SerializerOptions | None, optional): stream options to use.\n            Options are guessed based on the sink store type. Defaults to None.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: produced Jelly frames\n\n    \"\"\"\n    stream = None\n    for sink in sink_generator:\n        if not stream:\n            if options is None:\n                options = guess_options(sink)\n            stream = guess_stream(options, sink)\n        yield from stream_frames(stream, sink)\n</code></pre> <code>grouped_stream_to_file(stream, output_file, **kwargs)</code> <p>Write stream of GenericStatementSink to a binary file.</p> <p>Args:     stream (Generator[GenericStatementSink]): Generator of         GenericStatementSink to serialize.     output_file (IO[bytes]): output buffered writer.     **kwargs (Any): options to pass to stream.</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def grouped_stream_to_file(\n    stream: Generator[GenericStatementSink],\n    output_file: IO[bytes],\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Write stream of GenericStatementSink to a binary file.\n\n    Args:\n        stream (Generator[GenericStatementSink]): Generator of\n            GenericStatementSink to serialize.\n        output_file (IO[bytes]): output buffered writer.\n        **kwargs (Any): options to pass to stream.\n\n    \"\"\"\n    for frame in grouped_stream_to_frames(stream, **kwargs):\n        write_delimited(frame, output_file)\n</code></pre> <code>flat_stream_to_frames(statements, options=None)</code> <p>Serialize a stream of raw GenericStatementSink's triples or quads into Jelly frames.</p> <p>Args:     statements (Generator[Triple | Quad]):       s/p/o triples or s/p/o/g quads to serialize.     options (SerializerOptions | None, optional):         if omitted, guessed based on the first tuple.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: generated frames.</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def flat_stream_to_frames(\n    statements: Generator[Triple | Quad],\n    options: SerializerOptions | None = None,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a stream of raw GenericStatementSink's triples or quads into Jelly frames.\n\n    Args:\n        statements (Generator[Triple | Quad]):\n          s/p/o triples or s/p/o/g quads to serialize.\n        options (SerializerOptions | None, optional):\n            if omitted, guessed based on the first tuple.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: generated frames.\n\n    \"\"\"\n    first = next(statements, None)\n    if first is None:\n        return\n\n    sink = GenericStatementSink()\n    sink.add(first)\n    if options is None:\n        options = guess_options(sink)\n    stream = guess_stream(options, sink)\n\n    combined: Generator[Triple | Quad] | GenericStatementSink = (\n        item for item in chain([first], statements)\n    )\n\n    yield from stream_frames(stream, combined)\n</code></pre> <code>flat_stream_to_file(statements, output_file, options=None)</code> <p>Write Triple or Quad events to a binary file.</p> <p>Args:     statements (Generator[Triple | Quad]): statements to serialize.     output_file (IO[bytes]): output buffered writer.     options (SerializerOptions | None, optional): stream options.</p> Source code in <code>pyjelly/integrations/generic/serialize.py</code> <pre><code>def flat_stream_to_file(\n    statements: Generator[Triple | Quad],\n    output_file: IO[bytes],\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    \"\"\"\n    Write Triple or Quad events to a binary file.\n\n    Args:\n        statements (Generator[Triple | Quad]): statements to serialize.\n        output_file (IO[bytes]): output buffered writer.\n        options (SerializerOptions | None, optional): stream options.\n\n    \"\"\"\n    for frame in flat_stream_to_frames(statements, options):\n        write_delimited(frame, output_file)\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib","title":"<code>rdflib</code>","text":"<p>Modules:</p> Name Description <code>parse</code> <code>serialize</code> <p>Functions:</p> Name Description <code>register_extension_to_rdflib</code> <p>Make rdflib.util.guess_format discover Jelly format.</p>"},{"location":"api/#pyjelly.integrations.rdflib.register_extension_to_rdflib","title":"<code>register_extension_to_rdflib(extension='.jelly')</code>","text":"<p>Make rdflib.util.guess_format discover Jelly format.</p> <p>rdflib.util.guess_format(\"foo.jelly\") register_extension_to_rdflib() rdflib.util.guess_format(\"foo.jelly\") 'jelly'</p> Source code in <code>pyjelly/integrations/rdflib/__init__.py</code> <pre><code>def register_extension_to_rdflib(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Make [rdflib.util.guess_format][] discover Jelly format.\n\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    &gt;&gt;&gt; register_extension_to_rdflib()\n    &gt;&gt;&gt; rdflib.util.guess_format(\"foo.jelly\")\n    'jelly'\n    \"\"\"\n    rdflib.util.SUFFIX_FORMAT_MAP[extension.removeprefix(\".\")] = \"jelly\"\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.parse","title":"<code>parse</code>","text":"<p>Classes:</p> Name Description <code>Triple</code> <p>Describe RDFLib triple.</p> <code>Quad</code> <p>Describe RDFLib quad.</p> <code>Prefix</code> <p>Describe RDF Prefix(i.e, namespace declaration).</p> <code>RDFLibAdapter</code> <p>RDFLib adapter class, is extended by triples and quads implementations.</p> <code>RDFLibTriplesAdapter</code> <p>Triples adapter RDFLib implementation.</p> <code>RDFLibQuadsAdapter</code> <p>Extended RDFLib adapter for the QUADS physical type.</p> <code>RDFLibGraphsAdapter</code> <p>Extension of RDFLibQuadsBaseAdapter for the GRAPHS physical type.</p> <code>RDFLibJellyParser</code> <p>Functions:</p> Name Description <code>parse_triples_stream</code> <p>Parse flat triple stream.</p> <code>parse_quads_stream</code> <p>Parse flat quads stream.</p> <code>parse_jelly_grouped</code> <p>Take jelly file and return generators based on the detected physical type.</p> <code>parse_jelly_to_graph</code> <p>Add statements from Generator to provided Graph/Dataset.</p> <code>parse_jelly_flat</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <code>Triple</code> <p>               Bases: <code>tuple[Node, Node, Node]</code></p> <p>Describe RDFLib triple.</p> <p>Args:     tuple (Node, Node, Node): s/p/o tuple of RDFLib Nodes.</p> <p>Returns:     Triple: triple as tuple.</p> <code>Quad</code> <p>               Bases: <code>tuple[Node, Node, Node, GraphName]</code></p> <p>Describe RDFLib quad.</p> <p>Args:     tuple (Node, Node, Node, GraphName):         s/p/o/g as a tuple of RDFLib nodes and a GraphName,</p> <p>Returns:     Quad: quad as tuple.</p> <code>Prefix</code> <p>               Bases: <code>tuple[str, URIRef]</code></p> <p>Describe RDF Prefix(i.e, namespace declaration).</p> <p>Args:     tuple (str, rdflib.URIRef): expects prefix as a string,         and full namespace URI as Rdflib.URIRef.</p> <p>Returns:     Prefix: prefix as tuple(prefix, iri).</p> <code>RDFLibAdapter(options, parsing_mode=ParsingMode.FLAT)</code> <p>               Bases: <code>Adapter</code></p> <p>RDFLib adapter class, is extended by triples and quads implementations.</p> <p>Args:     Adapter (): abstract adapter class</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def __init__(\n    self, options: ParserOptions, parsing_mode: ParsingMode = ParsingMode.FLAT\n) -&gt; None:\n    self.options = options\n    self.parsing_mode = parsing_mode\n</code></pre> <code>RDFLibTriplesAdapter(options)</code> <p>               Bases: <code>RDFLibAdapter</code></p> <p>Triples adapter RDFLib implementation.</p> <p>Notes: returns triple/namespace declaration as soon as receives them.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>RDFLibQuadsAdapter(options)</code> <p>               Bases: <code>RDFLibQuadsBaseAdapter</code></p> <p>Extended RDFLib adapter for the QUADS physical type.</p> <p>Args:     RDFLibQuadsBaseAdapter (RDFLibAdapter): base quads adapter         (shared with graphs physical type)</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(self, options: ParserOptions) -&gt; None:\n    super().__init__(options=options)\n</code></pre> <code>RDFLibGraphsAdapter(options)</code> <p>               Bases: <code>RDFLibQuadsBaseAdapter</code></p> <p>Extension of RDFLibQuadsBaseAdapter for the GRAPHS physical type.</p> <p>Notes: introduces graph start/end, checks if graph exists.</p> <p>Args:     RDFLibQuadsBaseAdapter (RDFLibAdapter): base adapter for quads management.</p> <p>Raises:     JellyConformanceError: if no graph_start was encountered</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def __init__(\n    self,\n    options: ParserOptions,\n) -&gt; None:\n    super().__init__(options=options)\n    self._graph_id = None\n</code></pre> <code>RDFLibJellyParser</code> <p>               Bases: <code>Parser</code></p> <p>Methods:</p> Name Description <code>parse</code> <p>Parse jelly file into provided RDFLib Graph.</p> <code>parse(source, sink)</code> <p>Parse jelly file into provided RDFLib Graph.</p> <p>Args:     source (InputSource): jelly file as buffered binary stream InputSource obj     sink (Graph): RDFLib Graph</p> <p>Raises:     TypeError: raises error if invalid input</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse(self, source: InputSource, sink: Graph) -&gt; None:\n    \"\"\"\n    Parse jelly file into provided RDFLib Graph.\n\n    Args:\n        source (InputSource): jelly file as buffered binary stream InputSource obj\n        sink (Graph): RDFLib Graph\n\n    Raises:\n        TypeError: raises error if invalid input\n\n    \"\"\"\n    inp = source.getByteStream()  # type: ignore[no-untyped-call]\n    if inp is None:\n        msg = \"expected source to be a stream of bytes\"\n        raise TypeError(msg)\n    parse_jelly_to_graph(\n        inp,\n        graph_factory=lambda: Graph(store=sink.store, identifier=sink.identifier),\n        dataset_factory=lambda: Dataset(store=sink.store),\n    )\n</code></pre> <code>parse_triples_stream(frames, options)</code> <p>Parse flat triple stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options</p> <p>Yields:     Generator[Iterable[Triple | Prefix]]:         Generator of iterables of Triple or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_triples_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n) -&gt; Generator[Iterable[Triple | Prefix]]:\n    \"\"\"\n    Parse flat triple stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n\n    Yields:\n        Generator[Iterable[Triple | Prefix]]:\n            Generator of iterables of Triple or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter = RDFLibTriplesAdapter(options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_quads_stream(frames, options)</code> <p>Parse flat quads stream.</p> <p>Args:     frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames     options (ParserOptions): stream options</p> <p>Yields:     Generator[Iterable[Quad | Prefix]]:         Generator of iterables of Quad or Prefix objects,         one iterable per frame.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_quads_stream(\n    frames: Iterable[jelly.RdfStreamFrame],\n    options: ParserOptions,\n) -&gt; Generator[Iterable[Quad | Prefix]]:\n    \"\"\"\n    Parse flat quads stream.\n\n    Args:\n        frames (Iterable[jelly.RdfStreamFrame]): iterator over stream frames\n        options (ParserOptions): stream options\n\n    Yields:\n        Generator[Iterable[Quad | Prefix]]:\n            Generator of iterables of Quad or Prefix objects,\n            one iterable per frame.\n\n    \"\"\"\n    adapter_class: type[RDFLibQuadsBaseAdapter]\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_QUADS:\n        adapter_class = RDFLibQuadsAdapter\n    else:\n        adapter_class = RDFLibGraphsAdapter\n    adapter = adapter_class(options=options)\n    decoder = Decoder(adapter=adapter)\n    for frame in frames:\n        yield decoder.iter_rows(frame)\n    return\n</code></pre> <code>parse_jelly_grouped(inp, graph_factory=lambda: Graph(), dataset_factory=lambda: Dataset(), *, logical_type_strict=False)</code> <p>Take jelly file and return generators based on the detected physical type.</p> <p>Yields one graph/dataset per frame.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream     graph_factory (Callable): lambda to construct a Graph.         By default creates an empty in-memory Graph,         but you can pass something else here.     dataset_factory (Callable): lambda to construct a Dataset.         By default creates an empty in-memory Dataset,         but you can pass something else here.     logical_type_strict (bool): If True, validate the logical type in         stream options and require a grouped logical type. Otherwise, only the         physical type is used to route parsing.</p> <p>Raises:     NotImplementedError: is raised if a physical type is not implemented</p> <p>Yields:     Generator[Graph] | Generator[Dataset]:         returns generators for graphs/datasets based on the type of input</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_grouped(\n    inp: IO[bytes],\n    graph_factory: Callable[[], Graph] = lambda: Graph(),\n    dataset_factory: Callable[[], Dataset] = lambda: Dataset(),\n    *,\n    logical_type_strict: bool = False,\n) -&gt; Generator[Graph] | Generator[Dataset]:\n    \"\"\"\n    Take jelly file and return generators based on the detected physical type.\n\n    Yields one graph/dataset per frame.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream\n        graph_factory (Callable): lambda to construct a Graph.\n            By default creates an empty in-memory Graph,\n            but you can pass something else here.\n        dataset_factory (Callable): lambda to construct a Dataset.\n            By default creates an empty in-memory Dataset,\n            but you can pass something else here.\n        logical_type_strict (bool): If True, validate the *logical* type in\n            stream options and require a grouped logical type. Otherwise, only the\n            physical type is used to route parsing.\n\n\n\n    Raises:\n        NotImplementedError: is raised if a physical type is not implemented\n\n    Yields:\n        Generator[Graph] | Generator[Dataset]:\n            returns generators for graphs/datasets based on the type of input\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (\n        st is None\n        or st.logical_type == jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED\n        or st.flat\n    ):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected GROUPED logical type, got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for graph in parse_triples_stream(\n            frames=frames,\n            options=options,\n        ):\n            sink = graph_factory()\n            for graph_item in graph:\n                if isinstance(graph_item, Prefix):\n                    sink.bind(graph_item.prefix, graph_item.iri)\n                else:\n                    sink.add(graph_item)\n            yield sink\n        return\n    elif options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for dataset in parse_quads_stream(\n            frames=frames,\n            options=options,\n        ):\n            sink = dataset_factory()\n            for item in dataset:\n                if isinstance(item, Prefix):\n                    sink.bind(item.prefix, item.iri)\n                else:\n                    s, p, o, graph_name = item\n                    context = sink.get_context(graph_name)\n                    sink.add((s, p, o, context))\n            yield sink\n        return\n\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre> <code>parse_jelly_to_graph(inp, graph_factory=lambda: Graph(), dataset_factory=lambda: Dataset())</code> <p>Add statements from Generator to provided Graph/Dataset.</p> <p>Args:     inp (IO[bytes]): input jelly stream.     graph_factory (Callable[[], Graph]): factory to create Graph.         By default creates an empty in-memory Graph,         but you can pass something else here.     dataset_factory (Callable[[], Dataset]): factory to create Dataset.         By default creates an empty in-memory Dataset,         but you can pass something else here.</p> <p>Returns:     Dataset | Graph: Dataset or Graph with statements.</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_to_graph(\n    inp: IO[bytes],\n    graph_factory: Callable[[], Graph] = lambda: Graph(),\n    dataset_factory: Callable[[], Dataset] = lambda: Dataset(),\n) -&gt; Graph | Dataset:\n    \"\"\"\n    Add statements from Generator to provided Graph/Dataset.\n\n    Args:\n        inp (IO[bytes]): input jelly stream.\n        graph_factory (Callable[[], Graph]): factory to create Graph.\n            By default creates an empty in-memory Graph,\n            but you can pass something else here.\n        dataset_factory (Callable[[], Dataset]): factory to create Dataset.\n            By default creates an empty in-memory Dataset,\n            but you can pass something else here.\n\n    Returns:\n        Dataset | Graph: Dataset or Graph with statements.\n\n    \"\"\"\n    options, frames = get_options_and_frames(inp)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        sink = graph_factory()\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        quad_sink = dataset_factory()\n        sink = quad_sink\n\n    for item in parse_jelly_flat(inp=inp, frames=frames, options=options):\n        if isinstance(item, Prefix):\n            sink.bind(item.prefix, item.iri)\n        if isinstance(item, Triple):\n            sink.add(item)\n        if isinstance(item, Quad):\n            s, p, o, graph_name = item\n            context = quad_sink.get_context(graph_name)\n            quad_sink.add((s, p, o, context))\n    return sink\n</code></pre> <code>parse_jelly_flat(inp, frames=None, options=None, *, logical_type_strict=False)</code> <p>Parse jelly file with FLAT logical type into a Generator of stream events.</p> <p>Args:     inp (IO[bytes]): input jelly buffered binary stream.     frames (Iterable[jelly.RdfStreamFrame | None):         jelly frames if read before.     options (ParserOptions | None): stream options         if read before.     logical_type_strict (bool): If True, validate the logical type in         stream options and require FLAT_(TRIPLES|QUADS). Otherwise, only the         physical type is used to route parsing.</p> <p>Raises:     NotImplementedError: if physical type is not supported</p> <p>Yields:     Generator[Statement | Prefix]: Generator of stream events</p> Source code in <code>pyjelly/integrations/rdflib/parse.py</code> <pre><code>def parse_jelly_flat(\n    inp: IO[bytes],\n    frames: Iterable[jelly.RdfStreamFrame] | None = None,\n    options: ParserOptions | None = None,\n    *,\n    logical_type_strict: bool = False,\n) -&gt; Generator[Statement | Prefix]:\n    \"\"\"\n    Parse jelly file with FLAT logical type into a Generator of stream events.\n\n    Args:\n        inp (IO[bytes]): input jelly buffered binary stream.\n        frames (Iterable[jelly.RdfStreamFrame | None):\n            jelly frames if read before.\n        options (ParserOptions | None): stream options\n            if read before.\n        logical_type_strict (bool): If True, validate the *logical* type in\n            stream options and require FLAT_(TRIPLES|QUADS). Otherwise, only the\n            physical type is used to route parsing.\n\n\n    Raises:\n        NotImplementedError: if physical type is not supported\n\n    Yields:\n        Generator[Statement | Prefix]: Generator of stream events\n\n    \"\"\"\n    if frames is None or options is None:\n        options, frames = get_options_and_frames(inp)\n\n    st = getattr(options, \"stream_types\", None)\n    if logical_type_strict and (st is None or not st.flat):\n        lt_name = (\n            \"UNSPECIFIED\"\n            if st is None\n            else jelly.LogicalStreamType.Name(st.logical_type)\n        )\n        msg = (\n            \"strict logical type check requires options.stream_types\"\n            if st is None\n            else f\"expected FLAT logical type (TRIPLES/QUADS), got {lt_name}\"\n        )\n        raise JellyConformanceError(msg)\n\n    if options.stream_types.physical_type == jelly.PHYSICAL_STREAM_TYPE_TRIPLES:\n        for triples in parse_triples_stream(frames=frames, options=options):\n            yield from triples\n        return\n    if options.stream_types.physical_type in (\n        jelly.PHYSICAL_STREAM_TYPE_QUADS,\n        jelly.PHYSICAL_STREAM_TYPE_GRAPHS,\n    ):\n        for quads in parse_quads_stream(\n            frames=frames,\n            options=options,\n        ):\n            yield from quads\n        return\n    physical_type_name = jelly.PhysicalStreamType.Name(\n        options.stream_types.physical_type\n    )\n    msg = f\"the stream type {physical_type_name} is not supported \"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/#pyjelly.integrations.rdflib.serialize","title":"<code>serialize</code>","text":"<p>Classes:</p> Name Description <code>RDFLibTermEncoder</code> <code>RDFLibJellySerializer</code> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Functions:</p> Name Description <code>triples_stream_frames</code> <p>Serialize a Graph/Dataset into jelly frames.</p> <code>quads_stream_frames</code> <p>Serialize a Dataset into jelly frames.</p> <code>graphs_stream_frames</code> <p>Serialize a Dataset into jelly frames as a stream of graphs.</p> <code>guess_options</code> <p>Guess the serializer options based on the store type.</p> <code>guess_stream</code> <p>Return an appropriate stream implementation for the given options.</p> <code>grouped_stream_to_frames</code> <p>Transform Graphs/Datasets into Jelly frames, one frame per Graph/Dataset.</p> <code>grouped_stream_to_file</code> <p>Write stream of Graphs/Datasets to a binary file.</p> <code>flat_stream_to_frames</code> <p>Serialize a stream of raw triples or quads into Jelly frames.</p> <code>flat_stream_to_file</code> <p>Write Triple or Quad events to a binary file in Jelly flat format.</p> <code>RDFLibTermEncoder(lookup_preset=None)</code> <p>               Bases: <code>TermEncoder</code></p> <p>Methods:</p> Name Description <code>encode_spo</code> <p>Encode s/p/o term based on its RDFLib object.</p> <code>encode_graph</code> <p>Encode graph name term based on its RDFLib object.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def __init__(\n    self,\n    lookup_preset: options.LookupPreset | None = None,\n) -&gt; None:\n    if lookup_preset is None:\n        lookup_preset = options.LookupPreset()\n    self.lookup_preset = lookup_preset\n    self.names = LookupEncoder(lookup_size=lookup_preset.max_names)\n    self.prefixes = LookupEncoder(lookup_size=lookup_preset.max_prefixes)\n    self.datatypes = LookupEncoder(lookup_size=lookup_preset.max_datatypes)\n</code></pre> <code>encode_spo(term, slot, statement)</code> <p>Encode s/p/o term based on its RDFLib object.</p> <p>Args:     term (object): term to encode     slot (Slot): its place in statement.     statement (Statement): Triple/Quad message to fill with s/p/o terms.</p> <p>Returns:     Rows: encoded extra rows</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def encode_spo(self, term: object, slot: Slot, statement: Statement) -&gt; Rows:\n    \"\"\"\n    Encode s/p/o term based on its RDFLib object.\n\n    Args:\n        term (object): term to encode\n        slot (Slot): its place in statement.\n        statement (Statement): Triple/Quad message to fill with s/p/o terms.\n\n    Returns:\n        Rows: encoded extra rows\n\n    \"\"\"\n    if isinstance(term, rdflib.URIRef):\n        iri = self.get_iri_field(statement, slot)\n        return self.encode_iri(term, iri)\n\n    if isinstance(term, rdflib.Literal):\n        literal = self.get_literal_field(statement, slot)\n        return self.encode_literal(\n            lex=str(term),\n            language=term.language,\n            # `datatype` is cast to `str` explicitly because\n            # `URIRef.__eq__` overrides `str.__eq__` in an incompatible manner\n            datatype=term.datatype and str(term.datatype),\n            literal=literal,\n        )\n\n    if isinstance(term, rdflib.BNode):\n        self.set_bnode_field(statement, slot, str(term))\n        return ()\n\n    return super().encode_spo(term, slot, statement)  # error if not handled\n</code></pre> <code>encode_graph(term, statement)</code> <p>Encode graph name term based on its RDFLib object.</p> <p>Args:     term (object): term to encode     statement (HasGraph): Quad/GraphStart message to fill g_{} in.</p> <p>Returns:     Rows: encoded extra rows</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def encode_graph(self, term: object, statement: HasGraph) -&gt; Rows:\n    \"\"\"\n    Encode graph name term based on its RDFLib object.\n\n    Args:\n        term (object): term to encode\n        statement (HasGraph): Quad/GraphStart message to fill g_{} in.\n\n    Returns:\n        Rows: encoded extra rows\n\n    \"\"\"\n    if term == DATASET_DEFAULT_GRAPH_ID:\n        return self.encode_default_graph(statement.g_default_graph)\n\n    if isinstance(term, rdflib.URIRef):\n        return self.encode_iri(term, statement.g_iri)\n\n    if isinstance(term, rdflib.BNode):\n        statement.g_bnode = str(term)\n        return ()\n    return super().encode_graph(term, statement)  # error if not handled\n</code></pre> <code>RDFLibJellySerializer(store)</code> <p>               Bases: <code>Serializer</code></p> <p>RDFLib serializer for writing graphs in Jelly RDF stream format.</p> <p>Handles streaming RDF terms into Jelly frames using internal encoders. Supports only graphs and datasets (not quoted graphs).</p> <p>Methods:</p> Name Description <code>serialize</code> <p>Serialize self.store content to Jelly format.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def __init__(self, store: Graph) -&gt; None:\n    if isinstance(store, QuotedGraph):\n        msg = \"N3 format is not supported\"\n        raise NotImplementedError(msg)\n    super().__init__(store)\n</code></pre> <code>serialize(out, /, *, stream=None, options=None, **unused)</code> <p>Serialize self.store content to Jelly format.</p> <p>Args:     out (IO[bytes]): output buffered writer     stream (Stream | None, optional): Jelly stream object. Defaults to None.     options (SerializerOptions | None, optional): Serializer options         if defined beforehand, e.g., read from a separate file.         Defaults to None.     **unused(Any): unused args for RDFLib serialize</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@override\ndef serialize(  # type: ignore[override]\n    self,\n    out: IO[bytes],\n    /,\n    *,\n    stream: Stream | None = None,\n    options: SerializerOptions | None = None,\n    **unused: Any,\n) -&gt; None:\n    \"\"\"\n    Serialize self.store content to Jelly format.\n\n    Args:\n        out (IO[bytes]): output buffered writer\n        stream (Stream | None, optional): Jelly stream object. Defaults to None.\n        options (SerializerOptions | None, optional): Serializer options\n            if defined beforehand, e.g., read from a separate file.\n            Defaults to None.\n        **unused(Any): unused args for RDFLib serialize\n\n    \"\"\"\n    if options is None:\n        options = guess_options(self.store)\n    if stream is None:\n        stream = guess_stream(options, self.store)\n    write = write_delimited if stream.options.params.delimited else write_single\n    for stream_frame in stream_frames(stream, self.store):\n        write(stream_frame, out)\n</code></pre> <code>triples_stream_frames(stream, data)</code> <p>Serialize a Graph/Dataset into jelly frames.</p> <p>Args:     stream (TripleStream): stream that specifies triples processing     data (Graph | Dataset | Generator[Triple]):         Graph/Dataset/Statements to serialize.</p> <p>Notes:     if Dataset is given, its graphs are unpacked and iterated over     if flow is GraphsFrameFlow, emits a frame per graph.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(TripleStream)\ndef triples_stream_frames(\n    stream: TripleStream,\n    data: Graph | Dataset | Generator[Triple],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Graph/Dataset into jelly frames.\n\n    Args:\n        stream (TripleStream): stream that specifies triples processing\n        data (Graph | Dataset | Generator[Triple]):\n            Graph/Dataset/Statements to serialize.\n\n    Notes:\n        if Dataset is given, its graphs are unpacked and iterated over\n        if flow is GraphsFrameFlow, emits a frame per graph.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    stream.enroll()\n    if isinstance(data, Graph) and stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)\n\n    graphs = (data,) if not isinstance(data, Dataset) else data.graphs()\n    for graph in graphs:\n        for terms in graph:\n            if frame := stream.triple(terms):\n                yield frame\n        if frame := stream.flow.frame_from_graph():\n            yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>quads_stream_frames(stream, data)</code> <p>Serialize a Dataset into jelly frames.</p> <p>Notes:     Emits one frame per dataset if flow is of DatasetsFrameFlow.</p> <p>Args:     stream (QuadStream): stream that specifies quads processing     data (Dataset | Generator[Quad]): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(QuadStream)\ndef quads_stream_frames(\n    stream: QuadStream,\n    data: Dataset | Generator[Quad],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Dataset into jelly frames.\n\n    Notes:\n        Emits one frame per dataset if flow is of DatasetsFrameFlow.\n\n    Args:\n        stream (QuadStream): stream that specifies quads processing\n        data (Dataset | Generator[Quad]): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)  # type: ignore[arg-type]\n\n    iterator: Generator[Quad, None, None]\n    if isinstance(data, Dataset):\n        iterator = cast(Generator[Quad, None, None], data.quads())\n    else:\n        iterator = data\n\n    for terms in iterator:\n        if frame := stream.quad(terms):\n            yield frame\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>graphs_stream_frames(stream, data)</code> <p>Serialize a Dataset into jelly frames as a stream of graphs.</p> <p>Notes:     If flow of DatasetsFrameFlow type, the whole dataset     will be encoded into one frame.</p> <p>Args:     stream (GraphStream): stream that specifies graphs processing     data (Dataset | Generator[Quad]): Dataset to serialize.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>@stream_frames.register(GraphStream)\ndef graphs_stream_frames(\n    stream: GraphStream,\n    data: Dataset | Generator[Quad],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a Dataset into jelly frames as a stream of graphs.\n\n    Notes:\n        If flow of DatasetsFrameFlow type, the whole dataset\n        will be encoded into one frame.\n\n    Args:\n        stream (GraphStream): stream that specifies graphs processing\n        data (Dataset | Generator[Quad]): Dataset to serialize.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames\n\n    \"\"\"\n    stream.enroll()\n    if stream.options.params.namespace_declarations:\n        namespace_declarations(data, stream)  # type: ignore[arg-type]\n\n    if isinstance(data, Dataset):\n        graphs = data.graphs()\n    else:\n        ds = Dataset()\n        for quad in data:\n            ctx = ds.get_context(quad.g)\n            ctx.add((quad.s, quad.p, quad.o))\n        graphs = ds.graphs()\n\n    for graph in graphs:\n        yield from stream.graph(graph_id=graph.identifier, graph=graph)\n\n    if frame := stream.flow.frame_from_dataset():\n        yield frame\n    if stream.stream_types.flat and (frame := stream.flow.to_stream_frame()):\n        yield frame\n</code></pre> <code>guess_options(sink)</code> <p>Guess the serializer options based on the store type.</p> <p>guess_options(Graph()).logical_type 1 guess_options(Dataset()).logical_type 2</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_options(sink: Graph | Dataset) -&gt; SerializerOptions:\n    \"\"\"\n    Guess the serializer options based on the store type.\n\n    &gt;&gt;&gt; guess_options(Graph()).logical_type\n    1\n    &gt;&gt;&gt; guess_options(Dataset()).logical_type\n    2\n    \"\"\"\n    logical_type = (\n        jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS\n        if isinstance(sink, Dataset)\n        else jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES\n    )\n    # RDFLib doesn't support RDF-star and generalized statements by default\n    # as it requires specific handling for quoted triples and non-standard RDF terms\n    params = StreamParameters(generalized_statements=False, rdf_star=False)\n    return SerializerOptions(logical_type=logical_type, params=params)\n</code></pre> <code>guess_stream(options, sink)</code> <p>Return an appropriate stream implementation for the given options.</p> <p>Notes: if base(!) logical type is GRAPHS and Dataset is given,     initializes TripleStream</p> <p>graph_ser = RDFLibJellySerializer(Graph()) ds_ser = RDFLibJellySerializer(Dataset())</p> <p>type(guess_stream(guess_options(graph_ser.store), graph_ser.store))  type(guess_stream(guess_options(ds_ser.store), ds_ser.store))  Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def guess_stream(options: SerializerOptions, sink: Graph | Dataset) -&gt; Stream:\n    \"\"\"\n    Return an appropriate stream implementation for the given options.\n\n    Notes: if base(!) logical type is GRAPHS and Dataset is given,\n        initializes TripleStream\n\n    &gt;&gt;&gt; graph_ser = RDFLibJellySerializer(Graph())\n    &gt;&gt;&gt; ds_ser = RDFLibJellySerializer(Dataset())\n\n    &gt;&gt;&gt; type(guess_stream(guess_options(graph_ser.store), graph_ser.store))\n    &lt;class 'pyjelly.serialize.streams.TripleStream'&gt;\n    &gt;&gt;&gt; type(guess_stream(guess_options(ds_ser.store), ds_ser.store))\n    &lt;class 'pyjelly.serialize.streams.QuadStream'&gt;\n    \"\"\"\n    stream_cls: type[Stream]\n    if (options.logical_type % 10) != jelly.LOGICAL_STREAM_TYPE_GRAPHS and isinstance(\n        sink, Dataset\n    ):\n        stream_cls = QuadStream\n    else:\n        stream_cls = TripleStream\n    return stream_cls.for_rdflib(options=options)\n</code></pre> <code>grouped_stream_to_frames(sink_generator, options=None)</code> <p>Transform Graphs/Datasets into Jelly frames, one frame per Graph/Dataset.</p> <p>Note: options are guessed if not provided.</p> <p>Args:     sink_generator (Generator[Graph] | Generator[Dataset]): Generator of         Graphs/Dataset to transform.     options (SerializerOptions | None, optional): stream options to use.         Options are guessed based on the sink store type. Defaults to None.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: produced Jelly frames</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def grouped_stream_to_frames(\n    sink_generator: Generator[Graph] | Generator[Dataset],\n    options: SerializerOptions | None = None,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Transform Graphs/Datasets into Jelly frames, one frame per Graph/Dataset.\n\n    Note: options are guessed if not provided.\n\n    Args:\n        sink_generator (Generator[Graph] | Generator[Dataset]): Generator of\n            Graphs/Dataset to transform.\n        options (SerializerOptions | None, optional): stream options to use.\n            Options are guessed based on the sink store type. Defaults to None.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: produced Jelly frames\n\n    \"\"\"\n    stream = None\n    for sink in sink_generator:\n        if not stream:\n            if options is None:\n                options = guess_options(sink)\n            stream = guess_stream(options, sink)\n        yield from stream_frames(stream, sink)\n</code></pre> <code>grouped_stream_to_file(stream, output_file, **kwargs)</code> <p>Write stream of Graphs/Datasets to a binary file.</p> <p>Args:     stream (Generator[Graph] | Generator[Dataset]): Generator of         Graphs/Dataset to transform.     output_file (IO[bytes]): output buffered writer.     **kwargs (Any): options to pass to stream.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def grouped_stream_to_file(\n    stream: Generator[Graph] | Generator[Dataset],\n    output_file: IO[bytes],\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Write stream of Graphs/Datasets to a binary file.\n\n    Args:\n        stream (Generator[Graph] | Generator[Dataset]): Generator of\n            Graphs/Dataset to transform.\n        output_file (IO[bytes]): output buffered writer.\n        **kwargs (Any): options to pass to stream.\n\n    \"\"\"\n    for frame in grouped_stream_to_frames(stream, **kwargs):\n        write_delimited(frame, output_file)\n</code></pre> <code>flat_stream_to_frames(statements, options=None)</code> <p>Serialize a stream of raw triples or quads into Jelly frames.</p> <p>Args:     statements (Generator[Triple | Quad]):       s/p/o triples or s/p/o/g quads to serialize.     options (SerializerOptions | None, optional):         if omitted, guessed based on the first tuple.</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: generated frames.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def flat_stream_to_frames(\n    statements: Generator[Triple | Quad],\n    options: SerializerOptions | None = None,\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Serialize a stream of raw triples or quads into Jelly frames.\n\n    Args:\n        statements (Generator[Triple | Quad]):\n          s/p/o triples or s/p/o/g quads to serialize.\n        options (SerializerOptions | None, optional):\n            if omitted, guessed based on the first tuple.\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: generated frames.\n\n    \"\"\"\n    first = next(statements, None)\n    if first is None:\n        return\n\n    sink = Dataset() if len(first) == QUAD_ARITY else Graph()\n    if options is None:\n        options = guess_options(sink)\n    stream = guess_stream(options, sink)\n\n    combined: Generator[Triple | Quad] | Graph = (\n        item for item in chain([first], statements)\n    )\n\n    yield from stream_frames(stream, combined)\n</code></pre> <code>flat_stream_to_file(statements, output_file, options=None)</code> <p>Write Triple or Quad events to a binary file in Jelly flat format.</p> <p>Args:     statements (Generator[Triple | Quad]): statements to serialize.     output_file (IO[bytes]): output buffered writer.     options (SerializerOptions | None, optional): stream options.</p> Source code in <code>pyjelly/integrations/rdflib/serialize.py</code> <pre><code>def flat_stream_to_file(\n    statements: Generator[Triple | Quad],\n    output_file: IO[bytes],\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    \"\"\"\n    Write Triple or Quad events to a binary file in Jelly flat format.\n\n    Args:\n        statements (Generator[Triple | Quad]): statements to serialize.\n        output_file (IO[bytes]): output buffered writer.\n        options (SerializerOptions | None, optional): stream options.\n\n    \"\"\"\n    for frame in flat_stream_to_frames(statements, options):\n        write_delimited(frame, output_file)\n</code></pre>"},{"location":"api/#pyjelly.jelly","title":"<code>jelly</code>","text":"<p>Modules:</p> Name Description <code>rdf_pb2</code> <p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.jelly.rdf_pb2","title":"<code>rdf_pb2</code>","text":"<p>Generated protocol buffer code.</p>"},{"location":"api/#pyjelly.options","title":"<code>options</code>","text":"<p>Classes:</p> Name Description <code>StreamTypes</code> <p>Functions:</p> Name Description <code>register_mimetypes</code> <p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>Attributes:</p> Name Type Description <code>INTEGRATION_SIDE_EFFECTS</code> <code>bool</code> <p>Whether to allow integration module imports to trigger side effects.</p>"},{"location":"api/#pyjelly.options.INTEGRATION_SIDE_EFFECTS","title":"<code>INTEGRATION_SIDE_EFFECTS = True</code>","text":"<p>Whether to allow integration module imports to trigger side effects.</p> <p>These side effects are cheap and may include populating some registries for guessing the defaults for external integrations that work with Jelly.</p>"},{"location":"api/#pyjelly.options.StreamTypes","title":"<code>StreamTypes(physical_type=jelly.PHYSICAL_STREAM_TYPE_UNSPECIFIED, logical_type=jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED)</code>","text":"<p>Methods:</p> Name Description <code>__repr__</code> <p>Return the representation of StreamTypes.</p>"},{"location":"api/#pyjelly.options.StreamTypes.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the representation of StreamTypes.</p> <p>repr(StreamTypes(9999, 8888)) 'StreamTypes(9999, 8888)'</p> Source code in <code>pyjelly/options.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return the representation of StreamTypes.\n\n    &gt;&gt;&gt; repr(StreamTypes(9999, 8888))\n    'StreamTypes(9999, 8888)'\n    \"\"\"\n    with suppress(ValueError):\n        physical_type_name = jelly.PhysicalStreamType.Name(self.physical_type)\n        logical_type_name = jelly.LogicalStreamType.Name(self.logical_type)\n        return f\"StreamTypes({physical_type_name}, {logical_type_name})\"\n    return f\"StreamTypes({self.physical_type}, {self.logical_type})\"\n</code></pre>"},{"location":"api/#pyjelly.options.register_mimetypes","title":"<code>register_mimetypes(extension='.jelly')</code>","text":"<p>Associate files that have Jelly extension with Jelly MIME types.</p> <p>register_mimetypes() mimetypes.guess_type(\"out.jelly\") ('application/x-jelly-rdf', None)</p> Source code in <code>pyjelly/options.py</code> <pre><code>def register_mimetypes(extension: str = \".jelly\") -&gt; None:\n    \"\"\"\n    Associate files that have Jelly extension with Jelly MIME types.\n\n    &gt;&gt;&gt; register_mimetypes()\n    &gt;&gt;&gt; mimetypes.guess_type(\"out.jelly\")\n    ('application/x-jelly-rdf', None)\n    \"\"\"\n    for mimetype in MIMETYPES:\n        mimetypes.add_type(mimetype, extension)\n</code></pre>"},{"location":"api/#pyjelly.parse","title":"<code>parse</code>","text":"<p>Modules:</p> Name Description <code>decode</code> <code>ioutils</code> <code>lookup</code>"},{"location":"api/#pyjelly.parse.decode","title":"<code>decode</code>","text":"<p>Classes:</p> Name Description <code>ParsingMode</code> <p>Specifies how jelly frames should be treated.</p> <code>Decoder</code> <p>Functions:</p> Name Description <code>options_from_frame</code> <p>Fill stream options based on the options row.</p>"},{"location":"api/#pyjelly.parse.decode.ParsingMode","title":"<code>ParsingMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specifies how jelly frames should be treated.</p> <p>Modes: FLAT     Yield all frames as one Graph or Dataset. GROUPED     Yield one Graph/Dataset per frame (grouped parsing).</p>"},{"location":"api/#pyjelly.parse.decode.Decoder","title":"<code>Decoder(adapter)</code>","text":"<p>Initializes decoder with a lookup tables with preset sizes, integration-dependent adapter and empty repeated terms dictionary.</p> <p>Args:     adapter (Adapter): integration-dependent adapter that specifies terms     conversion to specific objects, framing,     namespace declarations, and graphs/datasets forming.</p> <p>Methods:</p> Name Description <code>iter_rows</code> <p>Iterate through rows in the frame.</p> <code>decode_row</code> <p>Decode a row based on its type.</p> <code>ingest_prefix_entry</code> <p>Update prefix lookup table based on the table entry.</p> <code>ingest_name_entry</code> <p>Update name lookup table based on the table entry.</p> <code>ingest_datatype_entry</code> <p>Update datatype lookup table based on the table entry.</p> <code>decode_term</code> <p>Decode a term based on its type: IRI/literal/BN/default graph.</p> <code>decode_iri</code> <p>Decode RdfIri message to IRI using a custom adapter.</p> <code>decode_bnode</code> <p>Decode string message to blank node (BN) using a custom adapter.</p> <code>decode_literal</code> <p>Decode RdfLiteral to literal based on custom adapter implementation.</p> <code>decode_statement</code> <p>Decode a triple/quad message.</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def __init__(self, adapter: Adapter) -&gt; None:\n    \"\"\"\n    Initialize decoder.\n\n    Initializes decoder with a lookup tables with preset sizes,\n    integration-dependent adapter and empty repeated terms dictionary.\n\n    Args:\n        adapter (Adapter): integration-dependent adapter that specifies terms\n        conversion to specific objects, framing,\n        namespace declarations, and graphs/datasets forming.\n\n    \"\"\"\n    self.adapter = adapter\n    self.names = LookupDecoder(lookup_size=self.options.lookup_preset.max_names)\n    self.prefixes = LookupDecoder(\n        lookup_size=self.options.lookup_preset.max_prefixes\n    )\n    self.datatypes = LookupDecoder(\n        lookup_size=self.options.lookup_preset.max_datatypes\n    )\n    self.repeated_terms: dict[str, jelly.RdfIri | str | jelly.RdfLiteral] = {}\n</code></pre> <code>iter_rows(frame)</code> <p>Iterate through rows in the frame.</p> <p>Args:     frame (jelly.RdfStreamFrame): jelly frame Yields:     Iterator[Any]: decoded rows</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def iter_rows(self, frame: jelly.RdfStreamFrame) -&gt; Iterator[Any]:\n    \"\"\"\n    Iterate through rows in the frame.\n\n    Args:\n        frame (jelly.RdfStreamFrame): jelly frame\n    Yields:\n        Iterator[Any]: decoded rows\n\n    \"\"\"\n    for row_owner in frame.rows:\n        row = getattr(row_owner, row_owner.WhichOneof(\"row\"))\n        decoded_row = self.decode_row(row)\n        if isinstance(\n            row, (jelly.RdfTriple, jelly.RdfQuad, jelly.RdfNamespaceDeclaration)\n        ):\n            yield decoded_row\n</code></pre> <code>decode_row(row)</code> <p>Decode a row based on its type.</p> <p>Notes: uses custom adapters to decode triples/quads, namespace declarations,        graph start/end.</p> <p>Args:     row (Any): protobuf row message</p> <p>Raises:     TypeError: raises error if this type of protobuf message does not have                a respective handler</p> <p>Returns:     Any | None: decoded row -                 result from calling decode_row (row type appropriate handler)</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_row(self, row: Any) -&gt; Any | None:\n    \"\"\"\n    Decode a row based on its type.\n\n    Notes: uses custom adapters to decode triples/quads, namespace declarations,\n           graph start/end.\n\n    Args:\n        row (Any): protobuf row message\n\n    Raises:\n        TypeError: raises error if this type of protobuf message does not have\n                   a respective handler\n\n    Returns:\n        Any | None: decoded row -\n                    result from calling decode_row (row type appropriate handler)\n\n    \"\"\"\n    try:\n        decode_row = self.row_handlers[type(row)]\n    except KeyError:\n        msg = f\"decoder not implemented for {type(row)}\"\n        raise TypeError(msg) from None\n    return decode_row(self, row)\n</code></pre> <code>ingest_prefix_entry(entry)</code> <p>Update prefix lookup table based on the table entry.</p> <p>Args:     entry (jelly.RdfPrefixEntry): prefix message, containing id and value</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def ingest_prefix_entry(self, entry: jelly.RdfPrefixEntry) -&gt; None:\n    \"\"\"\n    Update prefix lookup table based on the table entry.\n\n    Args:\n        entry (jelly.RdfPrefixEntry): prefix message, containing id and value\n\n    \"\"\"\n    self.prefixes.assign_entry(index=entry.id, value=entry.value)\n</code></pre> <code>ingest_name_entry(entry)</code> <p>Update name lookup table based on the table entry.</p> <p>Args:     entry (jelly.RdfNameEntry): name message, containing id and value</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def ingest_name_entry(self, entry: jelly.RdfNameEntry) -&gt; None:\n    \"\"\"\n    Update name lookup table based on the table entry.\n\n    Args:\n        entry (jelly.RdfNameEntry): name message, containing id and value\n\n    \"\"\"\n    self.names.assign_entry(index=entry.id, value=entry.value)\n</code></pre> <code>ingest_datatype_entry(entry)</code> <p>Update datatype lookup table based on the table entry.</p> <p>Args:     entry (jelly.RdfDatatypeEntry): name message, containing id and value</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def ingest_datatype_entry(self, entry: jelly.RdfDatatypeEntry) -&gt; None:\n    \"\"\"\n    Update datatype lookup table based on the table entry.\n\n    Args:\n        entry (jelly.RdfDatatypeEntry): name message, containing id and value\n\n    \"\"\"\n    self.datatypes.assign_entry(index=entry.id, value=entry.value)\n</code></pre> <code>decode_term(term)</code> <p>Decode a term based on its type: IRI/literal/BN/default graph.</p> <p>Notes: requires a custom adapter with implemented methods for terms decoding.</p> <p>Args:     term (Any): IRI/literal/BN(string)/Default graph message</p> <p>Raises:     TypeError: raises error if no handler for the term is found</p> <p>Returns:     Any: decoded term (currently, rdflib objects, e.g., rdflib.term.URIRef)</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_term(self, term: Any) -&gt; Any:\n    \"\"\"\n    Decode a term based on its type: IRI/literal/BN/default graph.\n\n    Notes: requires a custom adapter with implemented methods for terms decoding.\n\n    Args:\n        term (Any): IRI/literal/BN(string)/Default graph message\n\n    Raises:\n        TypeError: raises error if no handler for the term is found\n\n    Returns:\n        Any: decoded term (currently, rdflib objects, e.g., rdflib.term.URIRef)\n\n    \"\"\"\n    try:\n        decode_term = self.term_handlers[type(term)]\n    except KeyError:\n        msg = f\"decoder not implemented for {type(term)}\"\n        raise TypeError(msg) from None\n    return decode_term(self, term)\n</code></pre> <code>decode_iri(iri)</code> <p>Decode RdfIri message to IRI using a custom adapter.</p> <p>Args:     iri (jelly.RdfIri): RdfIri message</p> <p>Returns:     Any: IRI, based on adapter implementation, e.g., rdflib.term.URIRef</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_iri(self, iri: jelly.RdfIri) -&gt; Any:\n    \"\"\"\n    Decode RdfIri message to IRI using a custom adapter.\n\n    Args:\n        iri (jelly.RdfIri): RdfIri message\n\n    Returns:\n        Any: IRI, based on adapter implementation, e.g., rdflib.term.URIRef\n\n    \"\"\"\n    name = self.names.decode_name_term_index(iri.name_id)\n    prefix = self.prefixes.decode_prefix_term_index(iri.prefix_id)\n    return self.adapter.iri(iri=prefix + name)\n</code></pre> <code>decode_bnode(bnode)</code> <p>Decode string message to blank node (BN) using a custom adapter.</p> <p>Args:     bnode (str): blank node id</p> <p>Returns:     Any: blank node object from the custom adapter</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_bnode(self, bnode: str) -&gt; Any:\n    \"\"\"\n    Decode string message to blank node (BN) using a custom adapter.\n\n    Args:\n        bnode (str): blank node id\n\n    Returns:\n        Any: blank node object from the custom adapter\n\n    \"\"\"\n    return self.adapter.bnode(bnode)\n</code></pre> <code>decode_literal(literal)</code> <p>Decode RdfLiteral to literal based on custom adapter implementation.</p> <p>Notes: checks for langtag existence;        for datatype checks for non-zero table size and datatype field presence</p> <p>Args:     literal (jelly.RdfLiteral): RdfLiteral message</p> <p>Returns:     Any: literal returned by the custom adapter</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_literal(self, literal: jelly.RdfLiteral) -&gt; Any:\n    \"\"\"\n    Decode RdfLiteral to literal based on custom adapter implementation.\n\n    Notes: checks for langtag existence;\n           for datatype checks for non-zero table size and datatype field presence\n\n    Args:\n        literal (jelly.RdfLiteral): RdfLiteral message\n\n    Returns:\n        Any: literal returned by the custom adapter\n\n    \"\"\"\n    language = datatype = None\n    if literal.langtag:\n        language = literal.langtag\n    elif self.datatypes.lookup_size and literal.HasField(\"datatype\"):\n        datatype = self.datatypes.decode_datatype_term_index(literal.datatype)\n    return self.adapter.literal(\n        lex=literal.lex,\n        language=language,\n        datatype=datatype,\n    )\n</code></pre> <code>decode_statement(statement, oneofs)</code> <p>Decode a triple/quad message.</p> <p>Notes: also updates repeated terms dictionary</p> <p>Args:     statement (jelly.RdfTriple | jelly.RdfQuad): triple/quad message     oneofs (Sequence[str]): terms s/p/o/g(if quads)</p> <p>Raises:     ValueError: if a missing repeated term is encountered</p> <p>Returns:     Any: a list of decoded terms</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def decode_statement(\n    self,\n    statement: jelly.RdfTriple | jelly.RdfQuad,\n    oneofs: Sequence[str],\n) -&gt; Any:\n    \"\"\"\n    Decode a triple/quad message.\n\n    Notes: also updates repeated terms dictionary\n\n    Args:\n        statement (jelly.RdfTriple | jelly.RdfQuad): triple/quad message\n        oneofs (Sequence[str]): terms s/p/o/g(if quads)\n\n    Raises:\n        ValueError: if a missing repeated term is encountered\n\n    Returns:\n        Any: a list of decoded terms\n\n    \"\"\"\n    terms = []\n    for oneof in oneofs:\n        field = statement.WhichOneof(oneof)\n        if field:\n            jelly_term = getattr(statement, field)\n            decoded_term = self.decode_term(jelly_term)\n            self.repeated_terms[oneof] = decoded_term\n        else:\n            decoded_term = self.repeated_terms[oneof]\n            if decoded_term is None:\n                msg = f\"missing repeated term {oneof}\"\n                raise ValueError(msg)\n        terms.append(decoded_term)\n    return terms\n</code></pre>"},{"location":"api/#pyjelly.parse.decode.options_from_frame","title":"<code>options_from_frame(frame, *, delimited)</code>","text":"<p>Fill stream options based on the options row.</p> <p>Notes:     generalized_statements, rdf_star, and namespace declarations     are set to false by default</p> <p>Args:     frame (jelly.RdfStreamFrame): first non-empty frame from the stream     delimited (bool): derived delimited flag</p> <p>Returns:     ParserOptions: filled options with types/lookups/stream parameters information</p> Source code in <code>pyjelly/parse/decode.py</code> <pre><code>def options_from_frame(\n    frame: jelly.RdfStreamFrame,\n    *,\n    delimited: bool,\n) -&gt; ParserOptions:\n    \"\"\"\n    Fill stream options based on the options row.\n\n    Notes:\n        generalized_statements, rdf_star, and namespace declarations\n        are set to false by default\n\n    Args:\n        frame (jelly.RdfStreamFrame): first non-empty frame from the stream\n        delimited (bool): derived delimited flag\n\n    Returns:\n        ParserOptions: filled options with types/lookups/stream parameters information\n\n    \"\"\"\n    row = frame.rows[0]\n    options = row.options\n    nd = getattr(options, \"namespace_declarations\", False) or (\n        options.version &gt;= MAX_VERSION\n    )\n    return ParserOptions(\n        stream_types=StreamTypes(\n            physical_type=options.physical_type,\n            logical_type=options.logical_type,\n        ),\n        lookup_preset=LookupPreset(\n            max_names=options.max_name_table_size,\n            max_prefixes=options.max_prefix_table_size,\n            max_datatypes=options.max_datatype_table_size,\n        ),\n        params=StreamParameters(\n            stream_name=options.stream_name,\n            generalized_statements=options.generalized_statements,\n            rdf_star=options.rdf_star,\n            version=options.version,\n            delimited=delimited,\n            namespace_declarations=nd,\n        ),\n    )\n</code></pre>"},{"location":"api/#pyjelly.parse.ioutils","title":"<code>ioutils</code>","text":"<p>Functions:</p> Name Description <code>delimited_jelly_hint</code> <p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <code>get_options_and_frames</code> <p>Return stream options and frames from the buffered binary stream.</p>"},{"location":"api/#pyjelly.parse.ioutils.delimited_jelly_hint","title":"<code>delimited_jelly_hint(header)</code>","text":"<p>Detect whether a Jelly file is delimited from its first 3 bytes.</p> <p>Truth table (notation: <code>0A</code> = <code>0x0A</code>, <code>NN</code> = <code>not 0x0A</code>, <code>??</code> = don't care):</p> Byte 1 Byte 2 Byte 3 Result <code>NN</code> <code>??</code> <code>??</code> Delimited <code>0A</code> <code>NN</code> <code>??</code> Non-delimited <code>0A</code> <code>0A</code> <code>NN</code> Delimited (size = 10) <code>0A</code> <code>0A</code> <code>0A</code> Non-delimited (stream options size = 10) <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x00, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x00])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A])) False</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00])) True</p> <p>delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A])) False</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def delimited_jelly_hint(header: bytes) -&gt; bool:\n    \"\"\"\n    Detect whether a Jelly file is delimited from its first 3 bytes.\n\n    Truth table (notation: `0A` = `0x0A`, `NN` = `not 0x0A`, `??` = _don't care_):\n\n    | Byte 1 | Byte 2 | Byte 3 | Result                                   |\n    |--------|--------|--------|------------------------------------------|\n    | `NN`   |  `??`  |  `??`  | Delimited                                |\n    | `0A`   |  `NN`  |  `??`  | Non-delimited                            |\n    | `0A`   |  `0A`  |  `NN`  | Delimited (size = 10)                    |\n    | `0A`   |  `0A`  |  `0A`  | Non-delimited (stream options size = 10) |\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x00, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x00, 0x0A, 0x0A]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x00]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x00, 0x0A]))\n    False\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x00]))\n    True\n\n    &gt;&gt;&gt; delimited_jelly_hint(bytes([0x0A, 0x0A, 0x0A]))\n    False\n    \"\"\"\n    magic = 0x0A\n    return len(header) == 3 and (  # noqa: PLR2004\n        header[0] != magic or (header[1] == magic and header[2] != magic)\n    )\n</code></pre>"},{"location":"api/#pyjelly.parse.ioutils.get_options_and_frames","title":"<code>get_options_and_frames(inp)</code>","text":"<p>Return stream options and frames from the buffered binary stream.</p> <p>Args:     inp (IO[bytes]): jelly buffered binary stream</p> <p>Raises:     JellyConformanceError: if no non-empty frames detected in the delimited stream     JellyConformanceError: if non-delimited,         error is raised if no rows are detected (empty frame)</p> <p>Returns:     tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]: ParserOptions holds:         stream types, lookup presets and other stream options</p> Source code in <code>pyjelly/parse/ioutils.py</code> <pre><code>def get_options_and_frames(\n    inp: IO[bytes],\n) -&gt; tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]:\n    \"\"\"\n    Return stream options and frames from the buffered binary stream.\n\n    Args:\n        inp (IO[bytes]): jelly buffered binary stream\n\n    Raises:\n        JellyConformanceError: if no non-empty frames detected in the delimited stream\n        JellyConformanceError: if non-delimited,\n            error is raised if no rows are detected (empty frame)\n\n    Returns:\n        tuple[ParserOptions, Iterator[jelly.RdfStreamFrame]]: ParserOptions holds:\n            stream types, lookup presets and other stream options\n\n    \"\"\"\n    is_delimited = delimited_jelly_hint(bytes_read := inp.read(3))\n    inp.seek(-len(bytes_read), os.SEEK_CUR)\n\n    if is_delimited:\n        first_frame = None\n        skipped_frames = []\n        frames = frame_iterator(inp)\n        for frame in frames:\n            if not frame.rows:\n                skipped_frames.append(frame)\n            else:\n                first_frame = frame\n                break\n        if first_frame is None:\n            msg = \"No non-empty frames found in the stream\"\n            raise JellyConformanceError(msg)\n\n        options = options_from_frame(first_frame, delimited=True)\n        return options, chain(skipped_frames, (first_frame,), frames)\n\n    frame = parse(jelly.RdfStreamFrame, inp.read())\n\n    if not frame.rows:\n        msg = \"The stream is corrupted (only contains an empty frame)\"\n        raise JellyConformanceError(msg)\n\n    options = options_from_frame(frame, delimited=False)\n    return options, iter((frame,))\n</code></pre>"},{"location":"api/#pyjelly.parse.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>LookupDecoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.parse.lookup.LookupDecoder","title":"<code>LookupDecoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required Source code in <code>pyjelly/parse/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    if lookup_size &gt; MAX_LOOKUP_SIZE:\n        msg = f\"lookup size must be less than {MAX_LOOKUP_SIZE}\"\n        raise JellyAssertionError(msg)\n    self.lookup_size = lookup_size\n    placeholders = (None,) * lookup_size\n    self.data: deque[str | None] = deque(placeholders, maxlen=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre>"},{"location":"api/#pyjelly.serialize","title":"<code>serialize</code>","text":"<p>Modules:</p> Name Description <code>encode</code> <code>flows</code> <code>lookup</code> <code>streams</code>"},{"location":"api/#pyjelly.serialize.encode","title":"<code>encode</code>","text":"<p>Classes:</p> Name Description <code>TermEncoder</code> <p>Functions:</p> Name Description <code>split_iri</code> <p>Split iri into prefix and name.</p> <code>encode_spo</code> <p>Encode the s/p/o of a statement.</p> <code>encode_triple</code> <p>Encode one triple.</p> <code>encode_quad</code> <p>Encode one quad.</p> <code>encode_namespace_declaration</code> <p>Encode namespace declaration.</p> <code>encode_options</code> <p>Encode stream options to ProtoBuf message.</p>"},{"location":"api/#pyjelly.serialize.encode.TermEncoder","title":"<code>TermEncoder(lookup_preset=None)</code>","text":"<p>Methods:</p> Name Description <code>encode_iri_indices</code> <p>Encode lookup indices for IRI.</p> <code>encode_iri</code> <p>Encode iri.</p> <code>encode_default_graph</code> <p>Encode default graph.</p> <code>encode_literal</code> <p>Encode literal.</p> <code>encode_quoted_triple</code> <p>Encode a quoted triple.</p> <code>get_iri_field</code> <p>Get IRI field directly based on slot.</p> <code>get_literal_field</code> <p>Get literal field directly based on slot.</p> <code>set_bnode_field</code> <p>Set bnode field directly based on slot.</p> <code>get_triple_field</code> <p>Get triple term field directly based on slot.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def __init__(\n    self,\n    lookup_preset: options.LookupPreset | None = None,\n) -&gt; None:\n    if lookup_preset is None:\n        lookup_preset = options.LookupPreset()\n    self.lookup_preset = lookup_preset\n    self.names = LookupEncoder(lookup_size=lookup_preset.max_names)\n    self.prefixes = LookupEncoder(lookup_size=lookup_preset.max_prefixes)\n    self.datatypes = LookupEncoder(lookup_size=lookup_preset.max_datatypes)\n</code></pre> <code>encode_iri_indices(iri_string)</code> <p>Encode lookup indices for IRI.</p> <p>Args:     iri_string (str): full iri in string format.</p> <p>Returns:     tuple[Rows, int, int]: additional rows (if any) and         indices in prefix and name tables.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_iri_indices(self, iri_string: str) -&gt; tuple[Rows, int, int]:\n    \"\"\"\n    Encode lookup indices for IRI.\n\n    Args:\n        iri_string (str): full iri in string format.\n\n    Returns:\n        tuple[Rows, int, int]: additional rows (if any) and\n            indices in prefix and name tables.\n\n    \"\"\"\n    prefix, name = split_iri(iri_string)\n    if self.prefixes.lookup.max_size:\n        prefix_entry_index = self.prefixes.encode_entry_index(prefix)\n    else:\n        name = iri_string\n        prefix_entry_index = None\n\n    name_entry_index = self.names.encode_entry_index(name)\n    term_rows = []\n\n    if prefix_entry_index is not None:\n        prefix_entry = jelly.RdfPrefixEntry(id=prefix_entry_index, value=prefix)\n        term_rows.append(jelly.RdfStreamRow(prefix=prefix_entry))\n\n    if name_entry_index is not None:\n        name_entry = jelly.RdfNameEntry(id=name_entry_index, value=name)\n        term_rows.append(jelly.RdfStreamRow(name=name_entry))\n\n    prefix_index = self.prefixes.encode_prefix_term_index(prefix)\n    name_index = self.names.encode_name_term_index(name)\n    return term_rows, prefix_index, name_index\n</code></pre> <code>encode_iri(iri_string, iri)</code> <p>Encode iri.</p> <p>Args:     iri_string (str): full iri in string format.     iri (jelly.RdfIri): iri to fill</p> <p>Returns:     Rows: extra rows for prefix and name tables, if any.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_iri(self, iri_string: str, iri: jelly.RdfIri) -&gt; Rows:\n    \"\"\"\n    Encode iri.\n\n    Args:\n        iri_string (str): full iri in string format.\n        iri (jelly.RdfIri): iri to fill\n\n    Returns:\n        Rows: extra rows for prefix and name tables, if any.\n\n    \"\"\"\n    term_rows, prefix_index, name_index = self.encode_iri_indices(iri_string)\n    iri.prefix_id = prefix_index\n    iri.name_id = name_index\n    return term_rows\n</code></pre> <code>encode_default_graph(g_default_graph)</code> <p>Encode default graph.</p> <p>Returns:     Rows: empty extra rows (for API consistency)</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_default_graph(self, g_default_graph: jelly.RdfDefaultGraph) -&gt; Rows:\n    \"\"\"\n    Encode default graph.\n\n    Returns:\n        Rows: empty extra rows (for API consistency)\n\n    \"\"\"\n    g_default_graph.CopyFrom(jelly.RdfDefaultGraph())\n    return ()\n</code></pre> <code>encode_literal(*, lex, language=None, datatype=None, literal)</code> <p>Encode literal.</p> <p>Args:     lex (str): lexical form/literal value     language (str | None, optional): langtag. Defaults to None.     datatype (str | None, optional): data type if     it is a typed literal. Defaults to None.     literal (jelly.RdfLiteral): literal to fill.</p> <p>Raises:     JellyConformanceError: if datatype specified while         datatable is not used.</p> <p>Returns:     Rows: extra rows (i.e., datatype entries).</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_literal(\n    self,\n    *,\n    lex: str,\n    language: str | None = None,\n    datatype: str | None = None,\n    literal: jelly.RdfLiteral,\n) -&gt; Rows:\n    \"\"\"\n    Encode literal.\n\n    Args:\n        lex (str): lexical form/literal value\n        language (str | None, optional): langtag. Defaults to None.\n        datatype (str | None, optional): data type if\n        it is a typed literal. Defaults to None.\n        literal (jelly.RdfLiteral): literal to fill.\n\n    Raises:\n        JellyConformanceError: if datatype specified while\n            datatable is not used.\n\n    Returns:\n        Rows: extra rows (i.e., datatype entries).\n\n    \"\"\"\n    datatype_id = None\n    term_rows: tuple[()] | tuple[jelly.RdfStreamRow] = ()\n\n    if datatype and datatype != options.STRING_DATATYPE_IRI:\n        if self.datatypes.lookup.max_size == 0:\n            msg = (\n                f\"can't encode literal with type {datatype}: \"\n                \"datatype lookup cannot be used if disabled \"\n                \"(its size was set to 0)\"\n            )\n            raise JellyConformanceError(msg)\n        datatype_entry_id = self.datatypes.encode_entry_index(datatype)\n\n        if datatype_entry_id is not None:\n            entry = jelly.RdfDatatypeEntry(id=datatype_entry_id, value=datatype)\n            term_rows = (jelly.RdfStreamRow(datatype=entry),)\n\n        datatype_id = self.datatypes.encode_datatype_term_index(datatype)\n\n    literal.lex = lex\n    if language:\n        literal.langtag = language\n    if datatype_id:\n        literal.datatype = datatype_id\n    return term_rows\n</code></pre> <code>encode_quoted_triple(terms, quoted_statement)</code> <p>Encode a quoted triple.</p> <p>Notes:     Although a triple, it is treated as a part of a statement.     Repeated terms are not used when encoding quoted triples.</p> <p>Args:     terms (Iterable[object]): triple terms to encode.     quoted_statement (jelly.RdfTriple): quoted triple to fill.</p> <p>Returns:     Rows: additional stream rows with preceeding         information (prefixes, names, datatypes rows, if any).</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_quoted_triple(\n    self, terms: Iterable[object], quoted_statement: jelly.RdfTriple\n) -&gt; Rows:\n    \"\"\"\n    Encode a quoted triple.\n\n    Notes:\n        Although a triple, it is treated as a part of a statement.\n        Repeated terms are not used when encoding quoted triples.\n\n    Args:\n        terms (Iterable[object]): triple terms to encode.\n        quoted_statement (jelly.RdfTriple): quoted triple to fill.\n\n    Returns:\n        Rows: additional stream rows with preceeding\n            information (prefixes, names, datatypes rows, if any).\n\n    \"\"\"\n    rows: list[jelly.RdfStreamRow] = []\n    terms = iter(terms)\n    extra_rows = self.encode_spo(next(terms), Slot.subject, quoted_statement)\n    rows.extend(extra_rows)\n    extra_rows = self.encode_spo(next(terms), Slot.predicate, quoted_statement)\n    rows.extend(extra_rows)\n    extra_rows = self.encode_spo(next(terms), Slot.object, quoted_statement)\n    rows.extend(extra_rows)\n    return rows\n</code></pre> <code>get_iri_field(statement, slot)</code> <p>Get IRI field directly based on slot.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def get_iri_field(self, statement: Statement, slot: Slot) -&gt; jelly.RdfIri:\n    \"\"\"Get IRI field directly based on slot.\"\"\"\n    if slot == Slot.subject:\n        return statement.s_iri\n    if slot == Slot.predicate:\n        return statement.p_iri\n    return statement.o_iri\n</code></pre> <code>get_literal_field(statement, slot)</code> <p>Get literal field directly based on slot.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def get_literal_field(self, statement: Statement, slot: Slot) -&gt; jelly.RdfLiteral:\n    \"\"\"Get literal field directly based on slot.\"\"\"\n    if slot == Slot.subject:\n        return statement.s_literal\n    if slot == Slot.predicate:\n        return statement.p_literal\n    return statement.o_literal\n</code></pre> <code>set_bnode_field(statement, slot, identifier)</code> <p>Set bnode field directly based on slot.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def set_bnode_field(\n    self, statement: Statement, slot: Slot, identifier: str\n) -&gt; None:\n    \"\"\"Set bnode field directly based on slot.\"\"\"\n    if slot == Slot.subject:\n        statement.s_bnode = identifier\n    elif slot == Slot.predicate:\n        statement.p_bnode = identifier\n    else:\n        statement.o_bnode = identifier\n</code></pre> <code>get_triple_field(statement, slot)</code> <p>Get triple term field directly based on slot.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def get_triple_field(self, statement: Statement, slot: Slot) -&gt; jelly.RdfTriple:\n    \"\"\"Get triple term field directly based on slot.\"\"\"\n    if slot == Slot.subject:\n        return statement.s_triple_term\n    if slot == Slot.predicate:\n        return statement.p_triple_term\n    return statement.o_triple_term\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.split_iri","title":"<code>split_iri(iri_string)</code>","text":"<p>Split iri into prefix and name.</p> <p>Args:     iri_string (str): full iri string.</p> <p>Returns:     tuple[str, str]: iri's prefix and name.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def split_iri(iri_string: str) -&gt; tuple[str, str]:\n    \"\"\"\n    Split iri into prefix and name.\n\n    Args:\n        iri_string (str): full iri string.\n\n    Returns:\n        tuple[str, str]: iri's prefix and name.\n\n    \"\"\"\n    name = iri_string\n    prefix = \"\"\n    for sep in \"#\", \"/\":\n        prefix, char, name = iri_string.rpartition(sep)\n        if char:\n            return prefix + char, name\n    return prefix, name\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_spo","title":"<code>encode_spo(terms, term_encoder, repeated_terms, statement)</code>","text":"<p>Encode the s/p/o of a statement.</p> <p>Args:     terms (Iterator[object]): iterator for original terms to encode     term_encoder (TermEncoder): encoder with lookup tables     repeated_terms (list[object | None): list of repeated terms.     statement (Statement): Triple/Quad to fill.</p> <p>Returns:     list[jelly.RdfStreamRow] extra rows to append.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_spo(\n    terms: Iterator[object],\n    term_encoder: TermEncoder,\n    repeated_terms: list[object | None],\n    statement: Statement,\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode the s/p/o of a statement.\n\n    Args:\n        terms (Iterator[object]): iterator for original terms to encode\n        term_encoder (TermEncoder): encoder with lookup tables\n        repeated_terms (list[object | None): list of repeated terms.\n        statement (Statement): Triple/Quad to fill.\n\n    Returns:\n        list[jelly.RdfStreamRow] extra rows to append.\n\n    \"\"\"\n    rows: list[jelly.RdfStreamRow] = []\n    s = next(terms)\n    if repeated_terms[Slot.subject] != s:\n        extra_rows = term_encoder.encode_spo(s, Slot.subject, statement)\n        rows.extend(extra_rows)\n        repeated_terms[Slot.subject] = s\n    p = next(terms)\n    if repeated_terms[Slot.predicate] != p:\n        extra_rows = term_encoder.encode_spo(p, Slot.predicate, statement)\n        rows.extend(extra_rows)\n        repeated_terms[Slot.predicate] = p\n    o = next(terms)\n    if repeated_terms[Slot.object] != o:\n        extra_rows = term_encoder.encode_spo(o, Slot.object, statement)\n        rows.extend(extra_rows)\n        repeated_terms[Slot.object] = o\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_triple","title":"<code>encode_triple(terms, term_encoder, repeated_terms)</code>","text":"<p>Encode one triple.</p> <p>Args:     terms (Iterable[object]): original terms to encode     term_encoder (TermEncoder): current encoder with lookup tables     repeated_terms (list[object | None]): list of repeated terms.</p> <p>Returns:     list[jelly.RdfStreamRow]: list of rows to add to the current flow.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_triple(\n    terms: Iterable[object],\n    term_encoder: TermEncoder,\n    repeated_terms: list[object | None],\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode one triple.\n\n    Args:\n        terms (Iterable[object]): original terms to encode\n        term_encoder (TermEncoder): current encoder with lookup tables\n        repeated_terms (list[object | None]): list of repeated terms.\n\n    Returns:\n        list[jelly.RdfStreamRow]: list of rows to add to the current flow.\n\n    \"\"\"\n    triple = jelly.RdfTriple()\n    terms = iter(terms)\n    rows = encode_spo(terms, term_encoder, repeated_terms, triple)\n    row = jelly.RdfStreamRow(triple=triple)\n    rows.append(row)\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_quad","title":"<code>encode_quad(terms, term_encoder, repeated_terms)</code>","text":"<p>Encode one quad.</p> <p>Args:     terms (Iterable[object]): original terms to encode     term_encoder (TermEncoder): current encoder with lookup tables     repeated_terms (list[object | None]): list of repeated terms.</p> <p>Returns:     list[jelly.RdfStreamRow]: list of messages to append to current flow.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_quad(\n    terms: Iterable[object],\n    term_encoder: TermEncoder,\n    repeated_terms: list[object | None],\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode one quad.\n\n    Args:\n        terms (Iterable[object]): original terms to encode\n        term_encoder (TermEncoder): current encoder with lookup tables\n        repeated_terms (list[object | None]): list of repeated terms.\n\n    Returns:\n        list[jelly.RdfStreamRow]: list of messages to append to current flow.\n\n    \"\"\"\n    terms = iter(terms)\n    quad = jelly.RdfQuad()\n    rows = encode_spo(terms, term_encoder, repeated_terms, quad)\n    g = next(terms)\n    if repeated_terms[Slot.graph] != g:\n        extra_rows = term_encoder.encode_graph(g, quad)\n        rows.extend(extra_rows)\n        repeated_terms[Slot.graph] = g\n    row = jelly.RdfStreamRow(quad=quad)\n    rows.append(row)\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_namespace_declaration","title":"<code>encode_namespace_declaration(name, value, term_encoder)</code>","text":"<p>Encode namespace declaration.</p> <p>Args:     name (str): namespace prefix label     value (str): namespace iri     term_encoder (TermEncoder): current encoder</p> <p>Returns:     list[jelly.RdfStreamRow]: list of messages to append to current flow.</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_namespace_declaration(\n    name: str,\n    value: str,\n    term_encoder: TermEncoder,\n) -&gt; list[jelly.RdfStreamRow]:\n    \"\"\"\n    Encode namespace declaration.\n\n    Args:\n        name (str): namespace prefix label\n        value (str): namespace iri\n        term_encoder (TermEncoder): current encoder\n\n    Returns:\n        list[jelly.RdfStreamRow]: list of messages to append to current flow.\n\n    \"\"\"\n    iri = jelly.RdfIri()\n    [*rows] = term_encoder.encode_iri(value, iri=iri)\n    declaration = jelly.RdfNamespaceDeclaration(name=name, value=iri)\n    row = jelly.RdfStreamRow(namespace=declaration)\n    rows.append(row)\n    return rows\n</code></pre>"},{"location":"api/#pyjelly.serialize.encode.encode_options","title":"<code>encode_options(lookup_preset, stream_types, params)</code>","text":"<p>Encode stream options to ProtoBuf message.</p> <p>Args:     lookup_preset (options.LookupPreset): lookup tables options     stream_types (options.StreamTypes): physical and logical types     params (options.StreamParameters): other params.</p> <p>Returns:     jelly.RdfStreamRow: encoded stream options row</p> Source code in <code>pyjelly/serialize/encode.py</code> <pre><code>def encode_options(\n    lookup_preset: options.LookupPreset,\n    stream_types: options.StreamTypes,\n    params: options.StreamParameters,\n) -&gt; jelly.RdfStreamRow:\n    \"\"\"\n    Encode stream options to ProtoBuf message.\n\n    Args:\n        lookup_preset (options.LookupPreset): lookup tables options\n        stream_types (options.StreamTypes): physical and logical types\n        params (options.StreamParameters): other params.\n\n    Returns:\n        jelly.RdfStreamRow: encoded stream options row\n\n    \"\"\"\n    return jelly.RdfStreamRow(\n        options=jelly.RdfStreamOptions(\n            stream_name=params.stream_name,\n            physical_type=stream_types.physical_type,\n            generalized_statements=params.generalized_statements,\n            rdf_star=params.rdf_star,\n            max_name_table_size=lookup_preset.max_names,\n            max_prefix_table_size=lookup_preset.max_prefixes,\n            max_datatype_table_size=lookup_preset.max_datatypes,\n            logical_type=stream_types.logical_type,\n            version=params.version,\n        )\n    )\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows","title":"<code>flows</code>","text":"<p>Classes:</p> Name Description <code>FrameFlow</code> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <code>ManualFrameFlow</code> <p>Produces frames only when manually requested (never automatically).</p> <code>BoundedFrameFlow</code> <p>Produce frames automatically when a fixed number of rows is reached.</p> <code>GraphsFrameFlow</code> <code>DatasetsFrameFlow</code> <p>Functions:</p> Name Description <code>flow_for_type</code> <p>Return flow based on logical type requested.</p>"},{"location":"api/#pyjelly.serialize.flows.FrameFlow","title":"<code>FrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>UserList[RdfStreamRow]</code></p> <p>Abstract base class for producing Jelly frames from RDF stream rows.</p> <p>Collects stream rows and assembles them into RdfStreamFrame objects when ready.</p> <p>Allows for passing LogicalStreamType, required for     logical subtypes and non-delimited streams.</p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Treat the current rows as a graph and produce a frame.</p> <code>frame_from_dataset</code> <p>Treat the current rows as a dataset and produce a frame.</p> <code>to_stream_frame</code> <p>Create stream frame from flow content.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre> <code>frame_from_graph()</code> <p>Treat the current rows as a graph and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a graph and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>frame_from_dataset()</code> <p>Treat the current rows as a dataset and produce a frame.</p> <p>Default implementation returns None.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Treat the current rows as a dataset and produce a frame.\n\n    Default implementation returns None.\n    \"\"\"\n    return None\n</code></pre> <code>to_stream_frame()</code> <p>Create stream frame from flow content.</p> <p>Notes:     Clears flow content after creating the frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def to_stream_frame(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Create stream frame from flow content.\n\n    Notes:\n        Clears flow content after creating the frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame\n\n    \"\"\"\n    if not self:\n        return None\n    frame = jelly.RdfStreamFrame(rows=self)\n    self.clear()\n    return frame\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.ManualFrameFlow","title":"<code>ManualFrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produces frames only when manually requested (never automatically).</p> <p>Warning</p> <p>All stream rows are kept in memory until <code>to_stream_frame()</code> is called. This may lead to high memory usage for large streams.</p> <p>Used for non-delimited serialization.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.BoundedFrameFlow","title":"<code>BoundedFrameFlow(initlist=None, logical_type=None, *, frame_size=None)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Produce frames automatically when a fixed number of rows is reached.</p> <p>Used for delimited encoding (default mode).</p> <p>Methods:</p> Name Description <code>frame_from_bounds</code> <p>Emit frame from flow if full.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>@override\ndef __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    logical_type: jelly.LogicalStreamType | None = None,\n    *,\n    frame_size: int | None = None,\n) -&gt; None:\n    super().__init__(initlist, logical_type=logical_type)\n    self.frame_size = frame_size or DEFAULT_FRAME_SIZE\n</code></pre> <code>frame_from_bounds()</code> <p>Emit frame from flow if full.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>@override\ndef frame_from_bounds(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit frame from flow if full.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame\n\n    \"\"\"\n    if len(self) &gt;= self.frame_size:\n        return self.to_stream_frame()\n    return None\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.GraphsFrameFlow","title":"<code>GraphsFrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Methods:</p> Name Description <code>frame_from_graph</code> <p>Emit current flow content (one graph) as jelly frame.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre> <code>frame_from_graph()</code> <p>Emit current flow content (one graph) as jelly frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: jelly frame or none if         flow is empty.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_graph(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit current flow content (one graph) as jelly frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: jelly frame or none if\n            flow is empty.\n\n    \"\"\"\n    return self.to_stream_frame()\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.DatasetsFrameFlow","title":"<code>DatasetsFrameFlow(initlist=None, *, logical_type=None, **__kwargs)</code>","text":"<p>               Bases: <code>FrameFlow</code></p> <p>Methods:</p> Name Description <code>frame_from_dataset</code> <p>Emit current flow content (dataset) as jelly frame.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def __init__(\n    self,\n    initlist: Iterable[jelly.RdfStreamRow] | None = None,\n    *,\n    logical_type: jelly.LogicalStreamType | None = None,\n    **__kwargs: Any,\n) -&gt; None:\n    super().__init__(initlist)\n    self.logical_type = logical_type or self.__class__.logical_type\n</code></pre> <code>frame_from_dataset()</code> <p>Emit current flow content (dataset) as jelly frame.</p> <p>Returns:     jelly.RdfStreamFrame | None: jelly frame or none if         flow is empty.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def frame_from_dataset(self) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Emit current flow content (dataset) as jelly frame.\n\n    Returns:\n        jelly.RdfStreamFrame | None: jelly frame or none if\n            flow is empty.\n\n    \"\"\"\n    return self.to_stream_frame()\n</code></pre>"},{"location":"api/#pyjelly.serialize.flows.flow_for_type","title":"<code>flow_for_type(logical_type)</code>","text":"<p>Return flow based on logical type requested.</p> <p>Note: uses base logical type for subtypes (i.e., SUBJECT_GRAPHS uses     the same flow as its base type GRAPHS).</p> <p>Args:     logical_type (jelly.LogicalStreamType): logical type requested.</p> <p>Raises:     NotImplementedError: if (base) logical stream type is not supported.</p> <p>Returns:     type[FrameFlow]: FrameFlow for respective logical type.</p> Source code in <code>pyjelly/serialize/flows.py</code> <pre><code>def flow_for_type(logical_type: jelly.LogicalStreamType) -&gt; type[FrameFlow]:\n    \"\"\"\n    Return flow based on logical type requested.\n\n    Note: uses base logical type for subtypes (i.e., SUBJECT_GRAPHS uses\n        the same flow as its base type GRAPHS).\n\n    Args:\n        logical_type (jelly.LogicalStreamType): logical type requested.\n\n    Raises:\n        NotImplementedError: if (base) logical stream type is not supported.\n\n    Returns:\n        type[FrameFlow]: FrameFlow for respective logical type.\n\n    \"\"\"\n    try:\n        base_logical_type_value = logical_type % 10\n        base_name = jelly.LogicalStreamType.Name(base_logical_type_value)\n        return FLOW_DISPATCH[getattr(jelly.LogicalStreamType, base_name)]\n    except KeyError:\n        msg = (\n            \"unsupported logical stream type: \"\n            f\"{jelly.LogicalStreamType.Name(logical_type)}\"\n        )\n        raise NotImplementedError(msg) from None\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup","title":"<code>lookup</code>","text":"<p>Classes:</p> Name Description <code>Lookup</code> <p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <code>LookupEncoder</code> <p>Shared base for RDF lookup encoders using Jelly compression.</p>"},{"location":"api/#pyjelly.serialize.lookup.Lookup","title":"<code>Lookup(max_size)</code>","text":"<p>Fixed-size 1-based string-to-index mapping with LRU eviction.</p> <ul> <li>Assigns incrementing indices starting from 1.</li> <li>After reaching the maximum size, reuses the existing indices from evicting   the least-recently-used entries.</li> <li>Index 0 is reserved for delta encoding in Jelly streams.</li> </ul> <p>To check if a key exists, use <code>.move(key)</code> and catch <code>KeyError</code>. If <code>KeyError</code> is raised, the key can be inserted with <code>.insert(key)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of entries. Zero disables lookup.</p> required Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, max_size: int) -&gt; None:\n    self.data = OrderedDict[str, int]()\n    self.max_size = max_size\n    self._evicting = False\n</code></pre>"},{"location":"api/#pyjelly.serialize.lookup.LookupEncoder","title":"<code>LookupEncoder(*, lookup_size)</code>","text":"<p>Shared base for RDF lookup encoders using Jelly compression.</p> <p>Tracks the last assigned and last reused index.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_size</code> <code>int</code> <p>Maximum lookup size.</p> required <p>Methods:</p> Name Description <code>encode_entry_index</code> <p>Get or assign the index to use in an entry.</p> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def __init__(self, *, lookup_size: int) -&gt; None:\n    self.lookup = Lookup(max_size=lookup_size)\n    self.last_assigned_index = 0\n    self.last_reused_index = 0\n</code></pre> <code>encode_entry_index(key)</code> <p>Get or assign the index to use in an entry.</p> <p>Returns:</p> Type Description <code>int or None</code> <ul> <li>0 if the new index is sequential (<code>last_assigned_index + 1</code>)</li> <li>actual assigned/reused index otherwise</li> <li>None if the key already exists</li> </ul> <code>If the return value is None, the entry is already in the lookup and does not</code> <code>need to be emitted. Any integer value (including 0) means the entry is new</code> <code>and should be emitted.</code> Source code in <code>pyjelly/serialize/lookup.py</code> <pre><code>def encode_entry_index(self, key: str) -&gt; int | None:\n    \"\"\"\n    Get or assign the index to use in an entry.\n\n    Returns\n    -------\n    int or None\n        - 0 if the new index is sequential (`last_assigned_index + 1`)\n        - actual assigned/reused index otherwise\n        - None if the key already exists\n\n    If the return value is None, the entry is already in the lookup and does not\n    need to be emitted. Any integer value (including 0) means the entry is new\n    and should be emitted.\n\n    \"\"\"\n    try:\n        self.lookup.make_last_to_evict(key)\n        return None  # noqa: TRY300\n    except KeyError:\n        previous_index = self.last_assigned_index\n        index = self.lookup.insert(key)\n        self.last_assigned_index = index\n        if index == previous_index + 1:\n            return 0\n        return index\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams","title":"<code>streams</code>","text":"<p>Classes:</p> Name Description <code>Stream</code> <code>TripleStream</code> <code>QuadStream</code> <code>GraphStream</code> <p>Functions:</p> Name Description <code>stream_for_type</code> <p>Give a Stream based on physical type specified.</p>"},{"location":"api/#pyjelly.serialize.streams.Stream","title":"<code>Stream(*, encoder, options=None)</code>","text":"<p>Methods:</p> Name Description <code>infer_flow</code> <p>Return flow based on the stream options provided.</p> <code>enroll</code> <p>Initialize start of the stream.</p> <code>stream_options</code> <p>Encode and append stream options row to the current flow.</p> <code>namespace_declaration</code> <p>Add namespace declaration to jelly stream.</p> <code>for_rdflib</code> <p>Initialize stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>infer_flow()</code> <p>Return flow based on the stream options provided.</p> <p>Returns:     FrameFlow: initialised FrameFlow object.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def infer_flow(self) -&gt; FrameFlow:\n    \"\"\"\n    Return flow based on the stream options provided.\n\n    Returns:\n        FrameFlow: initialised FrameFlow object.\n\n    \"\"\"\n    flow: FrameFlow\n    if self.options.params.delimited:\n        if self.options.logical_type != jelly.LOGICAL_STREAM_TYPE_UNSPECIFIED:\n            flow_class = flow_for_type(self.options.logical_type)\n        else:\n            flow_class = self.default_delimited_flow_class\n\n        if self.options.logical_type in (\n            jelly.LOGICAL_STREAM_TYPE_FLAT_TRIPLES,\n            jelly.LOGICAL_STREAM_TYPE_FLAT_QUADS,\n        ):\n            flow = flow_class(\n                logical_type=self.options.logical_type,\n                frame_size=self.options.frame_size,\n            )\n        else:\n            flow = flow_class(logical_type=self.options.logical_type)\n    else:\n        flow = ManualFrameFlow(logical_type=self.options.logical_type)\n    return flow\n</code></pre> <code>enroll()</code> <p>Initialize start of the stream.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def enroll(self) -&gt; None:\n    \"\"\"Initialize start of the stream.\"\"\"\n    if not self.enrolled:\n        self.stream_options()\n        self.enrolled = True\n</code></pre> <code>stream_options()</code> <p>Encode and append stream options row to the current flow.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_options(self) -&gt; None:\n    \"\"\"Encode and append stream options row to the current flow.\"\"\"\n    self.flow.append(\n        encode_options(\n            stream_types=self.stream_types,\n            params=self.options.params,\n            lookup_preset=self.options.lookup_preset,\n        )\n    )\n</code></pre> <code>namespace_declaration(name, iri)</code> <p>Add namespace declaration to jelly stream.</p> <p>Args:     name (str): namespace prefix label     iri (str): namespace iri</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def namespace_declaration(self, name: str, iri: str) -&gt; None:\n    \"\"\"\n    Add namespace declaration to jelly stream.\n\n    Args:\n        name (str): namespace prefix label\n        iri (str): namespace iri\n\n    \"\"\"\n    rows = encode_namespace_declaration(\n        name=name,\n        value=iri,\n        term_encoder=self.encoder,\n    )\n    self.flow.extend(rows)\n</code></pre> <code>for_rdflib(options=None)</code> <p>Initialize stream with RDFLib encoder.</p> <p>Args:     options (SerializerOptions | None, optional): Stream options.         Defaults to None.</p> <p>Raises:     TypeError: if Stream is passed, and not a Stream for specific physical type.</p> <p>Returns:     Stream: initialized stream with RDFLib encoder.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>@classmethod\ndef for_rdflib(cls, options: SerializerOptions | None = None) -&gt; Stream:\n    \"\"\"\n    Initialize stream with RDFLib encoder.\n\n    Args:\n        options (SerializerOptions | None, optional): Stream options.\n            Defaults to None.\n\n    Raises:\n        TypeError: if Stream is passed, and not a Stream for specific physical type.\n\n    Returns:\n        Stream: initialized stream with RDFLib encoder.\n\n    \"\"\"\n    if cls is Stream:\n        msg = \"Stream is an abstract base class, use a subclass instead\"\n        raise TypeError(msg)\n    from pyjelly.integrations.rdflib.serialize import RDFLibTermEncoder\n\n    lookup_preset: LookupPreset | None = None\n    if options is not None:\n        lookup_preset = options.lookup_preset\n    return cls(\n        encoder=RDFLibTermEncoder(lookup_preset=lookup_preset),\n        options=options,\n    )\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.TripleStream","title":"<code>TripleStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>triple</code> <p>Process one triple to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>triple(terms)</code> <p>Process one triple to Protobuf messages.</p> <p>Note:     Adds new rows to the current flow and returns StreamFrame if     frame size conditions are met.</p> <p>Args:     terms (Iterable[object]): RDF terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def triple(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one triple to Protobuf messages.\n\n    Note:\n        Adds new rows to the current flow and returns StreamFrame if\n        frame size conditions are met.\n\n    Args:\n        terms (Iterable[object]): RDF terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_triple(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.QuadStream","title":"<code>QuadStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>Stream</code></p> <p>Methods:</p> Name Description <code>quad</code> <p>Process one quad to Protobuf messages.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>quad(terms)</code> <p>Process one quad to Protobuf messages.</p> <p>Args:     terms (Iterable[object]): terms to encode.</p> <p>Returns:     jelly.RdfStreamFrame | None: stream frame if         flow supports frames slicing and current flow is full</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def quad(self, terms: Iterable[object]) -&gt; jelly.RdfStreamFrame | None:\n    \"\"\"\n    Process one quad to Protobuf messages.\n\n    Args:\n        terms (Iterable[object]): terms to encode.\n\n    Returns:\n        jelly.RdfStreamFrame | None: stream frame if\n            flow supports frames slicing and current flow is full\n\n    \"\"\"\n    new_rows = encode_quad(\n        terms,\n        term_encoder=self.encoder,\n        repeated_terms=self.repeated_terms,\n    )\n    self.flow.extend(new_rows)\n    return self.flow.frame_from_bounds()\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.GraphStream","title":"<code>GraphStream(*, encoder, options=None)</code>","text":"<p>               Bases: <code>TripleStream</code></p> <p>Methods:</p> Name Description <code>graph</code> <p>Process one graph into a sequence of jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def __init__(\n    self,\n    *,\n    encoder: TermEncoder,\n    options: SerializerOptions | None = None,\n) -&gt; None:\n    self.encoder = encoder\n    if options is None:\n        options = SerializerOptions()\n    self.options = options\n    flow = options.flow\n    if flow is None:\n        flow = self.infer_flow()\n    self.flow = flow\n    self.repeated_terms = [None] * len(Slot)\n    self.enrolled = False\n    self.stream_types = StreamTypes(\n        physical_type=self.physical_type,\n        logical_type=self.flow.logical_type,\n    )\n</code></pre> <code>graph(graph_id, graph)</code> <p>Process one graph into a sequence of jelly frames.</p> <p>Args:     graph_id (object): graph id (BN, Literal, iri, default)     graph (Iterable[Iterable[object]]): iterable of triples (graph's content)</p> <p>Yields:     Generator[jelly.RdfStreamFrame]: jelly frames.</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def graph(\n    self,\n    graph_id: object,\n    graph: Iterable[Iterable[object]],\n) -&gt; Generator[jelly.RdfStreamFrame]:\n    \"\"\"\n    Process one graph into a sequence of jelly frames.\n\n    Args:\n        graph_id (object): graph id (BN, Literal, iri, default)\n        graph (Iterable[Iterable[object]]): iterable of triples (graph's content)\n\n    Yields:\n        Generator[jelly.RdfStreamFrame]: jelly frames.\n\n    \"\"\"\n    graph_start = jelly.RdfGraphStart()\n    [*graph_rows] = self.encoder.encode_graph(graph_id, graph_start)\n    start_row = jelly.RdfStreamRow(graph_start=graph_start)\n    graph_rows.append(start_row)\n    self.flow.extend(graph_rows)\n    for triple in graph:\n        if frame := self.triple(triple):  # has frame slicing inside\n            yield frame\n    end_row = jelly.RdfStreamRow(graph_end=jelly.RdfGraphEnd())\n    self.flow.append(end_row)\n    if frame := self.flow.frame_from_bounds():\n        yield frame\n</code></pre>"},{"location":"api/#pyjelly.serialize.streams.stream_for_type","title":"<code>stream_for_type(physical_type)</code>","text":"<p>Give a Stream based on physical type specified.</p> <p>Args:     physical_type (jelly.PhysicalStreamType): jelly stream physical type.</p> <p>Raises:     NotImplementedError: if no stream for requested physical type is available.</p> <p>Returns:     type[Stream]: jelly stream</p> Source code in <code>pyjelly/serialize/streams.py</code> <pre><code>def stream_for_type(physical_type: jelly.PhysicalStreamType) -&gt; type[Stream]:\n    \"\"\"\n    Give a Stream based on physical type specified.\n\n    Args:\n        physical_type (jelly.PhysicalStreamType): jelly stream physical type.\n\n    Raises:\n        NotImplementedError: if no stream for requested physical type is available.\n\n    Returns:\n        type[Stream]: jelly stream\n\n    \"\"\"\n    try:\n        stream_cls = STREAM_DISPATCH[physical_type]\n    except KeyError:\n        msg = (\n            \"no stream class for physical type \"\n            f\"{jelly.PhysicalStreamType.Name(physical_type)}\"\n        )\n        raise NotImplementedError(msg) from None\n    return stream_cls\n</code></pre>"},{"location":"generic-sink/","title":"Generic API","text":"<p>This guide explains how to use pyjelly\u2019s generic API to write and read RDF statements into the\u00a0Jelly\u00a0format without any external library.</p>"},{"location":"generic-sink/#installation","title":"Installation","text":"<p>Install pyjelly from PyPI:</p> <pre><code>pip install pyjelly\n</code></pre>"},{"location":"generic-sink/#requirements","title":"Requirements","text":"<ul> <li>Python\u00a03.9 or newer  </li> <li>Linux, macOS, or Windows</li> </ul>"},{"location":"generic-sink/#usage-without-external-libraries","title":"Usage without external libraries","text":"<p>Unlike the example in getting started, the Generic API does not use the RDFLib or any other third-party libraries, but it works in much the same way.</p>"},{"location":"generic-sink/#serializing-statements-to-a-jelly-file","title":"Serializing statements to a Jelly file","text":"<p>To make a set of triples/quads and write them to a Jelly file, use:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\n\n# Create a generic sink object\ngeneric_sink = GenericStatementSink()\n\n# Let's add triples one by one\ngeneric_sink.add(\n    Triple(\n        IRI(\"http://example.com/subject\"),\n        IRI(\"http://example.com/predicate\"),\n        Literal(\"Hello\", langtag=\"en\"),\n    )\n)\ngeneric_sink.add(\n    Triple(\n        BlankNode(\"B1\"),\n        IRI(\"http://example.com/hasName\"),\n        Literal(\"Bob\"),\n    )\n)\n\n# Write into a Jelly file\nwith open(\"output.jelly\", \"wb\") as out_file:\n    generic_sink.serialize(out_file)\n\nprint(\"All done.\")\n</code></pre> <p>This example uses pyjelly\u2019s simple custom triple/quad type, which is easy to create and work with.</p>"},{"location":"generic-sink/#parsing-statements-from-a-jelly-file","title":"Parsing statements from a Jelly file","text":"<p>To load triples/quads into your python object from a <code>.jelly</code> file, see:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\n\n# Create a generic sink object\ngeneric_sink = GenericStatementSink()\n\n# Load triples from the Jelly file\nwith open(\"output.jelly\", \"rb\") as in_file:\n    generic_sink.parse(in_file)\n\n# Let's inspect them statement by statement\nfor statement in generic_sink:\n    if isinstance(statement, Triple):\n        print(statement)\n\nprint(\"All done.\")\n</code></pre> <p>Which retrieves data from your <code>.jelly</code> file.</p>"},{"location":"generic-sink/#parsing-a-stream-of-graphs","title":"Parsing a stream of graphs","text":"<p>Similarly, to process a Jelly stream as a stream of graphs through generic API, see:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.generic.parse import parse_jelly_grouped\n\n# Dataset: Katrina weather measurements (10k graphs)\n# Documentation: https://w3id.org/riverbench/datasets/lod-katrina/dev\nurl = \"https://w3id.org/riverbench/datasets/lod-katrina/dev/files/jelly_10K.jelly.gz\"\n\n# Load, uncompress .gz file, and pass to Jelly parser, all in a streaming manner\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    # Parse into sinks (one per graph)\n    graphs = parse_jelly_grouped(jelly_stream)\n\n    # First 50\n    for i, graph in enumerate(graphs):\n        print(f\"Graph {i} in the stream has {len(graph)} triples\")\n        if i &gt;= 50:\n            break\n</code></pre> <p>Where we use a dataset of weather measurements and count the number of triples in each graph.</p>"},{"location":"generic-sink/#parsing-a-stream-of-statements","title":"Parsing a stream of statements","text":"<p>You can also process a Jelly stream as a flat stream with only generic API:</p> <p>We look through a fragment of Denmark's OpenStreetMap to find all city names:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.generic.generic_sink import *\nfrom pyjelly.integrations.generic.parse import parse_jelly_flat\n\n# Dataset: OpenStreetMap data for Denmark (first 10k objects)\n# Documentation: https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev\nurl = (\n    \"https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev/files/jelly_10K.jelly.gz\"\n)\n\n# We are looking for city names in the dataset\npredicate_to_look_for = IRI(\"https://www.openstreetmap.org/wiki/Key:addr:city\")\ncity_names = set()\n\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    for event in parse_jelly_flat(jelly_stream):\n        if isinstance(event, Triple):\n            if str(event.p) == str(predicate_to_look_for):\n                city_names.add(str(event.o))\n\nprint(f\"Found {len(city_names)} unique city names in the dataset.\")\nprint(\"Sample city names:\")\nfor city in list(city_names)[:10]:\n    print(f\"- {city}\")\n</code></pre> <p>We get a generator of stream events, which allows us to process the file statement-by-statement, however with no external libraries used.</p>"},{"location":"generic-sink/#streaming-data","title":"Streaming data","text":"<p>If you need to process a certain quantity of statements both efficiently and iteratively, you can provide a simple generator:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\n\n\n# Helper generator that streams statements from a Jelly file path\ndef stream_triples(jelly_path):\n    generic_sink = GenericStatementSink()\n    with open(jelly_path, \"rb\") as f:\n        generic_sink.parse(f)\n    yield from (stmt for stmt in generic_sink)\n\n\n# Example usage, just printing:\nfor triple in stream_triples(\"output.jelly\"):\n    print(triple)\n\nprint(\"All done.\")\n</code></pre> <p>With this method you avoid storing all statements in memory, which greatly improves performance.</p>"},{"location":"generic-sink/#serializing-a-stream-of-graphs","title":"Serializing a stream of graphs","text":"<p>If you have a generator object containing graphs, you can use a generic approach for serialization:</p> <pre><code>from pyjelly.integrations.generic.generic_sink import *\nfrom pyjelly.integrations.generic.serialize import grouped_stream_to_file\nimport random\n\n\n# Helper function to generate a generator of graphs\ndef generate_sample_sinks():\n    content = (\n        IRI(\"http://example.com/sensor\"),\n        IRI(\"http://example.com/humidity\"),\n        IRI(f\"http://example.com/{random.random()}\"),\n    )\n    for _ in range(10):\n        sink = GenericStatementSink()\n        sink.add(Triple(*content))\n        yield sink\n\n\noutput_file = \"output.jelly\"\nprint(f\"Streaming graphs into {output_file}\u2026\")\nwith open(output_file, \"wb\") as out_f:\n    grouped_stream_to_file(generate_sample_sinks(), out_f)\nprint(\"All done.\")\n</code></pre> <p>Grouped data is streamed in its original form, no need for additional RDF libraries like RDFLib. </p>"},{"location":"generic-sink/#serializing-a-stream-of-statements","title":"Serializing a stream of statements","text":"<p>Serializing a generator object of statements to <code>.jelly</code> file through generic API:</p> <pre><code>from pyjelly.integrations.generic.serialize import flat_stream_to_file\nfrom pyjelly.integrations.generic.generic_sink import *\nimport random\n\n\n# Example generator that yields raw triples\ndef generate_sample_triples():\n    content = (\n        IRI(\"http://example.com/sensor\"),\n        IRI(\"http://example.com/humidity\"),\n        IRI(f\"http://example.com/{random.random()}\"),\n    )\n    for _ in range(10):\n        yield Triple(*content)\n\n\noutput_file = \"flat_output.jelly\"\nprint(f\"Streaming triples into {output_file}\u2026\")\nsample_triples = generate_sample_triples()\nwith open(output_file, \"wb\") as out_f:\n    flat_stream_to_file(sample_triples, out_f)\nprint(\"All done.\")\n</code></pre> <p>Data is transmitted and kept ordered and simple.</p>"},{"location":"generic-sink/#working-with-byte-buffers-and-kafka","title":"Working with byte buffers and Kafka","text":"<p>When working with Kafka or other message brokers, you may want to write Jelly data to a byte buffer instead of a file. You can do this by using the <code>BytesIO</code> class from the <code>io</code> module:</p> <pre><code>import io\n\nfrom pyjelly.integrations.generic.generic_sink import *\n\ng1 = GenericStatementSink()\n\ng1.add(\n    Triple(\n        IRI(\"http://example.com/subject\"),\n        IRI(\"http://example.com/predicate\"),\n        Literal(\"Hello\", langtag=\"en\"),\n    )\n)\n\n# Write the data into a byte buffer (bytes type)\nwith io.BytesIO() as write_buffer:\n    g1.serialize(write_buffer)\n    data = write_buffer.getvalue()\n\nprint(f\"Serialized data size: {len(data)} bytes\")\n\n# Parse the data back\ng2 = GenericStatementSink()\nwith io.BytesIO(data) as read_buffer:\n    g2.parse(read_buffer)\n\nprint(\"\\nParsed triples:\")\nfor statement in g2:\n    print(statement)\n</code></pre> <p>The <code>data</code> variable is of type <code>bytes</code>, and can be passed to Kafka with <code>KafkaProducer.send(value=data)</code>, or any other API that accepts byte buffers. Same trick may be used when working with the RDFLib integration.</p> <p>When working with Kafka, you should be aware of the broker's offset management and partitioning strategies. Data within one Jelly stream must be strictly ordered and no frames may be dropped. If you have less strict ordering guarantees, you should split up the stream into multiple Jelly streams, each with guaranteed consistency.</p>"},{"location":"generic-sink/#see-also","title":"See also","text":"<p>If you are familiar with RDFLib, you can use pyjelly together with RDFLib in a similar way. See the dedicated guide.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide walks you through installing and working with pyjelly and RDFLib.</p>"},{"location":"getting-started/#installation-with-rdflib","title":"Installation (with RDFLib)","text":"<p>Install pyjelly from PyPI:</p> <pre><code>pip install pyjelly[rdflib]\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python\u00a03.9 or newer  </li> <li>Linux, macOS, or Windows</li> </ul>"},{"location":"getting-started/#usage-with-rdflib","title":"Usage with RDFLib","text":"<p>Once you install pyjelly, it integrates automatically with RDFLib through standard RDFLib API.</p>"},{"location":"getting-started/#serializing-a-graph","title":"Serializing a graph","text":"<p>To serialize a graph to the Jelly format see:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"http://xmlns.com/foaf/spec/index.rdf\")\ng.serialize(destination=\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>This creates a delimited Jelly stream using default options.</p>"},{"location":"getting-started/#including-namespace-declarations-prefixes","title":"Including namespace declarations (prefixes)","text":"<p>By default, Jelly serializes only triples/quads. To also include namespace declarations (prefixes) in the output, enable the <code>namespace_declarations</code> option. Prefixes bound in RDFLib's namespace manager will then be written into the Jelly stream and restored on parsing.</p> <pre><code>from rdflib import Graph, Namespace, URIRef, Literal\nfrom pyjelly.integrations.rdflib.serialize import SerializerOptions, StreamParameters\n\n# Build a tiny graph and bind a prefix\ng = Graph()\nEX = Namespace(\"http://example.org/\")\ng.namespace_manager.bind(\"ex\", EX)\ng.add((EX.alice, URIRef(\"http://xmlns.com/foaf/0.1/name\"), Literal(\"Alice\")))\n\nprint(\"IN  namespaces:\", dict(g.namespaces()))\n\n# Enable namespace declarations in Jelly output\noptions = SerializerOptions(params=StreamParameters(namespace_declarations=True))\n\n# Serialize with options\ng.serialize(\"sample_test.jelly\", format=\"jelly\", options=options)\n\n# Parse back and check namespaces\ng_new = Graph()\ng_new.parse(\"sample_test.jelly\", format=\"jelly\")\nprint(\"OUT namespaces:\", dict(g_new.namespaces()))\n</code></pre> <p>Tip</p> <p>For an existing graph you can (re)bind a prefix just before saving:</p> <pre><code>g.namespace_manager.bind(\"ex\", EX, replace=True)\n</code></pre>"},{"location":"getting-started/#parsing-a-graph","title":"Parsing a graph","text":"<p>To load RDF data from a <code>.jelly</code> file see:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"foaf.jelly\", format=\"jelly\")\n\nprint(\"Parsed triples:\")\nfor s, p, o in g:\n    print(f\"{s} {p} {o}\")\n</code></pre> <p>RDFLib will reconstruct the graph from the Jelly file.</p>"},{"location":"getting-started/#parsing-a-stream-of-graphs","title":"Parsing a stream of graphs","text":"<p>You can process a Jelly stream as a stream of graphs. A Jelly file consists of \"frames\" (batches of statements) \u2013 we can load each frame as a separate RDFLib graph.</p> <p>In this example, we use a dataset of weather measurements. We count the number of triples in each graph:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.rdflib.parse import parse_jelly_grouped\n\n# Dataset: Katrina weather measurements (10k graphs)\n# Documentation: https://w3id.org/riverbench/datasets/lod-katrina/dev\nurl = \"https://w3id.org/riverbench/datasets/lod-katrina/dev/files/jelly_10K.jelly.gz\"\n\n# Load, uncompress .gz file, and pass to Jelly parser, all in a streaming manner\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    graphs = parse_jelly_grouped(jelly_stream)\n    for i, graph in enumerate(graphs):\n        print(f\"Graph {i} in the stream has {len(graph)} triples\")\n        # Limit to 50 graphs for demonstration -- the rest will not be parsed\n        if i &gt;= 50:\n            break\n</code></pre> <p>Each iteration receives only one graph, allowing for processing large datasets efficiently, without exhausting memory.</p>"},{"location":"getting-started/#parsing-a-stream-of-triples","title":"Parsing a stream of triples","text":"<p>You can also process a Jelly stream as a flat stream of triples.</p> <p>We look through a fragment of Denmark's OpenStreetMap to find all city names:</p> <pre><code>import gzip\nimport urllib.request\n\nfrom pyjelly.integrations.rdflib.parse import parse_jelly_flat, Triple\nfrom rdflib import URIRef\n\n# Dataset: OpenStreetMap data for Denmark (first 10k objects)\n# Documentation: https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev\nurl = (\n    \"https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev/files/jelly_10K.jelly.gz\"\n)\n\n# We are looking for city names in the dataset\npredicate_to_look_for = URIRef(\"https://www.openstreetmap.org/wiki/Key:addr:city\")\ncity_names = set()\n\nwith (\n    urllib.request.urlopen(url) as response,\n    gzip.open(response) as jelly_stream,\n):\n    for event in parse_jelly_flat(jelly_stream):\n        if isinstance(event, Triple):  # we are only interested in triples\n            if event.p == predicate_to_look_for:\n                city_names.add(event.o)\n\nprint(f\"Found {len(city_names)} unique city names in the dataset.\")\nprint(\"10 random city names:\")\nfor city in list(city_names)[:10]:\n    print(f\"- {city}\")\n</code></pre> <p><code>parse_jelly_flat</code> returns a generator of stream events (i.e., statements parsed). This case allows you to efficiently process the file triple-by-triple and build custom aggregations from the stream.</p>"},{"location":"getting-started/#serializing-a-stream-of-graphs","title":"Serializing a stream of graphs","text":"<p>If you have a generator object containing graphs, you can easily serialize it into the Jelly format: </p> <pre><code>from pyjelly.integrations.rdflib.serialize import grouped_stream_to_file\n\nfrom rdflib import Graph, Literal, Namespace\nimport random\n\n\ndef generate_sample_graphs():\n    ex = Namespace(\"http://example.org/\")\n    for _ in range(10):\n        g = Graph()\n        g.add((ex.sensor, ex.temperature, Literal(random.random())))\n        g.add((ex.sensor, ex.humidity, Literal(random.random())))\n        yield g\n\n\noutput_file_name = \"output.jelly\"\n\nprint(f\"Streaming graphs into {output_file_name}\u2026\")\nsample_graphs = generate_sample_graphs()\nwith open(output_file_name, \"wb\") as out_file:\n    grouped_stream_to_file(sample_graphs, out_file)\nprint(\"All done.\")\n</code></pre> <p>This method allows for transmitting logically grouped data, preserving their original division.  For more precise control over frame serialization you can use lower-level API</p>"},{"location":"getting-started/#serializing-a-stream-of-statements","title":"Serializing a stream of statements","text":"<p>If you have a generator object containing statements, you can easily serialize it into the Jelly format: </p> <pre><code>from pyjelly.integrations.rdflib.serialize import flat_stream_to_file\nfrom rdflib import Literal, Namespace\nimport random\n\n\n# example generator with triples statements\ndef generate_sample_triples():\n    ex = Namespace(\"http://example.org/\")\n    for _ in range(10):\n        yield (ex.sensor, ex.temperature, Literal(random.random()))\n\n\noutput_file_name = \"flat_output.jelly\"\n\nprint(f\"Streaming triples into {output_file_name}\u2026\")\nsample_triples = generate_sample_triples()\nwith open(output_file_name, \"wb\") as out_file:\n    flat_stream_to_file(sample_triples, out_file)\nprint(\"All done.\")\n</code></pre> <p>The flat method transmits the data as a continuous sequence of statements, keeping it simple and ordered. For more precise control over frame serialization you can use lower-level API</p>"},{"location":"getting-started/#file-extension-support","title":"File extension support","text":"<p>You can generally omit the <code>format=\"jelly\"</code> parameter if the file ends in <code>.jelly</code> \u2013 RDFLib will auto-detect the format:</p> <pre><code>from rdflib import Graph\nimport pyjelly.integrations.rdflib\n\ng = Graph()\ng.parse(\"foaf.jelly\")\n</code></pre> <p>Warning</p> <p>Unfortunately, the way this is implemented in RDFLib is a bit wonky, so it will only work if you explicitly import <code>pyjelly.integrations.rdflib</code>, or you used <code>format=\"jelly\"</code> in the <code>serialize()</code> or <code>parse()</code> call before.</p>"},{"location":"getting-started/#see-also","title":"See also","text":"<ul> <li>Working with byte buffers and Kafka</li> <li>Usage without RDFLib</li> <li>API reference</li> </ul>"},{"location":"networkx-integration/","title":"NetworkX","text":"<p>NetworkX is a Python package that represents complex networks as graphs and allows for their manipulation.</p> <p>Install the following libraries:</p> <pre><code>pip install pyjelly[rdflib] networkx==3.2.1 matplotlib==3.9.4\n</code></pre> <p>Below there are few useful examples to follow.</p>"},{"location":"networkx-integration/#parse-graph-show-it","title":"Parse graph, show it","text":"<p>Let's investigate relationships between worldwide political figures (support and opposition relations)! We are given a graph in <code>.jelly</code> containing information about political stances extracted from news articles. Let's dive in and get some useful information!</p> <p>We can easily load it:  </p> <pre><code># Parse RDF from the Jelly format\nrdf_g = Graph()\nrdf_g.parse(example_file, format=\"jelly\")\nprint(f\"Loaded graph with {len(rdf_g)} instances.\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Loaded graph with 90000 instances.\n</code></pre> <p>Convert it into a convenient NetworkX graph:</p> <pre><code># Convert to a NetworkX graph\nnx_g = rdflib_to_networkx_graph(rdf_g_filtered)\n</code></pre> <p>Is our graph fully connected? It's important to know (are all political relations tied together?), let's check here:</p> <pre><code># Example calculation, get the number of connected components in a graph\nnum_components = nx.number_connected_components(nx_g)\nprint(f\"Connected components: {num_components}\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Connected components: 24\n</code></pre> <p>Which nodes are connected the most (have most connections?), let's see top 5 of them:</p> <pre><code># Example calculation, get top 5 objects with highest degrees, simple in NetworkX\ntop5 = sorted(nx_g.degree, key=lambda x: x[1], reverse=True)[:5]\nprint(\"Top 5 nodes sorted by degree:\")\nfor node, deg in top5:\n    print(f\"{node}: {deg}\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Top 5 nodes sorted by degree:\nSocrates: 241\nCavaco: 189\nPassos Coelho: 187\nCosta: 179\nAntonio Costa: 168\n</code></pre> <p>What is the shortest path between two nodes? We can check:</p> <pre><code># Example calculation, shortest path between two nodes (provided at least two nodes)\nsource = next(n for n in nx_g if norm(n) == \"socrates\")\ntarget = next(n for n in nx_g if norm(n) == \"obama\")\npath = nx.shortest_path(nx_g, source=source, target=target)\nprint(f\"Shortest path from {source} to {target}: {' -&gt; '.join(path)}\")\n</code></pre> <p>Output from <code>print()</code>:</p> <pre><code>Shortest path from Socrates to Obama: Socrates -&gt; Marcelo Rebelo de Sousa -&gt; Durao Barroso -&gt; Obama\n</code></pre> <p>However, it's best to see the full picture (for our example we truncate to 10 nodes for clarity):</p> <pre><code># Take first 10 nodes\nnodes = list(nx_g)[:10]\nsubg = nx_g.subgraph(nodes)\n\n# Draw and display the graph\npos_sub = nx.spring_layout(subg, k=5, iterations=200, scale=3, seed=24)\nplt.figure(figsize=(10, 10))\n\n# Introduce your own settings for display\nnx.draw_networkx(subg, pos_sub, font_size=14, node_size=220, linewidths=0.7)\nplt.axis(\"off\")\nplt.show()\n</code></pre> <p>The graph presents as follows</p> <p>In summary:</p> Entire example <pre><code>import urllib.request, gzip, tempfile, shutil, os\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom rdflib import Graph, URIRef, BNode, Literal\nfrom rdflib.extras.external_graph_libs import rdflib_to_networkx_graph\n\n# Filter predicates for people\nTARGET_PREDICATES = {\n    URIRef(\"http://www.politiquices.pt/ent2_str\"),\n    URIRef(\"http://www.politiquices.pt/ent1_str\"),\n}\n\n# URL to the dataset\nurl = \"https://w3id.org/riverbench/datasets/politiquices/1.0.3/files/jelly_10K.jelly.gz\"\n\n# Load example jelly file\nwith urllib.request.urlopen(url) as r:\n    fd, example_file = tempfile.mkstemp(suffix=\".jelly\")\n    os.close(fd)\n    with gzip.GzipFile(fileobj=r) as g, open(example_file, \"wb\") as out:\n        shutil.copyfileobj(g, out)\n\n# Parse RDF from the Jelly format\nrdf_g = Graph()\nrdf_g.parse(example_file, format=\"jelly\")\nprint(f\"Loaded graph with {len(rdf_g)} instances.\")\n\n# First step for filtering the graph\nrdf_g_filtered = Graph()\nfor s, p, o in rdf_g.triples((None, None, None)):\n    if p in TARGET_PREDICATES:\n        rdf_g_filtered.add((s, p, o))\n\n# Just filtering the graph for clarity of visualization, can be omitted\nrelated = URIRef(\"http://www.politiquices.pt/related\")\nfor b in list(rdf_g_filtered.subjects()):\n    if isinstance(b, BNode):\n        ent1 = ent2 = None\n        for p, o in rdf_g_filtered.predicate_objects(b):\n            if p == URIRef(\"http://www.politiquices.pt/ent1_str\") and isinstance(\n                o, Literal\n            ):\n                ent1 = o\n            elif p == URIRef(\"http://www.politiquices.pt/ent2_str\") and isinstance(\n                o, Literal\n            ):\n                ent2 = o\n        if ent1 and ent2:\n            rdf_g_filtered.add((ent1, related, ent2))\n            rdf_g_filtered.add((ent2, related, ent1))\n        for triple in list(rdf_g_filtered.triples((b, None, None))):\n            rdf_g_filtered.remove(triple)\n\n# Convert to a NetworkX graph\nnx_g = rdflib_to_networkx_graph(rdf_g_filtered)\n\n# Example calculation, get the number of connected components in a graph\nnum_components = nx.number_connected_components(nx_g)\nprint(f\"Connected components: {num_components}\")\n\n# Example calculation, get top 5 objects with highest degrees, simple in NetworkX\ntop5 = sorted(nx_g.degree, key=lambda x: x[1], reverse=True)[:5]\nprint(\"Top 5 nodes sorted by degree:\")\nfor node, deg in top5:\n    print(f\"{node}: {deg}\")\n\n# Helper function\nnorm = (\n    lambda n: str(n.value).strip().lower()\n    if isinstance(n, Literal)\n    else str(n).strip().lower()\n)\n\n# Example calculation, shortest path between two nodes (provided at least two nodes)\nsource = next(n for n in nx_g if norm(n) == \"socrates\")\ntarget = next(n for n in nx_g if norm(n) == \"obama\")\npath = nx.shortest_path(nx_g, source=source, target=target)\nprint(f\"Shortest path from {source} to {target}: {' -&gt; '.join(path)}\")\n\n# Take first 10 nodes\nnodes = list(nx_g)[:10]\nsubg = nx_g.subgraph(nodes)\n\n# Draw and display the graph\npos_sub = nx.spring_layout(subg, k=5, iterations=200, scale=3, seed=24)\nplt.figure(figsize=(10, 10))\n\n# Introduce your own settings for display\nnx.draw_networkx(subg, pos_sub, font_size=14, node_size=220, linewidths=0.7)\nplt.axis(\"off\")\nplt.show()\n\nprint(\"All done.\")\n</code></pre> <p>We converted an RDFLib graph to NetworkX, calculated insightful metrics and visualized the graph.  </p> <p>For more info about the data source please see the Politiquices dataset in RiverBench and its original source (Portuguese).</p>"},{"location":"networkx-integration/#serialize-networkx-graph","title":"Serialize NetworkX graph","text":"<p>This example shows how to write a NetworkX graph to a Jelly file.:</p> <pre><code>import networkx as nx\nfrom rdflib import Graph, URIRef, Namespace\nfrom rdflib.namespace import RDF\n\n# An example NetworkX graph\nnx_g = nx.Graph()\nnx_g.add_node(\"http://example.org/A\")\nnx_g.add_node(\"http://example.org/B\")\nnx_g.add_edge(\"http://example.org/A\", \"http://example.org/B\")\n\n# We define RDFLib graph for further conversion\nrdf_g = Graph()\n\n# Example namespace\nex = Namespace(\"http://example.org/ns#\")\n\n# Add triples through node information in NetworkX graph\nfor node_uri, data in nx_g.nodes(data=True):\n    subj = URIRef(node_uri)\n    rdf_g.add((subj, RDF.type, ex.Node))\n\n# Add triples through edge information in NetworkX graph\nfor u, v, attr in nx_g.edges(data=True):\n    rdf_g.add((URIRef(u), ex.connectedTo, URIRef(v)))\n\n# Serialize graph into a .jelly file\nrdf_g.serialize(destination=\"networkx_graph.jelly\", format=\"jelly\")\nprint(\"All done.\")\n</code></pre> <p>Which converts the NetworkX graph into an RDFLib <code>Graph</code> instance and serializes it.</p>"},{"location":"networkx-integration/#related-sources","title":"Related sources","text":"<p>To get more information, see the following:</p> <ul> <li>NetworkX examples</li> <li>NetworkX repository (github)</li> <li>RDFLib external graph integration</li> </ul>"},{"location":"overview/","title":"Overview and supported features","text":""},{"location":"overview/#what-is-jelly-and-pyjelly","title":"What is Jelly and pyjelly?","text":"<p>Jelly is a high-performance serialization format for RDF knowledge graphs and knowledge graph streams. It's designed to be fast, compact, and flexible. </p> <p>With Jelly, you can transmit both flat and structured streams of triples, quads, graphs, and datasets. Jelly works well in both batch and real-time settings \u2013 including files, sockets, or streaming protocols like Kafka or gRPC.</p> <p>pyjelly is a Python implementation of the Jelly protocol. It provides:</p> <ul> <li>Full support for reading and writing Jelly-encoded RDF data</li> <li>Seamless integration with RDFLib (\"works just like Turtle\")</li> <li>Standalone generic API with no third-party dependencies Generic API</li> <li>Support for all Jelly stream types</li> <li>Tools for working with delimited and non-delimited Jelly streams</li> <li>Fine-grained control over serialization options, compression, and framing</li> </ul>"},{"location":"overview/#overview","title":"Overview","text":""},{"location":"overview/#supported-stream-types","title":"Supported stream types","text":"<p>pyjelly supports all physical stream types: <code>TRIPLES</code>, <code>QUADS</code> and <code>GRAPHS</code>.</p> <p>See the full stream type matrix for an overview of valid combinations.</p>"},{"location":"overview/#conformance-to-the-jelly-specification","title":"Conformance to the Jelly specification","text":"<p>pyjelly is continuously tested for conformance to the Jelly specification. While the vast majority of features are implemented, there are a few edge cases left to resolve.</p> <p>You can track the progress in the conformance test suite definition.</p>"},{"location":"overview/#use-cases","title":"Use cases","text":"<p>Use cases for pyjelly include:</p> <ul> <li>Client-server communication \u2013 link your client app in Python to the server (e.g., Apache Jena, RDF4J) with Jelly to reduce latency and improve user experience.</li> <li>Inter-service communication \u2013 use Jelly to efficiently exchange RDF data between microservices.</li> <li>Data science workflows \u2013 use Jelly to read and write RDF data in data science pipelines, enabling efficient processing of large datasets. <ul> <li>pyjelly is fully streaming, so it can handle large datasets without loading everything into memory at once.</li> <li>We are working on support for pandas and other data science libraries \u2013 stay tuned for updates!</li> </ul> </li> <li>Database dumps and bulk loads \u2013 quickly read and write large RDF datasets with Jelly, reducing storage space and improving database maintenance tasks.</li> </ul>"},{"location":"overview/#pyjelly-integration-with-external-libraries","title":"pyjelly integration with external libraries","text":"<p>To learn how to use popular third-party libraries that connect with RDFLib, please see:</p> <ul> <li>RDFLib-Neo4j integration</li> <li>NetworkX integration</li> </ul>"},{"location":"overview/#generic-api","title":"Generic API","text":"<p>pyjelly includes its own generic API for working with RDF data (no RDFLib or other external RDF libraries required). It provides simple, built-in types for triples and quads, allowing you to create, read, and write data directly in the Jelly format.</p>"},{"location":"rdflib-neo4j-integration/","title":"RDFLib-Neo4j","text":"<p>Info</p> <p>This is an integration with Neo4j via the RDFLib-Neo4j library. It works with all Neo4j instances, including AuraDB, but is limited in features and performance. If you are self-hosting Neo4j (Neo4j Desktop or Community/Enterprise), consider using the Jelly-Neo4j plugin for neosemantics, which offers better performance and more features.</p> <p>RDFLib-Neo4j lets you import RDF triples into Neo4j via the RDFLib API.</p> <p>Install the following library:  </p> <pre><code>pip install pyjelly[rdflib] rdflib-neo4j\n</code></pre>"},{"location":"rdflib-neo4j-integration/#parsing-data-from-a-jelly-file-into-neo4j","title":"Parsing data from a Jelly file into Neo4j","text":"<p>To parse data from a <code>.jelly</code> file into the Neo4j database, use the following example (insert your own credentials to AuraDB):</p> Parsing <pre><code>import urllib.request\nfrom neo4j import GraphDatabase\nfrom rdflib import Graph\nfrom rdflib_neo4j import Neo4jStoreConfig, Neo4jStore, HANDLE_VOCAB_URI_STRATEGY\n\n# Example file from the Riverbench\nexample_file, _ = urllib.request.urlretrieve(\"https://w3id.org/riverbench/v/dev.jelly\")\n\n# Please introduce your credentials\naura_db_uri = \"aura_db_uri\"\naura_db_username = \"neo4j\"\naura_db_pwd = \"aura_db_pwd\"\n\n# Prepare the authentication data to the AuraDB\nauth_data = {\n    \"uri\": aura_db_uri,\n    \"database\": \"neo4j\",\n    \"user\": aura_db_username,\n    \"pwd\": aura_db_pwd,\n}\n\n# Prepare the configuration for Neo4jStore object\nconfig = Neo4jStoreConfig(\n    auth_data=auth_data,\n    handle_vocab_uri_strategy=HANDLE_VOCAB_URI_STRATEGY.IGNORE,\n    batching=True,\n)\n\n# Make a graph with Neo4jStore object\nneo4j_sink = Graph(store=Neo4jStore(config=config))\n\n# Parse the file into the AuraDB\nneo4j_sink.parse(example_file, format=\"jelly\")\n\n# Close the stream\nneo4j_sink.close(True)\n\n# Cypher query to check loaded data\nwith GraphDatabase.driver(\n    aura_db_uri, auth=(aura_db_username, aura_db_pwd)\n).session() as session:\n    count = session.run(\"MATCH ()-[r]-&gt;() RETURN count(r) AS c\").single()[\"c\"]\n    print(f\"Loaded {count} triples\")\n    for r in session.run(\n        \"MATCH (s)-[r]-&gt;(o) RETURN s.uri AS s, type(r) AS p, coalesce(o.uri,o.name) AS o LIMIT 5\"\n    ):\n        print(r[\"s\"], f\"-[{r['p']}]-&gt;\", r[\"o\"])\n\nprint(\"All done.\")\n</code></pre> <p>which inserts your data into your AuraDB database.</p>"},{"location":"rdflib-neo4j-integration/#related-sources","title":"Related sources","text":"<p>For more information, visit:</p> <ul> <li>RDFLib-Neo4j (GitHub)</li> <li>Neo4j Labs: RDFLib-Neo4j</li> <li>Alternative: Jelly-Neo4j plugin for neosemantics</li> </ul>"},{"location":"contributing/","title":"Contributing to pyjelly","text":"<p>Hi! This guide explains how to get started with developing pyjelly and contributing to it.</p>"},{"location":"contributing/#quick-start","title":"Quick start","text":"<p>Clone the project: </p> <pre><code>git clone --recursive git@github.com:Jelly-RDF/pyjelly.git\n</code></pre> <p>We use <code>uv</code> for package management. If you don't already have it, install uv.</p> <p>On Linux this is: </p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Install the project:</p> <pre><code>uv sync\n</code></pre> <p>Note</p> <p>If you use an IDE, make sure that it uses the Python interpreter from the environment that will be created in the <code>.venv</code> directory.</p> <p>If you get an error about the uv version being incorrect, run <code>uv self update</code></p> <p>Activate the environment or use <code>uv run</code> to run commands and code. </p>"},{"location":"contributing/#giving-feedback","title":"Giving feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/Jelly-RDF/pyjelly/issues</p> <p>If you are proposing a feature:</p> <ol> <li>Explain how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Contributions are always welcome! Consider if you can help with implementing the feature.</li> </ol>"},{"location":"contributing/#contributing-code","title":"Contributing code","text":"<p>If you've found a major issue (not just a typo) or have a feature request, please open an issue first. This helps us keep track of what needs to be done and allows others to contribute as well.</p> <p>When opening a pull request:</p> <ul> <li>Use a descriptive title.</li> <li>Clearly describe what the pull request does and why it is needed.</li> <li>Reference the related issue in the description.</li> </ul> <p>The CI will check if your code passes all checks. You can run these checks locally:</p> <ul> <li>Tests: <code>uv run pytest</code></li> <li>Type safety: <code>uv run mypy .</code></li> <li>Linter: <code>uv run ruff check --fix</code></li> <li>Formatter: <code>uv run ruff format</code></li> </ul> <p>This helps us follow best practices and keep the codebase in shape.</p>"},{"location":"contributing/#contributing-documentation","title":"Contributing documentation","text":"<p>The documentation is written in Markdown and built using MkDocs, using Material for MkDocs.</p> <p>To edit a documentation page, simply click the  button in the top-right of the page.</p> <p>It will take you to GitHub, where you can edit the Markdown file and submit a pull request. You can also clone the repository and edit the files locally. The source files are in the <code>docs</code> directory.</p>"},{"location":"contributing/#previewing-documentation-locally","title":"Previewing documentation locally","text":"<p>Install dependencies for docs:</p> <pre><code>uv sync --group docs\n</code></pre> <p>Then, start a local docs server:</p> <pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"contributing/#further-reading","title":"Further reading","text":"<ul> <li>More information on editing Jelly docs</li> <li>Material for MkDocs reference</li> <li>MkDocs documentation</li> <li>Macro plugin documentation</li> </ul>"},{"location":"contributing/#making-releases","title":"Making releases","text":"<ol> <li>Make sure you are on the <code>main</code> branch and that it is up-to-date: <code>git checkout main &amp;&amp; git pull</code>.</li> <li>Create a new tag for the release. For example, for version 1.2.3: <code>git tag v1.2.3</code>. The tag must start with <code>v</code>!</li> <li>Push the tag to GitHub: <code>git push origin v1.2.3</code>.</li> <li>The release will be automatically built and published to PyPI.</li> </ol>"},{"location":"contributing/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"contributing/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at community@neverblink.eu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/code_of_conduct/#attribution","title":"Attribution","text":"<p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"examples/","title":"Index","text":"<p>Code examples for using pyjelly in practice.</p> <p>The examples will be executed in alphabetical order, so you can number them accordingly.</p>"}]}